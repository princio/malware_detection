import csv, os, numpy as np
from enum import Enum
from Model import Model
from math import floor
from DomainLevel import DomainLevel, extractor
import re
import pandas as pd
from keras.preprocessing.sequence import pad_sequences


valid_chars = ['_', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
alphabet = {letter: idx+1 for idx, letter in enumerate(valid_chars)}
alphabet_rev = {idx+1: letter  for idx, letter in enumerate(valid_chars)}

def domain2input(domain):
    try:
        return [alphabet[l] for l in domain.lower().replace('.', '')]
    except:
        print('Error translating <%s>.' % domain)
        return None

def letter2number(value):
    return [alphabet[l] for l in value]

def number2letter(value):
    return ''.join([alphabet_rev[n] for n in value])



def is_right(x):
    distance = abs((0 if x['label'] == 'legit' else 1) - x['probability'])
    rightness = 1 if (x['label'] == 'legit' and x['probability'] < 0.5) or (x['label'] == 'dga' and x['probability'] > 0.5) else 0
    return rightness, distance

def normalcapture_wrongness(x):
    rightness = 1 if x > 0.5 else 0
    distance = 0 if x <= 0.5 else x-0.5
    return rightness, distance


class Input:
    def __init__(self, capture, dl):
        self.capture = capture
        self.dl = dl
        self.X_str = self.capture.domains.apply(dl.translate).rename('input')
        self.X_num = self.X_str.apply(domain2input).to_numpy()
        self.X = pad_sequences(self.X_num, maxlen=Model.MAXLEN, truncating='post')
        self.name = self.capture.name + '.' + self.dl.name

        dir = f'predictions/{self.capture.name}/dl_{self.dl.name}/'
        path = f'{dir}/{self.name}.csv'
        if not os.path.exists(path):
            os.makedirs(dir, exist_ok=True)
            pd.concat([self.capture.readable, self.X_str], axis=1).to_csv(path)
        pass

    @property
    def labeled(self):
        return self.capture.labeled

    @property
    def domains(self):
        return self.capture.domains

    @property
    def tlds(self):
        return self.capture.dls

    @property
    def df(self):
        return pd.concat([self.domains, pd.Series(self.X_str, name='input')], axis=1)


class Output:
    def __init__(self, input, model, predictions, time_elapsed = None):
        self.input = input
        self.model = model
        self.predictions = predictions
        self.time_elapsed = time_elapsed
        self.name = self.input.name + '.' + self.model.name
        pass

    @staticmethod
    def predict(input, model):
        dir = f'predictions/{input.capture.name}/dl_{input.dl.name}/'
        path = f'{dir}/{input.name}.{model.name}.csv'
        if os.path.exists(path):
            predictions = pd.read_csv(path)
        else:
            os.makedirs(dir, exist_ok=True)
            predictions, _ = model.predict(input.X)
            pd.Series(predictions, name='prediction').to_csv(path)

        return Output(input, model, predictions)