import math
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from dash.dependencies import Input, Output
from plotly.subplots import make_subplots
import sqlite3
import pandas as pd
import plotly.express as px
import numpy as np
import plotly.graph_objects as go
import os


db_path = '/media/princio/ssd512/stratosphere/db_3.sqlite3'
dirs = {
    'malware': '/media/princio/ssd512/stratosphere/pcap/csv/malware/',
    'normal': '/media/princio/ssd512/stratosphere/pcap/csv/normal/'
}
pcap_dict = {'normal': {}, 'botnet': {}}
pcap_names = {'normal': {}, 'botnet': {}}


def get_type(pcapname):
    bot_path = os.path.join(dirs['malware'], pcapname)
    nor_path = os.path.join(dirs['normal'], pcapname)
    if os.path.exists(bot_path):
        type_ = 'botnet'
        df_path = bot_path
    elif os.path.exists(nor_path):
        type_ = 'normal'
        df_path = nor_path
    else:
        raise Exception(pcapname + ' does not exists.')
    return type_, df_path


def get_df(pcapname, reload=False):
    if reload:
        type_, df_path = get_type(pcapname)
        pcap_dict[type_][pcapname] = pd.read_csv(
            df_path, usecols=list(range(0, 12)))
        return pcap_dict[type_][pcapname]

    if pcapname in pcap_dict['botnet']:
        return pcap_dict['botnet'][pcapname]
    if pcapname in pcap_dict['normal']:
        return pcap_dict['normal'][pcapname]

    type_, df_path = get_type(pcapname)
    pcap_dict[type_][pcapname] = pd.read_csv(
        df_path, usecols=[2, 3, 6, 8, 9, 10, 11])
    return pcap_dict[type_][pcapname].copy()


if not (os.path.exists('/tmp/df_app.csv') and os.path.exists('/tmp/df_pcap.csv')):

    db = sqlite3.connect(db_path)
    df_pcap = pd.read_sql('SELECT * from pcap', db)
    df_app = pd.read_sql('SELECT * from pcap_queries_3', db)
    db.close()


    df_pcap = df_pcap#.drop(columns=['s_id', 's_win', 'qry/h'])

    df_pcap['name2'] = df_pcap.s_id + '_' + df_pcap.s_win

    df_pcap.set_index('id', inplace=True, drop=False)

    df_app.set_index('query', inplace=True, drop=False)

    df_pcap = df_pcap[(df_pcap.unique > 2000) & (df_pcap.unique < 6000)]

    def f_llr(s_nosfx):
        num = s_nosfx.replace([0, 1], [0.000_000_000_1, 1-0.000_000_000_1])
        den = np.ones(len(num)) - num
        llr = np.log(num/den)
        return num/den, llr

    thresholds = [0, 0.1, 0.25, 0.5, 0.75, 0.9, 0.999]

    for th in thresholds:
        nd1, llr = f_llr(df_app.nosfx.apply(lambda x: 0.5 if x <= th else x))
        df_app['llr_%0.1f' % th] = llr
        df_app['rllr_%0.1f' % th] = llr * df_app.tot
        df_pcap['llr_%0.1f' % th] = 0
        df_pcap['rllr_%0.1f' % th] = 0

    df_pcap['nosfx >.5'] = 0

    bins = np.concatenate([
            np.arange(start=0, stop=0.1, step=0.02),
            [0.1, 0.4, 0.6, 0.9],
            np.arange(start=0.92, stop=1.01, step=0.02)
        ],
        axis=None
    )

    bins = [0, 0.02, 0.9, 0.97, 1]
    bins_high = [0.9, 0.99, 0.999, 0.9999]
    bins_high_labels = [ ('>%f' % high_th).rstrip('0')  for high_th in bins_high ]

    pcap_quartiles = {}
    pcap_high_th = {}
    for pcap_id, pcap in df_pcap.iterrows():
        df_app_pcap = df_app[df_app['pcap_id'] == pcap_id].copy()
        df_pcap.at[pcap_id, 'nosfx >.5'] = df_app_pcap[df_app_pcap['nosfx'] > 0.5].shape[0]
        for th in thresholds:
            df_pcap.at[pcap_id, 'llr_%0.1f' % th] = df_app_pcap['llr_%0.1f' % th].sum()
            df_pcap.at[pcap_id, 'rllr_%0.1f' % th] = df_app_pcap['rllr_%0.1f' % th].sum()
        pcap_quartiles[(pcap['name'], pcap['type'])] = pd.cut(df_app_pcap.nosfx, bins, include_lowest=True).value_counts(normalize=True, sort=False)
        pcap_high_th[pcap_id] = [pcap['name'], pcap['type']] + [ (df_app_pcap.nosfx > high_th).sum() for high_th in bins_high]

    df_pcap_quartiles = pd.DataFrame.from_dict(pcap_quartiles, orient='index')
    df_pcap_quartiles.columns = [ str(c) for c in df_pcap_quartiles.columns.values ]
    df_pcap_high_th = pd.DataFrame.from_dict(pcap_high_th, orient='index', columns=['name', 'type'] + bins_high_labels)
    df_pcap['rllr/llr'] = df_pcap['rllr_0.0'] / df_pcap['llr_0.0']
    df_pcap.to_csv('/tmp/df_pcap.csv')
    df_app.to_csv('/tmp/df_app.csv')
else:
    df_pcap = pd.read_csv('/tmp/df_pcap.csv')



def draw_LLR():
    figures = []

    df_ = df_pcap.copy()

    dfs = {
        '[2000, 6000]': df_,
    }

    for title, df in dfs.items():
        rllr = '<SPAN STYLE="text-decoration:overline">LLR</SPAN>'
        fig = go.Figure()
        nrow = 3
        ncol = 2
        fig = make_subplots(rows=nrow, cols=ncol,
            # shared_yaxes=True,
            horizontal_spacing=0.02,
            vertical_spacing=0.01,
            row_titles=['LLR', rllr, f'{rllr} / LLR'],
            column_titles=['linear scale', 'log scale' ])
        for i, col in enumerate(['llr_0.0', 'rllr_0.0', 'rllr/llr']):
            for j, type in enumerate(['botnet', 'normal']):
                df_ = df[df.type == type].sort_values(by='unique')
                scatter = go.Scatter(
                    x=df_.unique,
                    y=df_[col],
                    hovertext=df_.name,
                    mode='markers',
                    name=type,
                    marker=dict(
                        color=dict(botnet='blue', normal='red')[type], 
                        opacity=dict(botnet=0.25, normal=0.75)[type], 
                        symbol=dict(botnet='circle', normal='cross')[type]),
                    line=dict(width=0.5, color=dict(botnet='rgba(0,0,255,0.75)', normal='rgba(255,0,0,1)')[type]),
                    showlegend=(i == 0)
                )
                fig.add_trace(scatter, row=i+1, col=1)
                scatter['showlegend'] = False
                fig.add_trace(scatter, row=i+1, col=2)
                fig.update_xaxes(type="log", row=i+1, col=2)
        fig.update_layout(
            title=f'{title}: y: LLR and {rllr}; x: unique',
            # width=1200,
            height=1200)
        figures.append(fig)

    table = html.Div([dash_table.DataTable(
                id='llr-pcap.table',
                columns=[
                    {'name': i, 'id': i, 'deletable': True} for i in df_pcap.columns
                ],
                data=df_pcap.to_dict('records'),
                editable=True,
                filter_action="native",
                sort_action="native",
                sort_mode='multi',
                page_action='none',
                style_table={'height': '300px', 'overflowY': 'auto', 'overflowX': 'auto'},
                style_cell={
                    'overflow': 'hidden',
                    'textOverflow': 'ellipsis',
                    'maxWidth': 0
                }
            ),
    ])


    return [dcc.Graph(figure=fig) for fig in figures] + [table]


def draw_pcap_bar():
    figures = []

    df = df_pcap.sort_values(by='unique')

    df.name = df.name.str.replace('.pcap.csv', '')
    fig = make_subplots(
        rows=2, cols=1,
        shared_xaxes=True,
        horizontal_spacing=0.02,
        vertical_spacing=0.01,
        row_titles=['<i>n</i>', '<i>LLR</i>'],
        specs=[
            [{"type": "scatter"}],
            [{"type": "scatter"}]
            ]
        )
    fig.add_trace(go.Bar(
        x=df.name2,
        y=df.unique,
        name='<i>n</i>',
        marker_color=df.type.apply(lambda x: dict(botnet='blue', normal='red')[x]),
        base=0
        ),
        row=1, col=1
    )
    fig.add_trace(go.Bar(
        x=df.name2,
        y=df['llr_0.0'],
        name='LLR',
        marker_color=df.type.apply(lambda x: dict(botnet='blue', normal='red')[x]),
        base=0
        ),
        row=2, col=1
    )

    df['type2'] = df.type.apply(lambda x: dict(botnet='blue', normal='red')[x])
    fig.update_layout(
        height=800,
        width=1600,
        # xaxis_tickangle=-90,
        showlegend=False
    )
    fig.update_xaxes(
        tickangle=-45,
        row=2, col=1
    )
    fig.update_yaxes(
        title='<i>n</i>',
        row=1, col=1
    )
    fig.update_yaxes(
        title='<i>LLR</i>',
        row=2, col=1
    )

    figures.append(fig)

    df = df[['name2', 'unique', 'llr_0.0']].set_index('name2').T

    print(df)

    # table = html.Div([dash_table.DataTable(
    #             id='llr-table',
    #             columns=[
    #                 {'name': i, 'id': i} for i in df.columns
    #             ],
    #             data=df.to_dict('records'),
    #             # style_table={'height': '300px', 'overflowY': 'auto', 'overflowX': 'auto'},
    #             style_cell={
    #                 'overflow': 'hidden',
    #                 'transform': 'rotate(-90deg)',
    #                 'width': '5px',
    #                 'height': '50px',
    #                 'white-space': 'nowrap'
    #             }
    #         ),
    # ])

    return [dcc.Graph(figure=fig) for fig in figures]


app = dash.Dash(__name__)

app.layout = html.Div([
    # html.Div(
    #     draw_LLR(),
    #     id='LLR-container'
    # ),
    html.Div(
        draw_pcap_bar(),
        id='bar-container'
    ),
    # html.Div(
    #     draw_pcap_nosfx_distribution(),
    #     id='pcap-nosfx-distribution-container'
    # ),
    # html.Div(
    #     draw_pcap_scatter(),
    #     id='pcap-container'
    # ),
])

if __name__ == '__main__':
    app.run_server(debug=False)
