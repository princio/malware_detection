from Capture import normal, mixed, botnet, training, Capture
from IO import Input, Output, DF
from Model import Model
from DomainLevel import Transformer
import numpy as np
import pandas as pd

# def predict_all_standard():
#     models = [ Model.load(DomainLevel.LOWERT), Model.load(DomainLevel.LOWER), Model.load(DomainLevel.SIDE) ]
#     dls = DomainLevel.all()
#     dls.remove(DomainLevel.WHOLE)
#     captures = []
#     captures += [normal[name] for name in normal]
#     captures += [mixed[name] for name in mixed]
#     captures += [botnet[name] for name in botnet]
#     captures.append(training)
    
#     for capture in captures:
#         for dl in dls:
#             input = Input(capture, dl)
#             for model in models:
#                 print(f'Predicting {input.name} with {model.name}...')
#                 Output.predict(input, model)

def predict_all():
    model = Model.load(Transformer.NOTLD)
    dls = [ Transformer.NOTLD, Transformer.DOMAIN, Transformer.SUBDOMAIN ]
    captures = []
    captures += [normal[name] for name in normal]
    captures += [mixed[name] for name in mixed]
    captures += [botnet[name] for name in botnet]
    captures.append(training)
    
    for capture in captures:
        for dl in dls:
            input = Input(capture, dl)
            print(f'Predicting {input.name} with {model.name}...')
            Output.predict(input, model, redo=True)

def predict_normal():

    captures = [normal[name] for name in normal]

    models = [Model.load(1), Model.load(2), Model.load(-3)]
    trs= [ Transformer.NOSFX, Transformer.NOSFX_NP, Transformer.DOMAIN, Transformer.LAST ]

    dfs = []
    false_dga = {}
    false_dga_levels = {}
    false_dga_levels_dn = {}
    for capture in captures:
        for tr in trs:
            false_dga[(capture.name, tr.name)] = {}
            for model in models:
                input  = Input(capture, tr)
                output = Output.predict(input, model, False)
                output.threshold = 0.5
                dfs.append(output.DF)
                false_dga[(capture.name, tr.name)][('frac', model.name)] = output.DF.unique().dga_frac
                if tr.name not in ['DOMAIN', 'LAST']:
                    false_dga_levels[(capture.name, tr.name, model.name)] = output.DF.unique().level_count.T.to_dict()
                    false_dga_levels_dn[(capture.name, tr.name, model.name)] = output.DF.unique().level_count_dn.T.to_dict()
    
    DF.compare(dfs)

    print('%50s\t\t%8s\t%8s\t%8s' % ('', '1', '2', '>3'))
    for k in false_dga_levels:
        ss = ''
        for l in false_dga_levels[k]:
            ss += '%0.8f\t' % (false_dga_levels[k][l])
        print('%50s\t\t%s' %(k, ss))

    print('%50s\t\t%8s\t%8s\t%8s' % ('', '1', '2', '>3'))
    for k in false_dga_levels_dn:
        ss = ''
        for l in false_dga_levels_dn[k]:
            ss += '%0.8f\t' % (false_dga_levels_dn[k][l])
        print('%50s\t\t%s' %(k, ss))
    # print(pd.DataFrame(false_dga_levels).to_markdown())
    # print(pd.DataFrame(false_dga_levels).to_clipboard())

        # X = input.X
        # model.load_model()
        # nn = model.nn
        # Y = nn.predict(X)
        # df = pd.DataFrame({'X': X, 'Y': Y[:,0] })
        # df_unique = df.drop_duplicates()
        # df_wrong = df_unique.loc[df_unique['Y'] >= 0.5]
        # print(df, df_unique, df_wrong)
        # print(df_wrong.shape[0]/df_unique.shape[0])
        # print(df_wrong.shape[0]/df_unique.shape[0])



if __name__ == "__main__":

    predict_normal()

    pass