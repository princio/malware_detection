from Capture import normal, mixed, botnet, training, Capture
from IO import Input, Output
from Model import Model
from DomainLevel import Transformer
import numpy as np
import pandas as pd

# def predict_all_standard():
#     models = [ Model.load(DomainLevel.LOWERT), Model.load(DomainLevel.LOWER), Model.load(DomainLevel.SIDE) ]
#     dls = DomainLevel.all()
#     dls.remove(DomainLevel.WHOLE)
#     captures = []
#     captures += [normal[name] for name in normal]
#     captures += [mixed[name] for name in mixed]
#     captures += [botnet[name] for name in botnet]
#     captures.append(training)
    
#     for capture in captures:
#         for dl in dls:
#             input = Input(capture, dl)
#             for model in models:
#                 print(f'Predicting {input.name} with {model.name}...')
#                 Output.predict(input, model)

def predict_all():
    model = Model.load(Transformer.NOTLD)
    dls = [ Transformer.NOTLD, Transformer.DOMAIN, Transformer.SUBDOMAIN ]
    captures = []
    captures += [normal[name] for name in normal]
    captures += [mixed[name] for name in mixed]
    captures += [botnet[name] for name in botnet]
    captures.append(training)
    
    for capture in captures:
        for dl in dls:
            input = Input(capture, dl)
            print(f'Predicting {input.name} with {model.name}...')
            Output.predict(input, model, redo=True)

def predict_normal():

    captures = [normal[name] for name in normal]

    models = [Model.load(1), Model.load(2), Model.load(-3)]
    trs= [ Transformer.NOSFX, Transformer.NOSFX_NP, Transformer.DOMAIN, Transformer.LAST ]

    results = {}
    for capture in captures:
        for tr in trs:
            results[(capture.name, tr.name)] = {}
            for model in models:
                input  = Input(capture, tr)
                output = Output.predict(input, model, False)
                output.threshold = 0.5
                results[(capture.name, tr.name)][model.name] = output.DF.unique().dga_frac
    
    print(pd.DataFrame(results).to_markdown())
    print(pd.DataFrame(results).to_clipboard())

        # X = input.X
        # model.load_model()
        # nn = model.nn
        # Y = nn.predict(X)
        # df = pd.DataFrame({'X': X, 'Y': Y[:,0] })
        # df_unique = df.drop_duplicates()
        # df_wrong = df_unique.loc[df_unique['Y'] >= 0.5]
        # print(df, df_unique, df_wrong)
        # print(df_wrong.shape[0]/df_unique.shape[0])
        # print(df_wrong.shape[0]/df_unique.shape[0])



if __name__ == "__main__":

    predict_normal()

    pass