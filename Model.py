import numpy as np
from collections import OrderedDict
from keras.preprocessing import sequence
import time
from keras.models import model_from_json
from sklearn.metrics import confusion_matrix, precision_score, recall_score, classification_report, accuracy_score, f1_score

class Model:
    def __init__(self):
        self.id = None
        self.hash = None
        self.path = None
        self.training_set = None
        self.test_size = 0.05
        self.training_dataset = "setAtrain_h_t_domins"
        self.datetime = None
        self.classes = []
        self.epochs = None
        self.folds = None
        self.epoch = None
        self.fold = None
        self.training_confusion_matrix = None
        self.average = []

        self.nn = None

    @staticmethod
    def fetch(connection, id):
        cursor = connection.cursor()
        cursor.execute("""SELECT id, hash, path, training_set, test_size, training_dataset, datetime, classes, epochs, folds, epoch, fold, training_confusion_matrix, average
                            FROM public.models WHERE id = %s;""", (id, ))
                            
        return Model.fill(cursor.fetchone())

    @staticmethod
    def fill(fetched):
        fetched = list(fetched)

        model = Model()
        model.id = fetched.pop(0)
        model.hash = fetched.pop(0)
        model.path = fetched.pop(0)
        model.training_set = fetched.pop(0)
        model.test_size = fetched.pop(0)
        model.training_dataset = fetched.pop(0)
        model.datetime = fetched.pop(0)
        model.classes = fetched.pop(0)
        model.epochs = fetched.pop(0)
        model.folds = fetched.pop(0)
        model.epoch = fetched.pop(0)
        model.fold = fetched.pop(0)
        confusion_matrix = fetched.pop(0)
        if confusion_matrix is not None:
            model.training_confusion_matrix = np.asfarray(confusion_matrix).reshape(len(model.classes), len(model.classes))
        model.average = fetched.pop(0)

        return model

    def save(self, connection):
        cursor = connection.cursor()
        cursor.execute("""INSERT INTO public.models
	                        (hash, path, training_set, test_size, training_dataset, datetime, classes, epochs, folds, epoch, fold, training_confusion_matrix)
	                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING id;""",
                        (self.hash, self.path, self.training_set, self.test_size, self.training_dataset,
                        self.datetime, self.classes, self.epochs, self.folds, self.epoch, self.fold,
                        self.training_confusion_matrix))
        self.id = cursor.fetchone()[0]
        connection.commit()

    def save_average(self, connection):
        cursor = connection.cursor()
        cursor.execute("""UPDATE public.models SET average=%s WHERE id=%s;""",
                        (self.average, self.id))
        connection.commit()

    def load_model(self):
        if self.nn is not None: return
        with  open("%s.json" % self.path, 'r') as json_file:
            loaded_model_json = json_file.read()
        self.nn = model_from_json(loaded_model_json)
        self.nn.load_weights("%s.h5" % self.path)

    def test(self, dataset):
        
        self.load_model()

        indata = dataset.data()
        binary_labels = [x[0] for x in indata]
        X = [x[2] for x in indata]
        valid_chars = {x: idx + 1 for idx, x in enumerate(OrderedDict.fromkeys(''.join(X)))}
        maxlen = np.max([len(x) for x in X])
        X_test = [[valid_chars[y] for y in x] for x in X]
        X_test = sequence.pad_sequences(X_test, maxlen=maxlen)
        y_test = np.array([0 if x == 'legit' else 1 for x in binary_labels])
        
        time_elapsed = time.time()
        y_pred = self.nn.predict(X_test)
        time_elapsed = time.time() - time_elapsed

        y_pred = [0 if (x <= 0.5) else 1 for x in y_pred]

        y_test = np.array(y_test).ravel()

        confusion_matrix_ = confusion_matrix(y_test, y_pred)

        return confusion_matrix_, time_elapsed

    def __str__(self):
        return self.path.split('/')[-1]
