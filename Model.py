import numpy as np
from collections import OrderedDict, Counter as collection_counter
from keras.preprocessing import sequence
import time
from keras.models import model_from_json
from sklearn.metrics import confusion_matrix, precision_score, recall_score, classification_report, accuracy_score, f1_score
from json import load as json_load
from Dataset import Dataset

with open("models/alphabet.json", "r") as json_file:
    ALPHABET = json_load(json_file)

class Model:

    SELECT = """SELECT id, hash, path, training_set, test_size_folds, test_size_epochs, datetime,
                classes, epochs, folds, epoch, fold, dataset_train, dataset_test, average
                FROM public.models """

    def __init__(self):
        self.id = None
        self.hash = None
        self.path = None
        self.training_set = None
        self.test_size_folds = 0.05
        self.test_size_epochs = 0.05
        self.training_dataset = "setAtrain_h_t_domins"
        self.datetime = None
        self.classes = []
        self.epochs = None
        self.folds = None
        self.epoch = None
        self.fold = None
        self.dataset_train = None
        self.dataset_test = None
        self.average = []

        self.nn = None

    @staticmethod
    def fetch(connection, id):
        cursor = connection.cursor()
        cursor.execute("""SELECT id, hash, path, training_set, test_size_folds, test_size_epochs, datetime, classes, epochs, folds, epoch, fold, dataset_train, dataset_test, average
                            FROM public.models WHERE id = %s;""", (id, ))
                            
        return Model.fill(connection, cursor.fetchone())

    @staticmethod
    def fill(connection, fetched):
        fetched = list(fetched)

        model = Model()
        model.id = fetched.pop(0)
        model.hash = fetched.pop(0)
        model.path = fetched.pop(0)
        model.training_set = fetched.pop(0)
        model.test_size_folds = fetched.pop(0)
        model.test_size_epochs = fetched.pop(0)
        model.datetime = fetched.pop(0)
        model.classes = fetched.pop(0)
        model.epochs = fetched.pop(0)
        model.folds = fetched.pop(0)
        model.epoch = fetched.pop(0)
        model.fold = fetched.pop(0)
        model.dataset_train = Dataset.fetch(connection, fetched.pop(0))
        model.dataset_test = Dataset.fetch(connection, fetched.pop(0))
        model.average = fetched.pop(0)

        return model

    def save(self, connection):
        cursor = connection.cursor()
        cursor.execute("""INSERT INTO public.models
	                        (hash, path, training_set, test_size_folds, test_size_epochs, datetime, classes, epochs, folds, epoch, fold, dataset_train, dataset_test)
	                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s) RETURNING id;""",
                        (self.hash, self.path, self.training_set, self.test_size_folds, self.test_size_epochs, 
                        self.datetime, self.classes, self.epochs, self.folds, self.epoch, self.fold, self.dataset_train.id, self.dataset_test.id))
        self.id = cursor.fetchone()[0]
        connection.commit()

    def save_average(self, connection):
        cursor = connection.cursor()
        cursor.execute("""UPDATE public.models SET average=%s WHERE id=%s;""",
                        (self.average, self.id))
        connection.commit()

    def load_model(self):
        if self.nn is not None: return
        with  open("%s.json" % self.path, 'r') as json_file:
            loaded_model_json = json_file.read()
        self.nn = model_from_json(loaded_model_json)
        self.nn.load_weights("%s.h5" % self.path)

    def test(self, dataset):
        self.load_model()
        indata = dataset.data()
        binary_labels = [x[0] for x in indata]
        X = [x[2] for x in indata]

        maxlen = np.max([len(x) for x in X])
        X_test = [[ALPHABET[y] for y in x] for x in X]
        X_test = sequence.pad_sequences(X_test, maxlen=maxlen)
        y_test = np.array([0 if x == 'legit' else 1 for x in binary_labels])
        
        time_elapsed = time.time()
        y_pred = self.nn.predict(X_test)
        time_elapsed = time.time() - time_elapsed

        y_pred = [0 if (x <= 0.5) else 1 for x in y_pred]

        y_test = np.array(y_test).ravel()

        confusion_matrix_ = confusion_matrix(y_test, y_pred)

        return confusion_matrix_, time_elapsed

    def name(self):
        return "%d_%d" % (self.folds, self.epoch)

    def __str__(self):
        return self.path.split('/')[-1]
