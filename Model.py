import numpy as np
from collections import OrderedDict
from keras.preprocessing import sequence
import time
from keras.models import model_from_json
from sklearn.metrics import confusion_matrix, precision_score, recall_score, classification_report, accuracy_score, f1_score

class Model:
    def __init__(self):
        self.id = None
        self.hash = None
        self.path = None
        self.training_set = None
        self.test_size = 0.05
        self.training_dataset = "setAtrain_h_t_domins"
        self.datetime = None
        self.multiclass = False
        self.epochs = None
        self.folds = None
        self.epoch = None
        self.fold = None
        self.nn = None

    @staticmethod
    def fetch(connection, id):
        cursor = connection.cursor()
        cursor.execute("""SELECT id, hash, path, training_set, test_size, training_dataset, datetime, multiclass, epochs, folds, epoch, fold
                            FROM public.models WHERE id = %s;""", (id, ))
                            
        fetched = list(cursor.fetchone())
        model = Model()
        model.id = fetched.pop(0)
        model.hash = fetched.pop(0)
        model.path = fetched.pop(0)
        model.training_set = fetched.pop(0)
        model.test_size = fetched.pop(0)
        model.training_dataset = fetched.pop(0)
        model.datetime = fetched.pop(0)
        model.multiclass = fetched.pop(0)
        model.epochs = fetched.pop(0)
        model.folds = fetched.pop(0)
        model.epoch = fetched.pop(0)
        model.fold = fetched.pop(0)

        return model

    def save(self, connection):
        cursor = connection.cursor()
        cursor.execute("""INSERT INTO public.models
	                        (hash, path, training_set, test_size, training_dataset, datetime, multiclass, epochs, folds, epoch, fold)
	                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s);""",
        (self.hash, self.path, self.training_set, self.test_size, self.training_dataset, self.datetime, self.multiclass, self.epochs, self.folds, self.epoch, self.fold))
        connection.commit()

    def load_model(self):
        if self.nn is not None: return
        with  open("%s.json" % self.path, 'r') as json_file:
            loaded_model_json = json_file.read()
        self.nn = model_from_json(loaded_model_json)
        self.nn.load_weights("%s.h5" % self.path)

    def test(self, dataset, report):
        self.load_model()

        indata = dataset.data()
        binary_labels = [x[0] for x in indata]
        X = [x[2] for x in indata]
        valid_chars = {x: idx + 1 for idx, x in enumerate(OrderedDict.fromkeys(''.join(X)))}
        maxlen = np.max([len(x) for x in X])
        X_test = [[valid_chars[y] for y in x] for x in X]
        X_test = sequence.pad_sequences(X_test, maxlen=maxlen)
        y_test = np.array([0 if x == 'legit' else 1 for x in binary_labels])
        
        time_elapsed = time.time()
        y_pred = self.nn.predict(X_test)
        report.time_elapsed = time.time() - time_elapsed

        y_pred = [0 if (x <= 0.5) else 1 for x in y_pred]

        y_test = np.array(y_test).ravel()

        # print(confusion_matrix(y_test, y_pred))
        # print(classification_report(y_test, y_pred, target_names=[ 'legit', 'malware' ], digits=6))
        print("precision: %f" % precision_score(y_test, y_pred, average='micro'))
        print("   recall: %f" % recall_score(y_test, y_pred, average='micro'))
        print("       f1: %f" % f1_score(y_test, y_pred, average='micro'))

        report.confusion_matrix = confusion_matrix(y_test, y_pred).ravel()

    def __str__(self):
        return self.path.split('/')[-1]
