import csv, os, numpy as np
from enum import Enum
from Model import Model
from math import floor
from DomainLevel import DomainLevel, extractor
import re
import pandas as pd
from keras.preprocessing.sequence import pad_sequences


valid_chars = ['_', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
alphabet = {letter: idx+1 for idx, letter in enumerate(valid_chars)}
alphabet_rev = {idx+1: letter  for idx, letter in enumerate(valid_chars)}

def domain2input(domain):
    return [alphabet[l] for l in domain.lower().replace('.', '')]

def letter2number(value):
    return [alphabet[l] for l in value]

def number2letter(value):
    return ''.join([alphabet_rev[n] for n in value])



def is_right(x):
    distance = abs((0 if x['label'] == 'legit' else 1) - x['probability'])
    rightness = 1 if (x['label'] == 'legit' and x['probability'] < 0.5) or (x['label'] == 'dga' and x['probability'] > 0.5) else 0
    return rightness, distance

def normalcapture_wrongness(x):
    rightness = 1 if x > 0.5 else 0
    distance = 0 if x <= 0.5 else x-0.5
    return rightness, distance


class Input:
    def __init__(self, capture, dl):
        self.capture = capture
        self.dl = dl
        self.X_str = self.capture.translate(dl)
        self.X_num = self.X_str.apply(domain2input).to_numpy()
        self.X = pad_sequences(self.X_num, maxlen=Model.MAXLEN, truncating='post')
        self.name = self.capture.name + '.' + self.dl.name
        pass

    @property
    def labeled(self):
        return self.capture.labeled

    @property
    def domains(self):
        return self.capture.domains

    @property
    def tlds(self):
        return self.capture.dls

    @property
    def df(self):
        return pd.concat([self.domains, pd.Series(self.X_str, name='input')], axis=1)


class Output:
    def __init__(self, input, model, predictions, time_elapsed = None):
        self.input = input
        self.model = model
        self.predictions = predictions
        self.time_elapsed = time_elapsed
        self.name = self.input.name + '.' + self.model.name
        pass

    @staticmethod
    def predict(input, model):
        path = 'outputs/{model.name}/{input.capture.name}/{input.capture.dl.name}.csv'
        if os.path.exists(path):
            df = pd.read_csv(path)
            predictions = df['predictions']
        else:
            predictions, _ = model.predict(input.X)
            df = pd.concat([input.df, pd.Series(predictions, name='prediction')])
            df.to_csv(path)

        return Output(input, model, predictions)

class Prediction:

    def __init__(self, model, input):
        self.input = Input(capture, dl)
        self.model = model
        self.probabilities = probabilities
        self.time_elapsed = time_elapsed
        pass

    @property
    def name(self):
        return f'{self.input.name}__{self.model.dl.name}'

    @property
    def values(self):
        df = self.df()
        return df[['probability', 'wrong', 'distance']]

    def df(self):
        df = pd.concat([self.input.domains, self.input.inputs, self.probabilities], axis=1)
        if self.input.labeled:
            df['wrong'], df['distance'] = zip(*df[['label', 'probability']].apply(is_right, axis=1))
        else:
            df['wrong'], df['distance'] = zip(*df['probability'].apply(normalcapture_wrongness))

        return df

    def save(self):
        capture_name = self.input.capture.name
        if not os.path.exists(f'predictions/{capture_name}'):
            os.makedirs(f'predictions/{capture_name}')
        out_path = "predictions/%s/%s.dl_%s.model_%s.csv" % (capture_name, capture_name, self.input.dl.name, self.model.dl.name)
        print('Saving output to ' + out_path)
        df = self.df()
        df.to_csv(out_path)
        pass
    
    @staticmethod
    def load_by_name(name):
        match = re.match(r'(\w+).dl_(\w+).model_(\w+).csv', name)
        capture = Capture.load(match.group(0))
        dl = DomainLevel[match.group(1)]
        model = Model.load(match.group(2))
        return Prediction.load(capture, dl, model)

    @staticmethod
    def load(capture, dl, model):
        path = f'predictions/{capture.name}/{capture.name}.dl_{dl.name}.model_{model.dl.name}.csv'
        if not os.path.exists(path):
            return False
        df = pd.read_csv(path)
        inputs = df['input']
        probabilities = df['probability']
        return Prediction(capture, dl, model, inputs, probabilities)

class MultiPrediction:

    def __init__(self, capture):
        self.capture = capture
        self.predictions = []
        pass

    def path(self, append = '', ext = 'csv'):
        if not os.path.exists(f'predictions/{self.capture.name}'):
            os.makedirs(f'predictions/{self.capture.name}')
        return 'predictions/%s/%s.multi%s%s.%s' % (self.capture.name, self.capture.name, '.' if append != '' else '', append, ext)

    def df(self):
        df = self.capture.domains
        ps = {p.name: p.values for p in self.predictions}
        df = pd.concat([df] + list(ps.values()), keys=['input'] + list(ps.keys()), axis=1)
        return df

    def save(self):
        df = self.df()
        df.to_csv(self.path())
        return df

    def calc(self):
        df = self.df()
        df.insert(2, ('tld', 'name'), self.capture.tlds)
        tld_counts = df[('tld', 'name')].value_counts(sort=False)
        df_grp = df.groupby(('tld', 'name'))
        df_grps = {}

        with pd.ExcelWriter(self.path('grp', 'xlsx')) as writer:
            for agg in ['mean', 'sum']:
                df_grp_agg = df_grp.aggregate(agg)
                df_grp_agg.index.name = ('tld', 'name')
                df_grp_agg.insert(loc=0, column=('tld', 'num'), value=tld_counts)
                df_grp_agg.set_index([('tld', 'num')], append=True, inplace=True)
                df_grp_agg.loc[('all', 0),:] = df_grp_agg.sum(numeric_only=True, axis=0)
                df_grp_agg.sort_values(by=('all', 0), axis=1, inplace=True)
                df_grp_agg.to_excel(writer, sheet_name=agg)
                df_grps[agg] = df_grp_agg
        
        with pd.ExcelWriter(self.path('grp_splitted', 'xlsx')) as writer:
                metrics = ['distance', 'probability', 'wrong']
                for agg in ['mean', 'sum']:
                    df_grps[agg].to_excel(writer, sheet_name=f'total_{agg}')
                    for metric in metrics:
                        df_grps[agg].drop(level=1, columns=[m for m in metrics if m != metric]).to_excel(writer, sheet_name=f'{metric}.{agg}')


    def add(self, prediction):
        self.predictions.append(prediction)
        pass

class Predictor():
    DOMAIN = 0
    INPUT = 1
    PREDICTION = 2

    def __init__(self, dl, capture):
        self.dl = dl
        self.capture = capture
        self.inputs = self.capture.translate(dl)
        self.X = self.inputs.apply(domain2input).to_numpy()
        self.time_elapsed = None
        pass

    def predict(self, model, save = True):
        prediction = Prediction.load(self.capture, self.dl, model)
        if not prediction:
            probabilities, time_elapsed = model.predict(self.X)
            probabilities = pd.Series(probabilities[:,0], name='probability')
            prediction = Prediction(self.capture, self.dl, model, self.inputs, probabilities, time_elapsed)
            if save:
                prediction.save()
        return prediction


class MultiPredictor():
    DOMAIN = 0
    INPUT = 1
    PREDICTION = 2

    def __init__(self, dls, models, capture):
        self.models = models
        self.dls = dls
        self.capture = capture
        self.predictors = {}
        for dl in dls:
            self.predictors[dl] = Predictor(dl, capture)
        pass

    def predict(self, save = True):
        mp = MultiPrediction(self.capture)
        for dl in self.dls:
            for model in self.models:
                mp.add(self.predictors[dl].predict(model))
        mp.save()
        mp.calc()
        return mp

class MultiPredictor2():
    def __init__(self, capture, models):
        self.models = models
        self.inputs = {}
        for dl in DomainLevel.all():
            self.inputs[dl] = Input(capture, dl)
            self.predictions[dl] = Prediction(self.inputs[dl])
        self.models = models
        self.capture = capture
        self.outputs = {}
        pass

    def predict(self, save = True):
        for model in self.models:
            prediction = Prediction(model, input)
            for input in self.inputs:
                output = Output.predict(input, model)
                self.outputs[output.name] = output