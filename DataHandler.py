import csv, os, numpy as np
from enum import Enum
from Model import Model
from math import floor
from DomainLevel import DomainLevel
import re
import pandas as pd


valid_chars = ['_', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
alphabet = {letter: idx+1 for idx, letter in enumerate(valid_chars)}
alphabet_rev = {idx+1: letter  for idx, letter in enumerate(valid_chars)}

def domain2input(domain):
    return [alphabet[l] for l in domain.lower().replace('.', '')]

def letter2number(value):
    return [alphabet[l] for l in value]

def number2letter(value):
    return ''.join([alphabet_rev[n] for n in value])


class Capture():
    NUM = 0
    TIME = 1
    DOMAIN = 2
    LABEL = 3

    def __init__(self, dataframe, name):
        if not all(column in dataframe.columns for column in ['num', 'time', 'domain']):
            raise 'Incorrect table, missing some column'
        self.dataframe = dataframe
        self.name = name
        self.labeled = 'label' in dataframe.columns

    def translate(self, dl):
        return self.dataframe['domain'].apply(dl.translate).rename('input')

    def domains(self):
        if self.labeled:
            return self.dataframe[['domain', 'label']]
        return self.dataframe['domain']

    @staticmethod
    def load(name):
        path = f'captures/{name}.capture.csv'
        if not os.path.exists(path):
            return False
        return Capture(pd.read_csv(path), name)


class Predictor():
    DOMAIN = 0
    INPUT = 1
    PREDICTION = 2

    def __init__(self, dl, capture):
        self.dl = dl
        self.capture = capture
        self.inputs = None
        self.X = None
        self.time_elapsed = None
        self.prepared = False
        pass

    def prepare(self):
        if not self.prepared:
            self.inputs = self.capture.translate(self.dl)
            self.X = self.inputs.apply(domain2input).to_numpy()

    def predict(self, model, save = True):
        prediction = Prediction.load(self.capture, self.dl, model)
        if not prediction:
            self.prepare()
            probabilities, time_elapsed = model.predict(self.X)
            probabilities = pd.Series(probabilities[:,0], name='prediction')
            prediction = Prediction(self.capture, self.dl, model, self.inputs, probabilities, time_elapsed)
            if save:
                prediction.save()
        return prediction

class Prediction:

    def __init__(self, capture, dl, model, inputs, probabilities, time_elapsed = None):
        self.capture = capture
        self.dl = dl
        self.model = model
        self.inputs = inputs
        self.probabilities = probabilities
        self.time_elapsed = time_elapsed
        pass

    @property
    def df(self):
        return pd.concat([self.capture.domains(), self.inputs, self.probabilities], axis=1)

    def save(self):
        out_path = "predictions/%s.dl_%s.model_%s.tested.csv" % (self.capture.name, self.dl.name, self.model.dl.name)
        print('Saving output to ' + out_path)
        pd.concat([self.capture.domains(), self.inputs, self.probabilities], axis=1).to_csv(out_path)
        pass
    
    @staticmethod
    def load_by_name(name):
        match = re.match(r'(\w+).dl_(\w+).model_(\w+).csv', name)
        capture = Capture.load(match.group(0))
        dl = DomainLevel[match.group(1)]
        model = Model.load(match.group(2))
        return Prediction.load(capture, dl, model)

    @staticmethod
    def load(capture, dl, model):
        path = f'predictions/{capture.name}.dl_{dl.name}.model_{model.dl.name}.csv'
        if not os.path.exists(path):
            return False
        df = pd.read_csv(path)
        inputs = df['input']
        probabilities = df['probability']
        return Prediction(capture, dl, model, inputs, probabilities)

    # def group(self):
    #     dataout = pd.concat([self.capture.domains['domain'], self.predictions], axis=1, names=['domain', 'prediction']).groupby("domain").agg(['mean', 'count'])
    #     dataout.insert(loc=0, column='dl', value=[self.dl.name] * dataout.shape[0])
    #     dataout.insert(loc=1, column='input', value=dataout.index.to_series().apply(self.dl.translate))
    #     dataout.set_index(['dl', 'input'], append=True, inplace=True)
    #     return dataout

    # def load(self):
    #     if os.path.exists(self.path()):
    #         self.predictions = pd.read_csv(self.path(), names=["domain", "input", "prediction"])['prediction']
    #         return True
    #     return False

    # @staticmethod
    # def from_path(path):
    #     dir_path = path[path.rindex('/') + 1:]
    #     csv_filename = path[: path.rindex('/') + 1]
    #     matches = re.search('(.*?)__(.*?)__(.*?).out.csv', csv_filename)
    #     if len(matches) != 4:
    #         print(f'Prediction path {csv_filename} not match')
    #         return False
    #     capture = Capture.from_path(dir_path + matches[0] + '.csv')
    #     model = Model.from_name(matches[1])
    #     dl = DomainLevel.parse(matches[2])

    #     return Prediction(model, dl, capture)

# class Predictor:
#     def __init__(self, capture: Capture):
#         self.capture = capture
#         self.time_elapsed = None
#         self.data_out = None

#     def predict_multi(self, models: Model, dls, batch_size = 100*1000, redo = False):
#         dls = DomainLevel.all()
#         # columns = list(zip(*[
#         #     [t1 for t3 in [[dl.name]*len(models) for dl in dls] for t1 in t3],
#         #     [t1 for t1 in len(dls)*[model.dl.name for model in models]]
#         # ]))
#         # mi = pd.MultiIndex.from_product([[m.name for m in models], [dl.name for dl in dls], ['input', 'mean', 'count']], names=['model', 'type', 'value'])
        
#         dataouts = []
#         for dl in dls:
#             model_dataouts = None
#             for model in models:
#                 dataout = Prediction(model, dl, self.capture)
#                 dataout.predict()
#                 if model_dataouts is None:
#                     model_dataouts = dataout.group()
#                 else:
#                     model_dataouts.insert(1, model.dl.name, dataout.group()['dl'])
#                     model_dataouts.insert(2, model.dl.name, dataout.group()['prediction','mean'])
#             model_dataouts.columns = [m.name for m in models] + ['count']
#             dataouts.append(model_dataouts)

#         b2 = pd.concat(dataouts, axis=0)
#         b2.sort_index(inplace=True)
#         b2.to_csv('/tmp/big_table_vertical.csv')

#         b2.sort_values('count', axis=1)

#         # b1 = pd.concat(dataouts, axis=1)
#         # b1.to_csv('/tmp/big_table.csv')
#         pass
