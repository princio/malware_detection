import csv, os, numpy as np
from enum import Enum
from Model import Model
from math import floor
from DomainLevel import DomainLevel, extractor
import re
import pandas as pd


valid_chars = ['_', '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
alphabet = {letter: idx+1 for idx, letter in enumerate(valid_chars)}
alphabet_rev = {idx+1: letter  for idx, letter in enumerate(valid_chars)}

def domain2input(domain):
    return [alphabet[l] for l in domain.lower().replace('.', '')]

def letter2number(value):
    return [alphabet[l] for l in value]

def number2letter(value):
    return ''.join([alphabet_rev[n] for n in value])

class Capture():
    NUM = 0
    TIME = 1
    DOMAIN = 2
    LABEL = 3

    def __init__(self, dataframe, name):
        if not all(column in dataframe.columns for column in ['num', 'time', 'domain']):
            raise 'Incorrect table, missing some column'
        self.dataframe = dataframe
        self.name = name
        self.labeled = 'label' in dataframe.columns

    @property
    def domains(self):
        if self.labeled:
            return self.dataframe[['domain', 'label']]
        return self.dataframe['domain']

    @property
    def tlds(self):
        return pd.Series([extractor(domain).suffix for domain in self.dataframe['domain'].to_numpy(str)])

    def translate(self, dl):
        return self.dataframe['domain'].apply(dl.translate).rename('input')

    @staticmethod
    def load(name):
        path = f'captures/{name}.capture.csv'
        if not os.path.exists(path):
            return False
        return Capture(pd.read_csv(path), name)

def is_right(x):
    distance = abs((0 if x['label'] == 'legit' else 1) - x['probability'])
    rightness = 1 if (x['label'] == 'legit' and x['probability'] < 0.5) or (x['label'] == 'dga' and x['probability'] > 0.5) else 0
    return rightness, distance

class Prediction:

    def __init__(self, capture, dl, model, inputs, probabilities, time_elapsed = None):
        self.capture = capture
        self.dl = dl
        self.model = model
        self.inputs = inputs
        self.probabilities = probabilities
        self.time_elapsed = time_elapsed
        pass


    @property
    def name(self):
        return f'{self.model.dl.name}_{self.dl.name}'

    @property
    def values(self):
        df = self.df()
        return df[['probability', 'right', 'distance']]

    def df(self):
        df = pd.concat([self.capture.domains, self.inputs, self.probabilities], axis=1)
        if 'label' in df.columns:
            # df['right'] = df[['label', 'probability']].apply(lambda x: 1 if (x['label'] == 'legit' and x['probability'] < 0.5) or (x['label'] == 'dga' and x['probability'] > 0.5) else 0, axis=1)
            df['right'], df['distance'] = zip(*df[['label', 'probability']].apply(is_right, axis=1))
        return df

    def save(self):
        out_path = "predictions/%s.dl_%s.model_%s.csv" % (self.capture.name, self.dl.name, self.model.dl.name)
        print('Saving output to ' + out_path)
        df = self.df()
        df.to_csv(out_path)
        pass
    
    @staticmethod
    def load_by_name(name):
        match = re.match(r'(\w+).dl_(\w+).model_(\w+).csv', name)
        capture = Capture.load(match.group(0))
        dl = DomainLevel[match.group(1)]
        model = Model.load(match.group(2))
        return Prediction.load(capture, dl, model)

    @staticmethod
    def load(capture, dl, model):
        path = f'predictions/{capture.name}.dl_{dl.name}.model_{model.dl.name}.csv'
        if not os.path.exists(path):
            return False
        df = pd.read_csv(path)
        inputs = df['input']
        probabilities = df['probability']
        return Prediction(capture, dl, model, inputs, probabilities)

class MultiPrediction:

    def __init__(self, capture):
        self.capture = capture
        self.predictions = []
        pass

    def df(self):
        df = self.capture.domains
        ps = {p.name: p.values for p in self.predictions}
        df = pd.concat([df] + list(ps.values()), keys=['input'] + list(ps.keys()), axis=1)
        return df

    def save(self):
        df = self.df()
        df.to_csv(f'predictions/multi.{self.capture.name}.csv')
        return df

    def calc(self):
        df = self.df()
        df.insert(2, ('tld', 'name'), self.capture.tlds)
        tld_counts = df[('tld', 'name')].value_counts(sort=False)
        df_grp = df.groupby(('tld', 'name'))
        df_grps = {}
        for agg in ['mean', 'sum']:
            df_grp_agg = df_grp.aggregate(agg)
            df_grp_agg.index.name = ('tld', 'name')
            df_grp_agg.insert(loc=0, column=('tld', 'num'), value=tld_counts)
            df_grp_agg.set_index([('tld', 'num')], append=True, inplace=True)
            df_grp_agg.loc[('all', 0),:] = df_grp_agg.sum(numeric_only=True, axis=0)
            df_grp_agg.sort_values(by=('all', 0), axis=1, inplace=True)
            df_grp_agg.to_csv(f'predictions/{self.capture.name}.multi.{agg}.csv')
            df_grps[agg] = df_grp_agg.T.sort_index(level=0, axis=0)
        
        with pd.ExcelWriter(f'predictions/{self.capture.name}.multi.{agg}.xlsx') as writer:
            metrics = ['distance', 'probability', 'right']
            for agg in ['mean', 'sum']:
                df_grps[agg].to_excel(writer, sheet_name=f'total_{agg}')
                for metric in ['distance', 'probability', 'right']:
                    df_grps[agg].drop(level=1, index=[m for m in metrics if m != metric]).to_excel(writer, sheet_name=f'{metric}.{agg}')

    def add(self, prediction):
        self.predictions.append(prediction)
        pass

class Predictor():
    DOMAIN = 0
    INPUT = 1
    PREDICTION = 2

    def __init__(self, dl, capture):
        self.dl = dl
        self.capture = capture
        self.inputs = self.capture.translate(dl)
        self.X = self.inputs.apply(domain2input).to_numpy()
        self.time_elapsed = None
        pass

    def predict(self, model, save = True):
        prediction = Prediction.load(self.capture, self.dl, model)
        if not prediction:
            probabilities, time_elapsed = model.predict(self.X)
            probabilities = pd.Series(probabilities[:,0], name='probability')
            prediction = Prediction(self.capture, self.dl, model, self.inputs, probabilities, time_elapsed)
            if save:
                prediction.save()
        return prediction


class MultiPredictor():
    DOMAIN = 0
    INPUT = 1
    PREDICTION = 2

    def __init__(self, dls, models, capture):
        self.models = models
        self.dls = dls
        self.capture = capture
        self.predictors = {}
        for dl in dls:
            self.predictors[dl] = Predictor(dl, capture)
        pass

    def predict(self, save = True):
        mp = MultiPrediction(self.capture)
        for dl in self.dls:
            for model in self.models:
                mp.add(self.predictors[dl].predict(model))
        mp.save()
        mp.calc()
        return mp