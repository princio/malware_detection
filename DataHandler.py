import csv, os, numpy as np
from enum import Enum
from Model import Model
from IO import Output
from math import floor
from DomainLevel import DomainLevel, extractor
import re
import pandas as pd

def is_right(x):
    distance = abs((0 if x['label'] == 'legit' else 1) - x['probability'])
    rightness = 1 if (x['label'] == 'legit' and x['probability'] < 0.5) or (x['label'] == 'dga' and x['probability'] > 0.5) else 0
    return rightness, distance

def normalcapture_wrongness(x):
    rightness = 1 if x > 0.5 else 0
    distance = 0 if x <= 0.5 else x-0.5
    return rightness, distance

class Prediction:

    def __init__(self, model, input):
        self.input = Input(capture, dl)
        self.model = model
        self.probabilities = probabilities
        self.time_elapsed = time_elapsed
        pass

    @property
    def name(self):
        return f'{self.input.name}__{self.model.dl.name}'

    @property
    def values(self):
        df = self.df()
        return df[['probability', 'wrong', 'distance']]

    def df(self):
        df = pd.concat([self.input.domains, self.input.inputs, self.probabilities], axis=1)
        if self.input.labeled:
            df['wrong'], df['distance'] = zip(*df[['label', 'probability']].apply(is_right, axis=1))
        else:
            df['wrong'], df['distance'] = zip(*df['probability'].apply(normalcapture_wrongness))

        return df

    def save(self):
        capture_name = self.input.capture.name
        if not os.path.exists(f'predictions/{capture_name}'):
            os.makedirs(f'predictions/{capture_name}')
        out_path = "predictions/%s/%s.dl_%s.model_%s.csv" % (capture_name, capture_name, self.input.dl.name, self.model.dl.name)
        print('Saving output to ' + out_path)
        df = self.df()
        df.to_csv(out_path)
        pass
    
    @staticmethod
    def load_by_name(name):
        match = re.match(r'(\w+).dl_(\w+).model_(\w+).csv', name)
        capture = Capture.load(match.group(0))
        dl = DomainLevel[match.group(1)]
        model = Model.load(match.group(2))
        return Prediction.load(capture, dl, model)

    @staticmethod
    def load(capture, dl, model):
        path = f'predictions/{capture.name}/{capture.name}.dl_{dl.name}.model_{model.dl.name}.csv'
        if not os.path.exists(path):
            return False
        df = pd.read_csv(path)
        inputs = df['input']
        probabilities = df['probability']
        return Prediction(capture, dl, model, inputs, probabilities)

class MultiPrediction:

    def __init__(self, capture, models: [], dls: []):
        self.capture = capture
        for model in models:
            Input
            for dl in dls:
                Output()
        self.predictions = []
        pass

    def path(self, append = '', ext = 'csv'):
        if not os.path.exists(f'predictions/{self.capture.name}'):
            os.makedirs(f'predictions/{self.capture.name}')
        return 'views/%s/%s.multi%s%s.%s' % (self.capture.name, self.capture.name, '.' if append != '' else '', append, ext)

    def df(self):
        df = self.capture.domain
        ps = {p.name: p.values for p in self.predictions}
        df = pd.concat([df] + list(ps.values()), keys=['input'] + list(ps.keys()), axis=1)
        return df

    def save(self):
        df = self.df()
        df.to_csv(self.path())
        return df

    def calc(self):
        df = self.df()
        df.insert(2, ('tld', 'name'), self.capture.tlds)
        tld_counts = df[('tld', 'name')].value_counts(sort=False)
        df_grp = df.groupby(('tld', 'name'))
        df_grps = {}

        with pd.ExcelWriter(self.path('grp', 'xlsx')) as writer:
            for agg in ['mean', 'sum']:
                df_grp_agg = df_grp.aggregate(agg)
                df_grp_agg.index.name = ('tld', 'name')
                df_grp_agg.insert(loc=0, column=('tld', 'num'), value=tld_counts)
                df_grp_agg.set_index([('tld', 'num')], append=True, inplace=True)
                df_grp_agg.loc[('all', 0),:] = df_grp_agg.sum(numeric_only=True, axis=0)
                df_grp_agg.sort_values(by=('all', 0), axis=1, inplace=True)
                df_grp_agg.to_excel(writer, sheet_name=agg)
                df_grps[agg] = df_grp_agg
        
        with pd.ExcelWriter(self.path('grp_splitted', 'xlsx')) as writer:
                metrics = ['distance', 'probability', 'wrong']
                for agg in ['mean', 'sum']:
                    df_grps[agg].to_excel(writer, sheet_name=f'total_{agg}')
                    for metric in metrics:
                        df_grps[agg].drop(level=1, columns=[m for m in metrics if m != metric]).to_excel(writer, sheet_name=f'{metric}.{agg}')


    def add(self, prediction):
        self.predictions.append(prediction)
        pass

class Predictor():
    DOMAIN = 0
    INPUT = 1
    PREDICTION = 2

    def __init__(self, dl, capture):
        self.dl = dl
        self.capture = capture
        self.inputs = self.capture.translate(dl)
        self.X = self.inputs.apply(domain2input).to_numpy()
        self.time_elapsed = None
        pass

    def predict(self, model, save = True):
        prediction = Prediction.load(self.capture, self.dl, model)
        if not prediction:
            probabilities, time_elapsed = model.predict(self.X)
            probabilities = pd.Series(probabilities[:,0], name='probability')
            prediction = Prediction(self.capture, self.dl, model, self.inputs, probabilities, time_elapsed)
            if save:
                prediction.save()
        return prediction


class MultiPredictor():
    DOMAIN = 0
    INPUT = 1
    PREDICTION = 2

    def __init__(self, dls, models, capture):
        self.models = models
        self.dls = dls
        self.capture = capture
        self.predictors = {}
        for dl in dls:
            self.predictors[dl] = Predictor(dl, capture)
        pass

    def predict(self, save = True):
        mp = MultiPrediction(self.capture)
        for dl in self.dls:
            for model in self.models:
                mp.add(self.predictors[dl].predict(model))
        mp.save()
        mp.calc()
        return mp

class MultiPredictor2():
    def __init__(self, capture, models):
        self.models = models
        self.inputs = {}
        for dl in DomainLevel.all():
            self.inputs[dl] = Input(capture, dl)
            self.predictions[dl] = Prediction(self.inputs[dl])
        self.models = models
        self.capture = capture
        self.outputs = {}
        pass

    def predict(self, save = True):
        for model in self.models:
            prediction = Prediction(model, input)
            for input in self.inputs:
                output = Output.predict(input, model)
                self.outputs[output.name] = output