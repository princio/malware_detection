<template>
  <div id="app">

    <div>
      <select name="danfo-fx" id="danfo-fx" v-model="danfo.fx">
        <option v-for="fx in fxs" :key="fx">{{ fx }}</option>
      </select>
      <select name="danfo-size" id="danfo-size" v-model="danfo.size">
        <option v-for="size in sizes" :key="size">{{ size }}</option>
      </select>
      <select name="danfo-size" id="danfo-size" v-model="danfo.dga">
        <option v-for="dga in dgas" :key="dga">{{ dga }}</option>
      </select>
      <button v-on:click="danfo_exec()">clac</button>
      <pre v-text="danfo.config"></pre>
      <pre v-text="danfo.status"></pre>
      {{ danfo.error }}
    </div>
    <div
      ref="toolbar"
      style="
        display: flex;
        flex-direction: row;
        width: 75%;
        margin: auto;
        space-between: fill;
        justify-content: space-around;
      "
    >
      <div
        style="
          display: flex;
          flex-direction: row;
          width: 100%;
          text-align: left;
          justify-content: space-around;
        "
      >
        <div style="display: flex; flex-direction: column; text-align: left">
          <h4>$size$</h4>
          <div v-for="size in sizes" :key="size">
            <input
              type="checkbox"
              :id="size"
              :value="size"
              v-model="checkedSizes"
            />
            <label :for="size">{{ size }} </label>
          </div>
        </div>
        <div style="display: flex; flex-direction: column; text-align: left">
          <h4>$vDGA$</h4>
          <div v-for="dga in dgas" :key="dga">
            <input
              type="checkbox"
              :id="dga"
              :value="dga"
              v-model="checkedDgas"
            />
            <label :for="dga">{{ dga }} </label>
          </div>
        </div>
        <div style="display: flex; flex-direction: column; text-align: left">
          <h4>$f$</h4>
          <div v-for="fx in fxs" :key="fx">
            <input type="checkbox" :id="fx" :value="fx" v-model="checkedFxs" />
            <label :for="fx">{{ fx_symbol(fx) }} </label>
          </div>
        </div>
        <div style="display: flex; flex-direction: column; text-align: left">
          <h4>$vDGA$</h4>
          <div>
            <input type="radio" id="dga_eq" :value="false" v-model="dga_gt" />
            <label for="dga_eq">$=$</label>
          </div>
          <div>
            <input type="radio" id="dga_gt" :value="true" v-model="dga_gt" />
            <label for="dga_gt">$\ge$</label>
          </div>
        </div>

        <div style="display: flex; flex-direction: column; text-align: left">
          <h4>$\bar{th}$</h4>
          <div>
            <input type="radio" id="th_measure_mean" :value="'mean'" :on:click="onchange_measure()" v-model="th_measure" />
            <label for="th_measure_mean">$\bar{\mu}$: mean</label>
          </div>
          <div>
            <input type="radio" id="th_measure_max" :value="'max'" :on:click="onchange_measure()" v-model="th_measure" />
            <label for="th_measure_max">$\bar{M}$: max</label>
          </div>
        </div>

        <div style="display: flex; flex-direction: column; text-align: left">
          <h4>$th$</h4>
          <table style="padding: 0">
            <tr v-for="fx in fxs" :key="`key_${fx}`">
              <td>
                <div class="column">
                  <div class="row" v-for="s in sizes" :key="s">
                    <span style="width: 50px" v-text="`\$\\small ${th_measure_sym}^{${s}}_{${fx_symbol(fx)}}+\$`"></span>
                    <input
                      type="range"
                      :name="`${fx}_${s}_th`"
                      :id="`${fx}_${s}_th`"
                      :min="get_th_min(fx, s)"
                      :max="get_th_max(fx, s)"
                      :step="get_th_step(fx, s)"
                      v-model="ths[fx][s]"
                    />
                    <input type="text" style="width:50px" v-model="ths[fx][s]"/>
                  </div>
                </div>
              </td>
            </tr>
            <tr>
              <td><label :for="th_p">$\bar{th}_{p}=$</label></td>
              <td>
                <input
                  type="range"
                  name="th_p"
                  id="th_p"
                  min="0"
                  max="1"
                  step="0.05"
                  v-model="th_p"
                />
              </td>
              <td><input type="text" style="width:30px" v-model="th_p"/></td>
            </tr>
          </table>
        </div>
      </div>
      <button v-on:click="loadFile()">Reload</button>
      <button v-on:click="render()">Render</button>
    </div>

    <div ref="legend">
      <h3>
        Legend:
        <button v-on:click="toggle_legend()">{{ legend_btn_label }}</button>
      </h3>
      <table v-show="legend_show" style="text-align: left; margin: auto">
        <thead>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </thead>
        <tbody>
          <tr>
            <td>$s$</td>
            <td>size</td>
            <td>Window size, it could be $100$, $500$, $2500$.</td>
          </tr>
          <tr>
            <td>$\bar{M}^s_f$</td>
            <td>threshold</td>
            <td>
              Maximum of not infected windows having size $s$ for the function
              $f$.
            </td>
          </tr>
          <tr>
            <td>$th_f$</td>
            <td>threshold refiner</td>
            <td>
              Coefficient which is multiplied to $\bar{M}^s_f$ to refine the
              inspection.
            </td>
          </tr>
          <tr>
            <td>$\lambda$</td>
            <td>function</td>
            <td>
              A window is infected if its $LLR$ (aka $\lambda$) is greater than
              $\bar{M}^s_{\lambda} \cdot th_{\lambda}$.
            </td>
          </tr>
          <tr>
            <td>$nx$</td>
            <td>function</td>
            <td>
              A window is infected if it counts of domains responses is greater
              than $\bar{M}^s_{gt} \cdot th_{nx}$.
            </td>
          </tr>
          <tr>
            <td>$gt_{0.9}$</td>
            <td>function</td>
            <td>
              A window is infected if it counts of domains having inference
              greater than 0.9 is greater than $\bar{M}^s_{gt_{0.9}}$.
            </td>
          </tr>
          <tr>
            <td>$n_p$</td>
            <td>value</td>
            <td>Number of pcaps processed. This value depends on $vDGA$.</td>
          </tr>
          <tr>
            <td>$n_p^d$</td>
            <td>value</td>
            <td>
              Number of pcaps processed having at least one window infected.
            </td>
          </tr>
          <tr>
            <td>$N_w$</td>
            <td>value</td>
            <td>
              It is a normalized value which indicates <i>when</i> the first
              infected window has been detected.<br />$0$ indicates the first
              window, $1$ the last one.
            </td>
          </tr>
          <tr>
            <td>$n_w$</td>
            <td>value</td>
            <td>The total number of windows for the considered pcaps.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div ref="bounds">
      <h3>
        Bounds:
        <button v-on:click="toggle_bounds()">{{ bounds_btn_label }}</button>
      </h3>
      <div
      v-show="bounds_show" 
      style="
        display: flex;
        flex-direction: row;
        width: 100%;
        justify-content: space-around;
      "
      v-html="compiledBounds"></div>
    </div>

    <div
      id="df_table"
      style="
        display: flex;
        flex-direction: row;
        width: 100%;
        justify-content: space-around;
      "
      ref="mathJaxEl"
      v-html="compiledHtml"
    ></div>
  </div>
</template>

<script>
import axios from "axios";
const dfd = require('danfojs/dist/index')

export default {
  name: "App",
  components: {},
  data: function () {
    const sizes = [ 100, 500, 2500 ];
    const fxs = ["llr", "nx", "ctr", "ratio"];
    const ths = {}
    const ths_default = {}
    for (const fx of fxs) {
      ths[fx] = {};
      ths_default[fx] = {};
      for (const s of [ 100, 500, 2500 ]) {
        ths[fx][s] = 1;
        ths_default[fx][`${s}`] = {};
        for (const m of [ 'mean', 'max' ]) {
          ths_default[fx][`${s}`][m] = 1;
        }
      }
    }
    return {
      sizes,
      fxs,
      ths,
      ths_default,
      input: "",
      bounds: "",
      dgas: [1, 2, 3],
      checkedSizes: [100, 500, 2500],
      checkedDgas: [1, 2, 3],
      checkedFxs: ["llr", "nx", "ctr"],
      th_measure: 'mean',
      th_p: 0.5,
      dga_gt: false,
      legend_show: false,
      bounds_show: false,
      danfo: {
        fx: 'llr',
        size: 2500,
        dga: 1,
        config: 'nada',
        status: 'nada',
        error: ''
      },
    };
  },
  async mounted() {
    // await this.loadBounds();
    this.loadFile();
    this.renderMathJax(this.$refs.toolbar);
    // const dfs = {};
    // for (const fx of this.fxs) {
    //   if (fx === 'ratio') continue;
    //   dfs[fx] = {};
    //   for (const s of [ 100, 500, 2500 ]) {
    //     dfs[fx][s] = await dfd.read_csv(`http://127.0.0.1:3000/jsons/windows_${fx}_${s}.csv`);
    //     dfs[fx][s].addColumn({column: 'detected', values: dfs[fx][s].llr.apply(sum_vals), inplace: true});
    //     dfs[fx][s].loc({columns: ['window', 'detected']}).tail().print();
    //   }
    // }
    // this.dfs = dfs;

    this.df_bounds = await dfd.read_csv("http://127.0.0.1:3000/csv/bounds.csv");

    function sum_vals(llr) {
      return llr > 0.6;
    }
    
    this.df_windows.addColumn({column: 'detected', values: this.df_windows.llr.apply(sum_vals), inplace: true});
    this.df_windows.loc({columns: ['window', 'detected']}).tail().print();
  },
  computed: {
    compiledHtml: function () {
      return this.input;
    },
    compiledBounds: function () {
      return this.bounds;
    },
    legend_btn_label: function () {
      return this.legend_show ? "Hide" : "Show";
    },
    bounds_btn_label: function () {
      return this.bounds_show ? "Hide" : "Show";
    },
    th_measure_sym: function () {
      return {
        mean: '\\bar{\\mu}',
        max: '\\bar{M}'
      }[this.th_measure]
    }
  },
  methods: {
    async danfo_exec() {
      try {
        this.danfo.status = '';
        this.danfo.config = `fx=${this.danfo.fx}, size=${this.danfo.size}, dga=${this.danfo.dga}, th=${this.ths[this.danfo.fx][this.danfo.size]}`
        let df = await dfd.read_csv(`http://127.0.0.1:3000/csv/${this.danfo.fx}.csv`);
        df = df.query({ condition: df['size'].eq(Number(this.danfo.size)).and(df['dga'].eq(0).or(df['dga'].eq(Number(this.danfo.dga)))) });
        this.danfo.config += '\n' + df.loc({ columns: ['window'] }).sum();
        
        df.addColumn({ column: 'detected', values: df['llr'].gt(this.ths[this.danfo.fx][this.danfo.size]), inplace: true })

        const s_det = df['detected']
        const s_ndet = df['detected'].apply((x) => !x)
        const tn = df['window'].loc(s_ndet.and(df['dga'].eq(0))).sum();
        const fp = df['window'].loc( s_det.and(df['dga'].eq(0))).sum();
        const fn = df['window'].loc(s_ndet.and(df['dga'].ne(0))).sum();
        const tp = df['window'].loc( s_det.and(df['dga'].ne(0))).sum();

        this.danfo.status = df;


        this.danfo.status += `${tn} ${fp}\n${fn} ${tp}\n`
      } catch (error) {
        this.danfo.error = error;
      }
    },
    get_th_min(fx, size) {
      if (fx != 'llr') return 0;
      const def = this.ths_default[fx][`${size}`][this.th_measure];
      if (def < 0) return def*2;
      else return def - def;
    },
    get_th_max(fx, size) {
      if (fx == 'ratio') return 1;
      if (fx != 'llr') return size;
      const def = this.ths_default[fx][`${size}`][this.th_measure];
      if (def < 0) return def - def;
      else return def*2;
    },
    get_th_step(fx, size) {
      if (fx == 'ratio') return 0.05;
      const def = this.get_th_max(fx, size) - this.get_th_min(fx, size);
      return Math.round(def/20);
    },
    get_ths_default(fx, size) {
      if (fx == 'ratio') return 0.5;
      return this.ths_default[fx][`${size}`][this.th_measure];
    },
    set_ths_default() {
      for (const fx of this.fxs) {
        if (fx === "ratio") continue;
        for (const size of this.sizes) {
          const s = `${size}`;
          this.ths[fx][s] = this.ths_default[fx][s][this.th_measure]
        }
      }
    },
    onchange_measure() {
      this.set_ths_default();
      this.renderMathJax([this.$refs.toolbar]);
    },
    fx_symbol(fx) {
      return {
        'llr': '\\lambda',
        'nx': 'nx',
        'ctr': 'gt_{0.9}',
        'ratio': 'p'
      }[fx]
    },
    toggle_legend() {
      this.legend_show = !this.legend_show;
    },
    toggle_bounds() {
      this.bounds_show = !this.bounds_show;
    },
    render() {
      console.log(this.$refs.toolbar);
      this.renderMathJax([this.$refs.toolbar]);
      this.renderMathJax([this.$refs.mathJaxEl]);
      if (this.legend_show)
        this.renderMathJax([this.$refs.legend]);
      if (this.bounds_show)
        this.renderMathJax([this.$refs.bounds]);
    },
    async loadBounds() {
      const resp = await axios.get("http://127.0.0.1:3000/csv/bounds.csv")
      this.ths_default = resp.data;
      this.set_ths_default();
      this.$nextTick().then(() => {
        this.renderMathJax();
      });
    },
    loadFile() {
      let msg = "";
      if (this.checkedSizes.length === 0) msg += "Select at least one size.\n";
      if (this.checkedDgas.length === 0) msg += "Select at least one vDGA.\n";
      if (this.checkedFxs.length === 0)
        msg += "Select at least one function.\n";
      if (msg.length > 0) {
        alert(msg);
        return;
      }
      axios
        .post(
          "http://127.0.0.1:3000/df",
          {
            size: this.checkedSizes,
            dga_gt: this.dga_gt,
            dga: this.checkedDgas,
            fxs: this.checkedFxs,
            th_measure: this.th_measure,
            ths: this.ths
          }
        )
        .then(async (result) => {
          this.input = Buffer.from(result.data.html, "base64").toString("ascii");
          this.bounds = Buffer.from(result.data.bounds, "base64").toString("ascii");

          this.$nextTick().then(() => {
            this.renderMathJax();
          });
        })
        .catch((error) => {
          console.log(error);
        });
    },
    renderMathJax(refs = [this.$refs.mathJaxEl]) {
      if (!refs ||  refs.length === 0 || !refs[0])
        return
      if (window.MathJax) {
        window.MathJax.config = {
          tex: {
            inlineMath: [
              ["$", "$"],
              ["\\(", "\\)"],
            ],
          },
          svg: {
            fontCache: "global",
          },
        };
        if (window.MathJax && window.MathJax.typesetPromise)
          window.MathJax.typesetPromise(refs);
      }
    },
  },
};
</script>

<style>
.column {
  display: flex;
  flex-direction: column;
}
.row {
  display: flex;
  flex-direction: row;
}
table > tbody > tr > td {
  vertical-align: middle;
  text-align: center;
  padding: 0 10px;
}
table > tbody > tr > th {
  text-align: left;
  padding: 0 20px;
}
table, .dataframe {
  border: 0 !important;
  padding: 50px 0px 0 0;
}
body {
  margin: 0;
  background-color: rgb(53, 53, 53);
}
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: white; /*#2c3e50;*/
  padding: 20px;
}
th,
td {
  vertical-align: top;
}
</style>