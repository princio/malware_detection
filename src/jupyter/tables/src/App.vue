
<template>
  <div id="app">

    <div>
      <select name="danfo-fx" id="danfo-fx" v-model="danfo.fx">
        <option v-for="fx in fxs" :key="fx">{{ fx }}</option>
      </select>
      <select name="danfo-size" id="danfo-size" v-model="danfo.size">
        <option v-for="size in sizes" :key="size">{{ size }}</option>
      </select>
      <select name="danfo-size" id="danfo-size" v-model="danfo.dga">
        <option v-for="dga in dgas" :key="dga">{{ dga }}</option>
      </select>
      <button v-on:click="danfo_exec()">clac</button>
      <pre v-text="danfo.config"></pre>
      <pre v-text="danfo.status"></pre>
      {{ danfo.error }}
    </div>
    <div
      ref="toolbar"
      style="
        display: flex;
        flex-direction: row;
        width: 75%;
        margin: auto;
        space-between: fill;
        justify-content: space-around;
      "
    >
      <div
        style="
          display: flex;
          flex-direction: row;
          width: 100%;
          text-align: left;
          justify-content: space-around;
        "
      >
        <div style="display: flex; flex-direction: column; text-align: left">
          <h4>$size$</h4>
          <div v-for="size in sizes" :key="size">
            <input
              type="checkbox"
              :id="size"
              :value="size"
              v-model="checkedSizes"
            />
            <label :for="size">{{ size }} </label>
          </div>
        </div>
        <div style="display: flex; flex-direction: column; text-align: left">
          <h4>$vDGA$</h4>
          <div v-for="dga in dgas" :key="dga">
            <input
              type="checkbox"
              :id="dga"
              :value="dga"
              v-model="checkedDgas"
            />
            <label :for="dga">{{ dga }} </label>
          </div>
        </div>
        <div style="display: flex; flex-direction: column; text-align: left">
          <h4>$f$</h4>
          <div v-for="fx in fxs" :key="fx">
            <input type="checkbox" :id="fx" :value="fx" v-model="checkedFxs" />
            <label :for="fx">{{ fx_symbol(fx) }} </label>
          </div>
        </div>
        <div style="display: flex; flex-direction: column; text-align: left">
          <h4>$vDGA$</h4>
          <div>
            <input type="radio" id="dga_eq" :value="false" v-model="dga_gt" />
            <label for="dga_eq">$=$</label>
          </div>
          <div>
            <input type="radio" id="dga_gt" :value="true" v-model="dga_gt" />
            <label for="dga_gt">$\ge$</label>
          </div>
        </div>

        <div style="display: flex; flex-direction: column; text-align: left">
          <h4>$\bar{th}$</h4>
          <div>
            <input type="radio" id="th_measure_mean" :value="'mean'" :on:click="onchange_measure()" v-model="th_measure" />
            <label for="th_measure_mean">$\bar{\mu}$: mean</label>
          </div>
          <div>
            <input type="radio" id="th_measure_max" :value="'max'" :on:click="onchange_measure()" v-model="th_measure" />
            <label for="th_measure_max">$\bar{M}$: max</label>
          </div>
        </div>

        <div 
          v-show=false
          style="display: flex; flex-direction: column; text-align: left">
          <h4>$th$</h4>
          <table style="padding: 0">
            <tr v-for="fx in fxs" :key="`key_${fx}`">
              <td>
                <div class="column">
                  <div class="row" v-for="s in sizes" :key="s">
                    <span style="width: 50px" v-text="`\$\\small ${th_measure_sym}^{${s}}_{${fx_symbol(fx)}}+\$`"></span>
                    <input
                      type="range"
                      :name="`${fx}_${s}_th`"
                      :id="`${fx}_${s}_th`"
                      :min="get_th_min(fx, s)"
                      :max="get_th_max(fx, s)"
                      :step="get_th_step(fx, s)"
                      v-model="ths[fx][s]"
                    />
                    <input type="text" style="width:50px" v-model="ths[fx][s]"/>
                  </div>
                </div>
              </td>
            </tr>
            <tr>
              <td><label :for="th_p">$\bar{th}_{p}=$</label></td>
              <td>
                <input
                  type="range"
                  name="th_p"
                  id="th_p"
                  min="0"
                  max="1"
                  step="0.05"
                  v-model="th_p"
                />
              </td>
              <td><input type="text" style="width:30px" v-model="th_p"/></td>
            </tr>
          </table>
        </div>
      </div>
      <button v-on:click="reload()">Reload</button>
      <button v-on:click="render()">Render</button>
    </div>

    <div ref="legend">
      <h3>
        Legend:
        <button v-on:click="toggle_legend()">{{ legend_btn_label }}</button>
      </h3>
      <table v-show="legend_show" style="text-align: left; margin: auto">
        <thead>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </thead>
        <tbody>
          <tr>
            <td>$s$</td>
            <td>size</td>
            <td>Window size, it could be $100$, $500$, $2500$.</td>
          </tr>
          <tr>
            <td>$\bar{M}^s_f$</td>
            <td>threshold</td>
            <td>
              Maximum of not infected windows having size $s$ for the function
              $f$.
            </td>
          </tr>
          <tr>
            <td>$th_f$</td>
            <td>threshold refiner</td>
            <td>
              Coefficient which is multiplied to $\bar{M}^s_f$ to refine the
              inspection.
            </td>
          </tr>
          <tr>
            <td>$\lambda$</td>
            <td>function</td>
            <td>
              A window is infected if its $LLR$ (aka $\lambda$) is greater than
              $\bar{M}^s_{\lambda} \cdot th_{\lambda}$.
            </td>
          </tr>
          <tr>
            <td>$nx$</td>
            <td>function</td>
            <td>
              A window is infected if it counts of domains responses is greater
              than $\bar{M}^s_{gt} \cdot th_{nx}$.
            </td>
          </tr>
          <tr>
            <td>$gt_{0.9}$</td>
            <td>function</td>
            <td>
              A window is infected if it counts of domains having inference
              greater than 0.9 is greater than $\bar{M}^s_{gt_{0.9}}$.
            </td>
          </tr>
          <tr>
            <td>$n_p$</td>
            <td>value</td>
            <td>Number of pcaps processed. This value depends on $vDGA$.</td>
          </tr>
          <tr>
            <td>$n_p^d$</td>
            <td>value</td>
            <td>
              Number of pcaps processed having at least one window infected.
            </td>
          </tr>
          <tr>
            <td>$N_w$</td>
            <td>value</td>
            <td>
              It is a normalized value which indicates <i>when</i> the first
              infected window has been detected.<br />$0$ indicates the first
              window, $1$ the last one.
            </td>
          </tr>
          <tr>
            <td>$n_w$</td>
            <td>value</td>
            <td>The total number of windows for the considered pcaps.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div ref="bounds">
      <h3>
        Bounds:
        <button v-on:click="toggle_bounds()">{{ bounds_btn_label }}</button>
      </h3>
      <div
      v-show="bounds_show" 
      style="
        display: flex;
        flex-direction: row;
        width: 100%;
        justify-content: space-around;
      "
      v-html="compiledBounds"></div>
    </div>

    <div
      id="df_table"
      style="
        display: flex;
        flex-direction: row;
        width: 100%;
        justify-content: space-around;
      "
      ref="mathJaxEl"
      v-html="compiledHtml"
    ></div>

    <table
      ref="cms_table">
      <thead>
        <tr>
          <th v-for="(h, hindex) in header" :key="`header_${hindex}`">
            {{ h }}
            <button v-on:click="setHSort(hindex, false)">^</button>
            <button v-on:click="setHSort(hindex, true)">V</button>
          </th>
        </tr>
      </thead>
      <tbody ref="cms_table_body">
        <tr v-for="(row, rindex) in sortedArray" :key="`row_${rindex}`">
          <th
          v-for="(c, cindex) in row.slice(0, 3)"
          :key="`col_index_${rindex}_${cindex}`"
          >
            {{ c }}
          </th>
          <td
          v-for="(c, cindex) in row.slice(3)"
          :key="`col_value_${rindex}_${cindex}`"
          :class="c > 0.75 ? 'greenclass' : (c < 0.25 ? 'redclass' : null)"
          >
          {{ c }}
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</template>

<script>
import axios from "axios";
const dfd = require('danfojs/dist/index')

export default {
  name: "App",
  components: {},
  data: function () {
    const sizes = [ 100, 500, 2500 ];
    const fxs = ["llr", "nx", "ctr", "ratio"];
    const ths = {}
    const ths_default = {}
    for (const fx of fxs) {
      ths[fx] = {};
      ths_default[fx] = {};
      for (const s of [ 100, 500, 2500 ]) {
        ths[fx][s] = 1;
        ths_default[fx][`${s}`] = {};
        for (const m of [ 'mean', 'max' ]) {
          ths_default[fx][`${s}`][m] = 1;
        }
      }
    }
    return {
      sizes,
      fxs,
      ths,
      ths_default,
      input: "",
      bounds: "",
      dgas: [1, 2, 3],
      checkedSizes: [100, 500, 2500],
      checkedDgas: [1, 2, 3],
      checkedFxs: ["llr", "nx", "ctr"],
      th_measure: 'mean',
      th_p: 0.5,
      dga_gt: false,
      legend_show: false,
      bounds_show: false,
      danfo: {
        fx: 'llr',
        size: 2500,
        dga: 1,
        config: 'nada',
        status: 'nada',
        error: ''
      },
      cms: {},
      values: [],
      hindex: 1,
      hasc: true
    };
  },
  created() {
    this.header = [
      '$f$',
      '$s$',
      '$vDGA$',
      '$\\tiny\\begin{pmatrix} tn & fp \\\\ fn & tp \\end{pmatrix}$',
      '$\\bar{pr}$',
      '$pr$',
      '$acc$'
    ];
  },
  async mounted() {
    this.renderMathJax(this.$refs.toolbar);
    this.dfs = {};
    for (const fx of this.fxs) {
      if (fx === 'ratio') continue;
      this.cms[fx] = []
      this.dfs[fx] = await dfd.read_csv(`http://127.0.0.1:3000/csv/${this.danfo.fx}.csv`);
    }
    this.df_bounds = await dfd.read_csv("http://127.0.0.1:3000/csv/bounds.csv");
  },
  computed: {
    compiledHtml: function () {
      return this.input;
    },
    compiledBounds: function () {
      return this.bounds;
    },
    legend_btn_label: function () {
      return this.legend_show ? "Hide" : "Show";
    },
    bounds_btn_label: function () {
      return this.bounds_show ? "Hide" : "Show";
    },
    th_measure_sym: function () {
      return {
        mean: '\\bar{\\mu}',
        max: '\\bar{M}'
      }[this.th_measure]
    },
    sortedArray: function() {
      return this.values.slice().sort((r1, r2) => {
        let a = r1[this.hindex];
        a = a === 'NaN' ? -1 : a;
        let b = r2[this.hindex];
        b = b === 'NaN' ? -1 : b;
        return (this.hasc ? (a - b) : (b - a))
      });
    }
  },
  methods: {
    async setHSort(hindex, asc) {
      this.hindex = hindex;
      this.hasc = asc;
    },
    get_cm(fx, size, dga) {
      console.log('get_cm');
      let df = this.dfs[fx];
      df = df.query({ condition: df['size'].eq(Number(size)).and(df['dga'].eq(0).or(df['dga'].eq(Number(dga)))) });
      df.addColumn({ column: 'detected', values: df['llr'].gt(this.ths[fx][size]), inplace: true });
      
      const s_det = df['detected']
      const s_ndet = df['detected'].apply((x) => !x)

      const tn = df['window'].loc(s_ndet.and(df['dga'].eq(0))).sum();
      const fp = df['window'].loc( s_det.and(df['dga'].eq(0))).sum();
      const fn = df['window'].loc(s_ndet.and(df['dga'].ne(0))).sum();
      const tp = df['window'].loc( s_det.and(df['dga'].ne(0))).sum();

      const normal = {
        pr: tn / (tn + fn),
        re: tn / (tn + fp),
        tpr: tn / (tn + fp)
      }
      normal.f1 = 2 * (normal.pr * normal.re) / (normal.pr + normal.re);

      const infected = {
        pr: tp / (tp + fp),
        re: tp / (tp + fn),
        tpr: tp / (tp + fn)
      }
      infected.f1 = 2 * (infected.pr * infected.re) / (infected.pr + infected.re);

      const macro = {
        pr: (normal.pr + infected.pr) / 2,
        re: (normal.re + infected.re) / 2,
        tpr: (normal.tpr + infected.tpr) / 2,
        f1: (normal.f1 + infected.f1)/2,
        accuracy: (tp + tn) / (tp + tn + fp + fn)
      }

      return { tn, fp, fn, tp, report: { normal, infected, macro } };
    },
    clearMathJax() {
      const nodes = {}
      for (const node of window.MathJax.startup.document.getMathItemsWithin(this.$refs.cms_table_body)) {
        const cellIndex = node.end.node.parentElement.parentElement.rowIndex;
        if (cellIndex in nodes) {
          nodes[cellIndex].remove();
          nodes[cellIndex] = node.end.node;
        }
        else
          nodes[cellIndex] = node.end.node;
      }
    },
    get_cms() {
      try {
        const cms = [];
        for (const fx of this.checkedFxs) {
          for (const size of this.sizes) {
            for (const dga of this.checkedDgas) {
              const cm = this.get_cm(fx, size, dga);
              cms.push({ r: { fx, size, dga }, cm,  });
            }
          }
        }
        return cms;
      } catch (error) {
        this.danfo.error = error;
      }
    },
    async reload() {
      const _2d = (n) => (n >= 0.99 && n < 1) ? 0.99 : ((n > 0 && n <= 0.01) ? 0.01 : n.toFixed(2));
      const cms = this.get_cms();
      const values = [];
      for (const cm of cms) {
        const col1 = `$\\small\\begin{pmatrix} ${cm.cm.tn} & ${cm.cm.fp} \\\\ ${cm.cm.fn} & ${cm.cm.tp} \\end{pmatrix}$`;
        
        values.push([
            cm.r.fx,
            cm.r.size,
            cm.r.dga,
            col1,
            _2d(cm.cm.report.normal.pr),
            _2d(cm.cm.report.infected.pr),
            _2d(cm.cm.report.macro.accuracy),
        ]);
      }
      this.values = values;
      await this.$nextTick();
      this.clearMathJax();
      this.renderMathJax([this.$refs.cms_table_body]);
    },
    get_th_min(fx, size) {
      if (fx != 'llr') return 0;
      const def = this.ths_default[fx][`${size}`][this.th_measure];
      if (def < 0) return def*2;
      else return def - def;
    },
    get_th_max(fx, size) {
      if (fx == 'ratio') return 1;
      if (fx != 'llr') return size;
      const def = this.ths_default[fx][`${size}`][this.th_measure];
      if (def < 0) return def - def;
      else return def*2;
    },
    get_th_step(fx, size) {
      if (fx == 'ratio') return 0.05;
      const def = this.get_th_max(fx, size) - this.get_th_min(fx, size);
      return Math.round(def/20);
    },
    get_ths_default(fx, size) {
      if (fx == 'ratio') return 0.5;
      return this.ths_default[fx][`${size}`][this.th_measure];
    },
    set_ths_default() {
      for (const fx of this.fxs) {
        if (fx === "ratio") continue;
        for (const size of this.sizes) {
          const s = `${size}`;
          this.ths[fx][s] = this.ths_default[fx][s][this.th_measure]
        }
      }
    },
    onchange_measure() {
      this.set_ths_default();
      this.renderMathJax([this.$refs.toolbar]);
    },
    fx_symbol(fx) {
      return {
        'llr': '\\lambda',
        'nx': 'nx',
        'ctr': 'gt_{0.9}',
        'ratio': 'p'
      }[fx]
    },
    toggle_legend() {
      this.legend_show = !this.legend_show;
    },
    toggle_bounds() {
      this.bounds_show = !this.bounds_show;
    },
    render() {
      this.renderMathJax([this.$refs.toolbar]);
      this.renderMathJax([this.$refs.mathJaxEl]);
      if (this.legend_show)
        this.renderMathJax([this.$refs.legend]);
      if (this.bounds_show)
        this.renderMathJax([this.$refs.bounds]);
      this.renderMathJax([this.$refs.cms_table]);
    },
    async loadBounds() {
      const resp = await axios.get("http://127.0.0.1:3000/csv/bounds.csv")
      this.ths_default = resp.data;
      this.set_ths_default();
      this.$nextTick().then(() => {
        this.renderMathJax();
      });
    },
    renderMathJax(refs = [this.$refs.mathJaxEl]) {
      if (!refs ||  refs.length === 0 || !refs[0])
        return
      if (window.MathJax) {
        window.MathJax.config = {
          tex: {
            inlineMath: [
              ["$", "$"],
              ["\\(", "\\)"],
            ],
          },
          svg: {
            fontCache: "global",
          },
        };
        if (window.MathJax && window.MathJax.typesetPromise)
          window.MathJax.typesetPromise(refs);
      }
    },
  },
  updated: function () {
    this.$nextTick(function () {
      if(this.renderTable) {
        this.renderMathJax([this.$refs.cms_table_body]);
        this.clearMathJax();
        this.renderTable = false;
      }
    })
  },
  watch: {
    sortedArray: async function() {
      this.renderTable = true;
    }
  }
};
</script>

<style>
.greenclass {
  color: yellowgreen;
}
.redclass {
  color: red;
}
.column {
  display: flex;
  flex-direction: column;
}
.row {
  display: flex;
  flex-direction: row;
}
table > tbody > tr > td {
  vertical-align: middle;
  text-align: center;
  padding: 0 10px;
}
table > tbody > tr > th {
  text-align: left;
  padding: 0 20px;
}
table, .dataframe {
  border: 0 !important;
  padding: 50px 0px 0 0;
}
body {
  margin: 0;
  background-color: rgb(53, 53, 53);
}
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: white; /*#2c3e50;*/
  padding: 20px;
}
th,
td {
  vertical-align: top;
}
</style>