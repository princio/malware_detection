from re import DEBUG
from numpy.lib.arraysetops import unique
import psycopg2
from psycopg2.extras import execute_values
import pandas as pd
import numpy as np
import os
from pandasgui import show
import pprint

pp = pprint.PrettyPrinter(indent=4)

# With LLR2 we intend to set-to-0 (zeroing) the NOSFX values between two thresholds.
#
#
#
#
#
#
#
#


db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")


def f_llr(s_nosfx):
    num = s_nosfx.replace(
        [0, 1], [0.000_000_000_000_000_1, 1 - 0.000_000_000_000_000_1]
    )
    den = np.ones(len(num)) - num
    llr = np.log(num / den)
    return llr


df_pcap = pd.read_sql(
    'SELECT id, "name", "malware_id", "infected", "qr", q, r, "unique", days FROM pcap ORDER BY name',
    db,
)

windows = [
    2500,
    500,
    100,
]

max_q = np.lcm.reduce(windows) * (1_000_000 // np.lcm.reduce(windows))

query = """
DROP TABLE IF EXISTS public.window_qr;

CREATE TABLE IF NOT EXISTS public.window_qr
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    pcap_id integer NOT NULL,
    size integer NOT NULL,
    "window" integer NOT NULL,

    "first" integer[] DEFAULT '{0,0,0}'::integer[],
    "last" integer[] DEFAULT '{0,0,0}'::integer[],

    "begin_time" real[] DEFAULT '{0,0,0}'::real[],
    "end_time" real[] DEFAULT '{0,0,0}'::real[],

    "app" integer[] DEFAULT '{0,0,0}'::integer[],
    "unique" integer[] DEFAULT '{0,0,0}'::integer[],

    "txt" integer[] DEFAULT '{0,0,0}'::integer[],

    "ok" integer[] DEFAULT '{0,0,0}'::integer[],
    "nx" integer[] DEFAULT '{0,0,0}'::integer[],
    "oth" integer[] DEFAULT '{0,0,0}'::integer[],

    "llr" double precision[] DEFAULT '{0,0,0}'::double precision[],

    CONSTRAINT window_qr_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE public.window_qr
    OWNER to postgres;
"""

cur = db.cursor()

cur.execute(query)

cur.close()

db.commit()

for idx, pcap in df_pcap.iterrows():

    cur = db.cursor()

    for s in windows:
        nwindows = pcap.q // s + 1
        for offset in range(0, nwindows):

            query_requests = (
                """SELECT m3.*, dn."logit.0"[1] as logit
                    FROM message3 as m3 JOIN dn ON m3.dn_id=dn.id
                        WHERE pcap_id=%d AND is_response is FALSE
                            ORDER BY fn
                                LIMIT %d OFFSET %d"""
                % (
                    pcap.id,
                    s + 1,
                    s * offset,
                )
            )
            df_q = pd.read_sql(query_requests, db)

            first_fn_next_window = df_q.iloc[-1].fn if df_q.shape[0] == s+1 else pcap.qr

            df_q = df_q.iloc[0:s]

            query_responses = """SELECT m3.*, dn."logit.0"[1] as logit
                    FROM message3 as m3 JOIN dn ON m3.dn_id=dn.id
                        WHERE pcap_id=%d AND is_response is TRUE AND fn >= %d AND fn < %d
                        ORDER BY fn"""% (
                    pcap.id,
                    df_q.fn.min(),
                    pcap.qr if offset == nwindows-1 else df_q.fn.max(),
                )
            df_r = pd.read_sql(query_responses, db)


            print(
                "Queries  : Pcap %6d of size %6s: \t[%d] %6d <= fn < %6d\t[%d] %6d <= fn < %6d "
                % (pcap.id, pcap.qr, df_q.shape[0], df_q.fn.min(), df_q.fn.max(), df_r.shape[0], df_r.fn.min(), df_r.fn.max())
            )

            df = pd.concat([df_q, df_r], axis=0).sort_values(by="fn", ascending=True)

            dfs = [df, df_q, df_r]

            if df_q.empty or df_r.empty:
                break


            sum_cols = ["app", "ok", "txt", "nx", "no", "other", "llr"]

            app = [ df.shape[0] for df in dfs ]
            first = [ df.iloc[0].fn for df in dfs ]


            last = [ df.iloc[-1].fn for df in dfs ]

            begin_time = [ df.iloc[0].time_s for df in dfs ]
            end_time = [ df.iloc[-1].time_s for df in dfs ]

            nunique = [ df.dn_id.drop_duplicates().shape[0] for df in dfs ]

            txt = [ df.qcode.apply(lambda x: 1 if x == 16 else 0).sum()  for df in dfs ]

            ok = [ df.rcode.apply(lambda x: 1 if x == 0 else 0).sum() for df in dfs ]
            nx = [ df.rcode.apply(lambda x: 1 if x == 3 else 0).sum() for df in dfs ]
            oth = [ app[i] - ok[i] - nx[i] for i in range(3) ]

            llr = [ df.logit.sum() for df in dfs ]

            def cv(v):
                if type(v).__module__ == np.__name__:
                    return v.item()
                if type(v).__name__ == "list":
                    return [ vv.item() if type(vv).__module__ == np.__name__ else vv for vv in v]
                return v

            values = [ cv(v) for v in [pcap.id, s, offset, first, last, begin_time, end_time, app, nunique,  txt, ok, nx, oth, llr ] ]
            
            execute_values(
                cur,
                """INSERT INTO public.window_qr(
                    pcap_id, size, "window", first, last, begin_time, end_time, app, "unique", txt, ok, nx, oth, llr)
                    VALUES  %s;""",
                [values],
            )
        exit(0)
    db.commit()
    cur.close()
