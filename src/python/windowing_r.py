from re import DEBUG
from numpy.lib.arraysetops import unique
import psycopg2
from psycopg2.extras import execute_values
import pandas as pd
import numpy as np
import os
from pandasgui import show
import pprint

pp = pprint.PrettyPrinter(indent=4)

# With LLR2 we intend to set-to-0 (zeroing) the NOSFX values between two thresholds.
#
#
#
#
#
#
#
#


db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")


def f_llr(s_nosfx):
    num = s_nosfx.replace(
        [0, 1], [0.000_000_000_000_000_1, 1 - 0.000_000_000_000_000_1]
    )
    den = np.ones(len(num)) - num
    llr = np.log(num / den)
    return llr


df_pcap = pd.read_sql(
    'SELECT id, "name", "malware_id", "infected", "qr", q, r, "unique", days FROM pcap ORDER BY name',
    db,
)

windows = [
    2500,
    500,
    100,
]

max_q = np.lcm.reduce(windows) * (1_000_000 // np.lcm.reduce(windows))

query = """
DROP TABLE IF EXISTS public.window_qr;

CREATE TABLE IF NOT EXISTS public.window_qr
(
    id integer NOT NULL GENERATED ALWAYS AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    pcap_id integer NOT NULL,
    size integer NOT NULL,
    "window" integer NOT NULL,

    "first" integer[] DEFAULT '{0,0,0}'::integer[],
    "last" integer[] DEFAULT '{0,0,0}'::integer[],

    "begin_time" real[] DEFAULT '{0,0,0}'::real[],
    "end_time" real[] DEFAULT '{0,0,0}'::real[],

    "app" integer[] DEFAULT '{0,0,0}'::integer[],
    "unique" integer[] DEFAULT '{0,0,0}'::integer[],

    "txt" integer[] DEFAULT '{0,0,0}'::integer[],

    "ok" integer[] DEFAULT '{0,0,0}'::integer[],
    "nx" integer[] DEFAULT '{0,0,0}'::integer[],
    "oth" integer[] DEFAULT '{0,0,0}'::integer[],

    "llr" double precision[] DEFAULT '{0,0,0}'::double precision[],

    CONSTRAINT window_qr_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE public.window_qr
    OWNER to postgres;
"""

cur = db.cursor()

cur.execute(query)

cur.close()

db.commit()

for idx, pcap in df_pcap.iterrows():

    cur = db.cursor()

    query = """SELECT m3.fn, is_response
                    FROM message3 as m3
                    WHERE pcap_id=%d
                            ORDER BY fn""" % pcap.id
    df_fn = pd.read_sql(query, db)

    df_fn_q = df_fn[~df_fn.is_response].fn.to_frame().copy()
    df_fn_r = df_fn[df_fn.is_response].fn.to_frame().copy()


    for s in windows:
        nwindows = pcap.qr // s + 1

        df_q = df_fn_q.copy()
        df_q = df_q.reset_index()

        df_q['window'] = df_q['index'] // s
        
        df_q = df_q.groupby(by='window').aggregate(['first', 'last', 'count'])

        firsts = df_q[('fn', 'first')].values
        lasts = df_q[('fn', 'last')].values
        lasts[-1] = pcap.qr if lasts[-1] < pcap.qr else lasts[1]

        responses_limits = [ (firsts[i], lasts[i] ) for i in range(len(firsts))]

        offset = -1
        for limits in responses_limits:
            offset += 1
            query = (
                """SELECT m3.*, dn."logit.0"[1] as logit
                    FROM message3 as m3 JOIN dn ON m3.dn_id=dn.id
                        WHERE pcap_id=%d AND fn >= %d AND fn <= %d
                            ORDER BY fn"""
                % (
                    pcap.id,
                    limits[0],
                    limits[1],
                )
            )
            df = pd.read_sql(query, db)
            df_q = df[~df.is_response]
            df_r = df[df.is_response]

            if df_r.shape[0] == 0:
                df_r = df_r.append(pd.Series(0, index=df_r.columns), ignore_index=True)

            print(
                "Pcap %6d, size %6d, window %d/%d (s=%d): \t\tq: [%d] %6d <= fn <= %6d\tr: [%d] %6d <= fn <= %6d"
                % (pcap.id, pcap.qr, offset+1, nwindows, s,
                    df_q.shape[0], df_q.fn.min(), df_q.fn.max(),
                    df_r.shape[0], df_r.fn.min(), df_r.fn.max(),
                )
            )

            df = pd.concat([df_q, df_r], axis=0).sort_values(by="fn", ascending=True)

            dfs = [df, df_q, df_r]

            sum_cols = ["app", "ok", "txt", "nx", "no", "other", "llr"]

            app = [ df.shape[0] for df in dfs ]
            first = [ df.iloc[0].fn for df in dfs ]


            last = [ df.iloc[-1].fn for df in dfs ]

            begin_time = [ df.iloc[0].time_s for df in dfs ]
            end_time = [ df.iloc[-1].time_s for df in dfs ]

            nunique = [ df.dn_id.drop_duplicates().shape[0] for df in dfs ]

            txt = [ df.qcode.apply(lambda x: 1 if x == 16 else 0).sum()  for df in dfs ]

            ok = [ df.rcode.apply(lambda x: 1 if x == 0 else 0).sum() for df in dfs ]
            nx = [ df.rcode.apply(lambda x: 1 if x == 3 else 0).sum() for df in dfs ]
            oth = [ app[i] - ok[i] - nx[i] for i in range(3) ]

            llr = [ df.logit.sum() for df in dfs ]

            def cv(v):
                if type(v).__module__ == np.__name__:
                    return v.item()
                if type(v).__name__ == "list":
                    return [ vv.item() if type(vv).__module__ == np.__name__ else vv for vv in v]
                return v

            values = [ cv(v) for v in [pcap.id, s, offset, first, last, begin_time, end_time, app, nunique,  txt, ok, nx, oth, llr ] ]

            execute_values(
                cur,
                """INSERT INTO public.window_qr(
                    pcap_id, size, "window", first, last, begin_time, end_time, app, "unique", txt, ok, nx, oth, llr)
                    VALUES  %s;""",
                [values],
            )
    db.commit()
    cur.close()
