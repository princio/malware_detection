import os
import pandas as pd
import sqlite3
import hashlib
import subprocess
from datetime import datetime
import sys


def hash_(pcap_path):
    BUF_SIZE = 65536
    sha256 = hashlib.sha256()
    with open(pcap_path, 'rb') as f:
        while True:
            data = f.read(BUF_SIZE)
            if not data:
                break
            sha256.update(data)
    return sha256.hexdigest()

def pcap2sqlite(pcap_path, infected = False, redo = False):
    if not os.path.exists(pcap_path):
        print('File not exists.')
        return False

    db_path = '/media/princio/ssd512/stratosphere/pcapdns.sqlite3'
    dns_parser = '/home/princio/Desktop/malware_detection/pcap_to_sqlite3/dns_parse_rcode/bin/dns_parse'
    pcap_name = os.path.basename(pcap_path)

    print('Hashing...')
    pcap_hash = hash_(pcap_path)

    db = sqlite3.connect(db_path)
    cur = db.cursor()

    try:
        to_do = True
        pcap_id = cur.execute("""SELECT id, qr FROM pcap WHERE pcap_hash = ?""", [pcap_hash]).fetchone()

        if pcap_id is not None:
            message_count = pcap_id[1]
            pcap_id = pcap_id[0]
            message_inserted = cur.execute("""SELECT COUNT(id) FROM message WHERE pcap_id = ?""", [pcap_id]).fetchone()[0]
            print('ciao', message_count, message_inserted)


            if message_count != message_inserted:
                print('Mismatch for <%s>:\n#####%d != %d' % (pcap_path, message_count, message_inserted))
                cur.execute("""DELETE FROM message WHERE pcap_id = ?""", [pcap_id])
                cur.execute("""DELETE FROM pcap WHERE id = ?""", [pcap_id])
                to_do = True
            else:
                to_do = redo

        if not to_do:
            return True
            
        print('Parsing...')
        ret = subprocess.run([dns_parser, '-ndcS', pcap_path], capture_output=True)
        if ret.returncode != 0:
            raise Exception('Error during parsing:\n%s' % ret.stderr)

        print('Reading...')
        df = pd.read_csv('/tmp/dnsparse.csv', index_col=False)

        print('Inserting pcap...')
        delta = datetime.fromtimestamp(df['time'].iloc[-1]) - datetime.fromtimestamp(df['time'].iloc[0])
        pcap_days = float(f'{delta.days}.{int(delta.seconds/3600/0.24)}')

        qr = df.shape[0]
        q = df[df.qr == 'q'].shape[0]
        r = qr - q
        u = df.dn.drop_duplicates().shape[0]
        pcap_id = cur.execute("""INSERT INTO pcap ('name','pcap_hash','infected','qr','q','r','unique', 'unique_norm','days') VALUES
                                        (?,?,?,?,?,?,?,?,?)""",
                    [pcap_name, pcap_hash, infected, qr, q, r, u, u/qr, pcap_days]
        ).lastrowid

        dict_dn = pd.read_sql('SELECT dn, id FROM dn', db).set_index('dn').to_dict(orient='index')

        print('Inserting DNs...')
        inserts = []
        df_udn = df[['dn', 'bdn']].copy().drop_duplicates()
        df_udn['id'] = -1

        inserts = []
        for _, row in df_udn.iterrows():
            if row['dn'] not in dict_dn:
                inserts.append([row['dn'], row['bdn']])
        cur.executemany("""INSERT INTO "main"."dn"("id","dn","basedomain") VALUES (NULL,?,?);""", inserts)
                
        df_dn = pd.read_sql('SELECT dn, id FROM dn' , db)

        dff = df.merge(df_dn, left_on='dn', right_on='dn')


        dff['dn'] = dff['id']
        dff = dff.drop(columns=['id', 'bdn']).rename(columns={'dn': 'dn_id'})
        dff['qr'] = dff['qr'].apply(lambda x: x == 'r')


        print('Inserting messages...')
        dff.insert(0, 'pcap_id', pcap_id)
        cur.executemany(
            """
            INSERT INTO "main"."message"
            ("id","pcap_id","time","size","protocol","server","message_ID","qr","aa","rcode","dn_id","qcode","qdcount","ancount","nscount","arcount","answer")
            VALUES (NULL,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?);
            """,
            dff.values)

        db.commit()
        print('Done.')
    except Exception as e:
        print(e)
        db.close()
        return False

    db.close()
    return True

if __name__ == '__main__':
    if len(sys.argv) == 1:
        print('No pcap path passed.')
        exit(1)

    pcap_path = sys.argv[1]

    exit(pcap2sqlite(pcap_path))
    
    pass
