import numpy as np

class Metric:
    def __init__(self, name, precision = 0, recall = 0, f1_score = 0, support = 0):
        self.name = name
        self.precision = precision
        self.recall = recall
        self.f1_score = f1_score
        self.support = support

    def __str__(self):
        return ("%s: %f, %f, %f, %d" % (self.name, self.precision, self.recall, self.f1_score, self.support))

    def sum(self, metric):
        self.precision = self.precision + metric.precision
        self.recall = self.recall + metric.recall
        self.f1_score = self.f1_score + metric.f1_score
        self.support = self.support + metric.support


    def div(self, scalar):
        self.precision = self.precision / scalar
        self.recall = self.recall / scalar
        self.f1_score = self.f1_score / scalar
        self.support = self.support / scalar

    def tolist(self):
        s = self.support
        if type(s) is np.int64:
            s = s.item()
        return [self.precision, self.recall, self.f1_score, s]

    @staticmethod
    def fromlist(name, values):
        metric = Metric(name)
        metric.precision = values[0]
        metric.recall = values[1]
        metric.f1_score = values[2]
        metric.support = int(values[3])
        return metric
        