import math
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from dash.dependencies import Input, Output
from plotly.subplots import make_subplots
import dash_bootstrap_components as dbc

import psycopg2
import pandas as pd
import plotly.express as px
import numpy as np
import plotly.graph_objects as go
import os
from sklearn.metrics import classification_report, confusion_matrix
import plotly.figure_factory as ff

db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")

def win_name(window, nn, exclude):
    return "win_%d_%s%s.csv" % (
        window,
        nn,
        f"_{exclude}" if exclude != "None" else "",
    )

def f_llr(s_nosfx):
    num = s_nosfx.replace([0, 1], [0.000_000_000_000_1, 1 - 0.000_000_000_000_1])
    den = np.ones(len(num)) - num
    llr = np.log(num / den)
    return llr


df_pcap = pd.read_sql(
    'SELECT id, "name", "malware_id", "infected", "qr", q, r, "unique", days FROM pcap WHERE "unique" > 2000 and "unique"< 6000 ORDER BY name',
    db,
)

pcap_cols = ["pcap_id", "malware_id", "infected"]
wins_cols = [
    "window",
    "llr",
    "size",
    "nx",
    "no",
    "txt",
    "nx_top10m",
    "no_top10m",
    "txt_top10m",
]

windows = [100, 500, 1000, 2000]
nns = ['nosfx', 'domain']
excludes = {"None": None, "exc-1": [0.2, 0.8], "exc-2": [0.3, 0.7], "exc-3": [0.4, 0.6]}

dfs = {}

for window in windows:
    for nn in nns:
        for exc in excludes:
            wname = win_name(window, nn ,exc)
            if not os.path.exists(os.path.join('/tmp/', wname)):
                dfs[wname] = pd.DataFrame([], columns=wins_cols)

for idx, pcap in df_pcap.iterrows():

    query = "SELECT * FROM qr_grouped_view WHERE pcap_id=%d ORDER BY q_time" % pcap["id"]
    df = pd.read_sql(query, db)

    df["size"] = 1
    df["nx"] = df.rcode.apply(lambda x: 1 if x == 3 else 0)
    df["no"] = df.rcode.fillna(value=-1).apply(lambda x: 1 if x == -1 else 0)
    df["txt"] = df.qcode.apply(lambda x: 1 if x == 16 else 0)
    df["top10m"] = df["top10m"].astype(np.single)
    df["nx_top10m"] = df[["nx", "top10m"]].apply(
        lambda x: 1 if (x[0] == 1) and np.isnan(x[1]) else 0, axis=1
    )
    df["no_top10m"] = df[["no", "top10m"]].apply(
        lambda x: 1 if (x[0] == 1) and np.isnan(x[1]) else 0, axis=1
    )
    df["txt_top10m"] = df[["txt", "top10m"]].apply(
        lambda x: 1 if (x[0] == 1) and np.isnan(x[1]) else 0, axis=1
    )

    for window in windows:
        for nn in nns:
            for exc in excludes:
                wname = win_name(window, nn ,exc)
                if wname not in dfs:
                    continue
                df__ = df.copy()
                if exc != "None":
                    df__ = df__[~((df__[nn] > excludes[exc][0]) & (df__[nn] < excludes[exc][1]))]
                df__["llr"] = f_llr(df__[nn])
                df__["window"] = df__.index // window
                df__ = df__[wins_cols].groupby("window").sum().reset_index()
                df__["infected"] = bool(pcap["infected"])
                df__["pcap_id"] = pcap["id"]
                df__["malware_id"] = pcap["malware_id"]
                dfs[wname] = pd.concat([dfs[wname], df__[pcap_cols + wins_cols]], ignore_index=True)

    print(idx)

for dfs_name in dfs:
    dfs[dfs_name].to_csv(os.path.join('/tmp/', dfs_name))
