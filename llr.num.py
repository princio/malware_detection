import os, json
from math import log
import numpy as np
import matplotlib.pyplot as plt
import math

plt.set_loglevel("warning")


# mixed 1 | 6747
# mixed 4 | 175

mixed = {
    1: ['mixed_capture_1/mixed', 6747],
    2: ['mixed_capture_2/mixed', 0],
    3: ['mixed_capture_3/mixed', 0],
    4: ['mixed_capture_4/mixed', 174],
    5: ['mixed_capture_5/mixed', 0]
}

def format_input(x):
    x = x.replace('www.','').split('.')
    return x[0] + x[-1]

def llr():

    mixed_num = 1

    frame_detection_number = mixed[mixed_num][1]
    pcap_root = f'datasets/pcaps/{mixed[mixed_num][0]}'

    if os.path.exists(f'{pcap_root}.npy'):
        predictions = np.load(open(f'{pcap_root}.npy', 'rb'), allow_pickle=True)
    else:
        from Model import Model
        from Pcap import Pcap
        from Repository import ModelRepository
        id_mio = 'fb9ffddd-de28-439c-8ae5-3473f390e6cf'
        id_granatiero = 'c62c1bed-722f-4a7e-b0a8-09d2b50e9732'
        model = ModelRepository.fetch(connection, id_granatiero)
        pcap = Pcap(f'{pcap_root}.csv')
        predictions, _ = model.predict_pcap(pcap, format_input, csv_path=f'{pcap_root}.out.csv')
        predictions = np.asarray(predictions.ravel(), dtype='float64')
        np.save(f'{pcap_root}', predictions)

    len__ = len(predictions)
    deltas = [math.ceil(0.07*len__), math.ceil(0.1*len__), frame_detection_number]
    _fig, axs = plt.subplots(2, len(deltas))  # Create a figure and an axes.
    good_binary = {}
    bad_binary = {}
    good_float = {}
    bad_float = {}
    for idx, delta in enumerate(deltas):
        slices_number = math.ceil(len__/delta)

        good_binary[delta] = np.zeros(slices_number*2)
        bad_binary[delta] = np.zeros(slices_number*2)
        good_float[delta] = np.zeros(slices_number*2)
        bad_float[delta] = np.zeros(slices_number*2)

        x = np.zeros(slices_number*2)

        for z in range(0, slices_number):
            l = (z+1)*delta if (z+1)*delta < len__ else len__
            for i in range(z*delta, l):
                zz = z*2
                if predictions[i] > 0.5:
                    bad_binary[delta][zz] += 1
                    bad_float[delta][zz] += predictions[i] - 0.5
                else:
                    good_binary[delta][zz] += 1
                    good_float[delta][zz] += 0.5 - predictions[i]

            x[zz] = z*delta
            x[zz+1] = l-1
            bad_binary[delta][zz+1] = bad_binary[delta][zz]
            bad_float[delta][zz+1] = bad_float[delta][zz]
            good_binary[delta][zz+1] = good_binary[delta][zz]
            good_float[delta][zz+1] = good_float[delta][zz]

        axs[0, idx].plot(x, good_binary[delta], label=f'good_float')
        axs[0, idx].plot(x, bad_binary[delta], label=f'bad_float')
        axs[0, idx].axvline(x=frame_detection_number, color='red')
        axs[0, idx].set_title(f'binary prediction sum with delta={delta}')
        axs[0, idx].legend()

        axs[1, idx].plot(x, good_float[delta], label=f'good_float')
        axs[1, idx].plot(x, bad_float[delta], label=f'bad_float')
        axs[1, idx].axvline(x=frame_detection_number, color='red')
        axs[1, idx].set_title(f'float prediction with delta={delta}')
        axs[1, idx].legend()
    
    plt.show()
    pass

if __name__ == "__main__":
    import matplotlib.rcsetup as rcsetup
    llr()


    # for delta in [3,5]:
    #     print("delta=%d" % delta)
    #     for z in range(13-delta + 1):
    #         for i in range(z, z + delta):
    #             print("%5d %5d" % (z, i))
    #         print("----")

    pass