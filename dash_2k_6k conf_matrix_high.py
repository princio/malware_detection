import math
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from dash.dependencies import Input, Output
from plotly.subplots import make_subplots
import psycopg2
import pandas as pd
import plotly.express as px
import numpy as np
import plotly.graph_objects as go
import os
from sklearn.metrics import classification_report, confusion_matrix
import plotly.figure_factory as ff


db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")

# pcap_list = [
#     ["27_2017_04_30-normal.pcap", 858],
#     ["32_2017-05-02_normal.pcap", 859],
#     ["29_2017-05-01_normal.pcap", 872],
#     ["30_2017-05-01_normal.pcap", 873],
#     ["31_2017-05-01_normal.pcap", 874],
#     ["10_2013-08-20_capture-win10.pcap", 80],
#     ["303-1_2017-08-12_capture-win2.pcap", 106],
#     ["5_2013-08-20_capture-win14.pcap", 845],
#     ["7_2013-08-20_capture-win1.pcap", 846],
#     ["10_2013-08-20_capture-win9.pcap", 847],
#     ["25-2_2014-01-25_capture_win3.pcap", 848],
#     ["6_2013-08-20_capture-win6.pcap", 849],
#     ["6_2013-08-20_capture-win11.pcap", 850],
#     ["10_2013-08-20_capture-win7.original.pcap", 851],
#     ["10_2013-08-20_capture-win7.pcap", 852],
#     ["110-6_2015-06-07_capture-win9.pcap", 853],
#     ["69_2014-04-07_capture-win17.pcap", 854],
#     ["71_2014-04-07_capture-win19.fixed.pcap", 855],
#     ["25-6_2014-12-20_capture-win3.pcap", 856],
#     ["170-1_capture-win6.pcap", 857]
# ]
def calc_windows(unique=False, th=0, window=1000):

    fname = '/tmp/win_%d_%0.3f%s.csv' % (window, th, '_unique' if unique else '')

    def f_llr(s_nosfx):
        num = s_nosfx.replace([0, 1], [0.000_000_000_000_1, 1-0.000_000_000_000_1])
        den = np.ones(len(num)) - num
        llr = np.log(num/den)
        return llr

    df_pcap = pd.read_sql('SELECT id, "name", "malware_id", "infected", "qr", q, r, "unique", days FROM pcap WHERE "unique" > 2000 and "unique"< 6000 ORDER BY name', db)

    print('Windowing with %d' % window)
    if not os.path.exists(fname):
        pcap_cols=['pcap_id', 'malware_id', 'infected']
        wins_cols = ['window', 'llr', 'size', 'nx', 'no', 'txt', 'nx_top10m', 'no_top10m', 'txt_top10m']
        df_wins = pd.DataFrame([], columns=wins_cols)
        for _,pcap in df_pcap.iterrows():
            df = pd.read_sql('SELECT * FROM qr_grouped_view WHERE pcap_id=%d ORDER BY q_time' % pcap['id'], db)

            df['llr'] =  f_llr(df.nosfx)
            df['window'] =  df.index // window
            df['size'] =  1
            df['nx'] =  df.rcode.apply(lambda x: 1 if x == 3 else 0)
            df['no'] =  df.rcode.fillna(value=-1).apply(lambda x: 1 if x == -1 else 0)
            df['txt'] =  df.qcode.apply(lambda x: 1 if x == 16 else 0)
            df['nx_top10m'] =  df[['nx', 'top10m']].apply(  lambda x: 1 if (x[0] == 1) and np.isnan(x[1]) else 0, axis=1)
            df['no_top10m'] =  df[['no', 'top10m']].apply(  lambda x: 1 if (x[0] == 1) and np.isnan(x[1]) else 0, axis=1)
            df['txt_top10m'] =  df[['txt', 'top10m']].apply(lambda x: 1 if (x[0] == 1) and np.isnan(x[1]) else 0, axis=1)

            df_win = df[wins_cols].groupby('window').sum().reset_index()
            df_win['infected'] = bool(pcap['infected'])
            df_win['pcap_id'] = pcap['id']
            df_win['malware_id'] = pcap['malware_id']

            df_wins = pd.concat([df_wins, df_win[pcap_cols + wins_cols]], ignore_index=True)
        df_wins.to_csv(fname)

    df = pd.read_csv(fname, index_col=0).reset_index()

    df.malware_id = df.malware_id.fillna(-1).astype(int).astype(str).replace(to_replace=-1, value='no-malware')

    df['nx_no'] = df.nx + df.no
    df['nx_no_txt'] = df.nx + df.no + df.txt

    df['nx_no_top10m'] = df.nx_top10m + df.no_top10m
    df['nx_no_txt_top10m'] = df.nx_top10m + df.no_top10m + df.txt_top10m

    cols = [
        (   df.infected.astype(bool),  df.llr > 0,                  'Pcap-label', 'LLR > 0'                        ),
        (   df.infected.astype(bool),  df.nx_no_txt > 5,           'Pcap-label', 'avg(NX+NO+TXT) > 5'            ),
        (   df.infected.astype(bool),  df.nx_no_txt_top10m > 5,    'Pcap-label', 'avg(NX+NO+TXT)_TOP10M > 5'     ),
        (   df.infected.astype(bool),  df.nx_no_txt > 30,           'Pcap-label', 'avg(NX+NO+TXT) > 30'            ),
        (   df.infected.astype(bool),  df.nx_no_txt_top10m > 30,    'Pcap-label', 'avg(NX+NO+TXT)_TOP10M > 30'     ),
        (   df.nx_no_txt > 5,         df.llr > 0,                  'avg(NX+NO+TXT) > 5', 'LLR > 0'               ),
        (   df.nx_no_txt_top10m > 5,  df.llr > 0,                  'avg(NX+NO+TXT)_TOP10M > 5', 'LLR > 0'        )
    ]
    divs = []
    for col in cols:
        y_true = col[0]
        y_pred = col[1]
        report = classification_report(y_true, y_pred, target_names=['not infected', 'infected'])
        cmatrix = confusion_matrix(y_true, y_pred)
        x = ['normal', 'infected']
        y = ['normal', 'infected']
        z = cmatrix
        z_text = cmatrix
        fig = ff.create_annotated_heatmap(z, x=x, y=y, annotation_text=z_text, colorscale='Viridis')
        fig.update_layout(height=300,width=600, font=dict(size=24), margin=dict(t=20, l=20, b=20, r=20))
        fig.update_xaxes(title='predict', title_font = {"size": 20})
        fig.update_yaxes(title='true', title_font = {"size": 20}, tickfont={"size": 20})
        divs.append(
                html.Div(
                [
                    html.Div([html.H2('True: ' + col[2]), html.H2('Predict: ' + col[3])], style={'width': '450px', 'height': '100%', 'margin-top':'50px'}),
                    html.Div(
                        dcc.Graph(figure=fig)
                    ),
                    html.Pre(
                        report,
                        style={'font-family': 'monospace', 'font-size': '20px'}
                    )
                ],
                style={'display': 'flex', 'flex-direction': 'row', 'border': '1px solid black'}

            )
        )

    df2 = df.groupby('malware_id').mean().reset_index()

    print(df2)
    return [
            html.H1('Windowing %d queries' % window, style={'text-aling': 'center'})
        ] + divs + [
            html.Div(
                dcc.Graph(figure=px.scatter(df, symbol='infected', x='index', y='nx', color='malware_id'))
            ),
            html.Div(
                dcc.Graph(figure=px.scatter(df, symbol='infected', x='index', y='no', color='malware_id'))
            ),
            html.Div([
                    dcc.Graph(figure=px.bar(df2, y='llr', x='malware_id')),
                    dcc.Graph(figure=px.bar(df2, y='nx', x='malware_id')),
                    dcc.Graph(figure=px.bar(df2, y='nx_no', x='malware_id')),
                    dcc.Graph(figure=px.bar(df2, y='nx_no_txt', x='malware_id'))
                ],
                style={'display': 'flex', 'flex-direction': 'row'}
            ),
            html.Div([
                    dcc.Graph(figure=px.bar(df2, y='llr', x='malware_id')),
                    dcc.Graph(figure=px.bar(df2, y='nx_top10m', x='malware_id')),
                    dcc.Graph(figure=px.bar(df2, y='nx_no_top10m', x='malware_id')),
                    dcc.Graph(figure=px.bar(df2, y='nx_no_txt_top10m', x='malware_id'))
                ],
                style={'display': 'flex', 'flex-direction': 'row'}
            )
        ]

app = dash.Dash(__name__)

app.layout = html.Div([
    # dcc.Dropdown(
    #     id='demo-dropdown',
    #     options=[
    #         {'label': 'window 100', 'value': '100'},
    #         {'label': 'window 500', 'value': '500'},
    #         {'label': 'window 1000', 'value': '1000'},
    #         {'label': 'window 2000', 'value': '2000'}
    #     ],
    #     value='1000',
    #     searchable=False,
    #     clearable=False
    # ),
    dcc.Dropdown(
        id='demo-dropdown',
        options=[
            {'label': '100', 'value': 100},
            {'label': '500', 'value': 500},
            {'label': '1000', 'value': 1000},
            {'label': '2000', 'value': 2000},
        ],
        value=1000,
        clearable=False
    )  
    # html.Div([
    #     dcc.Slider(
    #         id='my-slider',
    #         max=13927,
    #         min=-51027,
    #         step=500,
    #         value=0,
    #     ),
    #     html.Div([], id='my-slider-value')
    # ]),
    # dcc.Checklist(
    #     id='unique-checkbox',
    #     options=[
    #         {'label': 'uniques', 'value': 'unique'},
    #     ],
    #     value=[]
    # ),
    # html.Button('Submit', id='submit-val', n_clicks=0),
    , html.Div(
        calc_windows(),
        id='result-container'
    )
])


@app.callback(
    dash.dependencies.Output('result-container', 'children'),
    [dash.dependencies.Input('demo-dropdown', 'value')])
def update_output(value):
    return calc_windows(window=value)


# @app.callback(
#     dash.dependencies.Output('result-container', 'children'),
#     [dash.dependencies.Input('submit-val', 'n_clicks')],
#     [dash.dependencies.State('unique-checkbox', 'value'),
#     dash.dependencies.State('my-slider', 'value')])
# def update_output(n_clicks, unique, slider):
#     print(unique, slider)
#     return calc_windows(unique='unique' in unique, th=float(slider))

# @app.callback(
#     dash.dependencies.Output('my-slider-value', 'children'),
#     dash.dependencies.Input('my-slider', 'value'))
# def update_slider_value(slider):
#     return slider

if __name__ == '__main__':
    app.run_server(debug=False, port=8051)
