from DomainLevel import DomainLevel, extractor
import pandas as pd
from os import path as os_path, environ

class Capture():
    NUM = 0
    TIME = 1
    DOMAIN = 2
    LABEL = 3
    CLASS = 4

    def __init__(self, name, or_path, frame_infection_number = None, notes = None):
        is_debug = environ.get('DEBUG') == 'True'
        self.name = name + ('_debug' if is_debug else '')
        self.path = f'captures/{name}.csv'
        self.or_path = or_path
        self.frame_infection_number = frame_infection_number
        self.notes = notes
        if not os_path.exists(self.path):
            df = pd.read_csv(self.or_path, nrows=(100 if is_debug else None))
            if df.shape[1] != 3 and df.shape[1] != 4:
                raise 'Capture incompatible'
            df.columns = ['num', 'time', 'domain']
            if df.shape[1] == 4:
                df.columns.append('label')
            df.to_csv(self.path)
            df = df
        else:
            df = pd.read_csv(self.path, nrows=(100 if is_debug else None))
            if not all(column in df.columns for column in ['num', 'time', 'domain']):
                raise 'Capture incompatible'
        self.df = df
        self.dataset = 'label' in self.df.columns and 'class' in self.df.columns

    @property
    def type(self):
        return self.name[:self.name.index('_')]

    @property
    def domain(self):
        return self.df['domain']

    @property
    def class_(self):
        return self.df['class']

    @property
    def label(self):
        if 'label' in self.df.columns:
            return self.df['label']
        return None

    @staticmethod
    def load(name):
        path = f'captures/{name}.csv'
        if not os_path.exists(path):
            return False
        return Capture(pd.read_csv(path), name)

    @property
    def readable(self):
        if self.dataset:
            return self.df.loc[:, ['domain', 'label', 'class']]
        return self.df['domain']

    @property
    def tld(self):
        return self.df['domain'].apply(lambda x: extractor(x).suffix) #pd.Series([extractor(domain).suffix for domain in self.df['domain'].to_numpy(str)], name='tld')





normal = {
    '27': Capture('normal_27', 'datasets/pcaps/normal_27/2017_04_30-normal.pcap.csv'), #'len': 26461,
    '31': Capture('normal_31', 'datasets/pcaps/normal_31/2017-05-01_normal.pcap.csv') #'len': 40122,
}
mixed = {
    '1': Capture('mixed_1', 'datasets/pcaps/mixed_capture_1/mixed.csv', frame_infection_number=6747), #32251
    '2': Capture('mixed_2', 'datasets/pcaps/mixed_capture_2/mixed.csv'), #4319
    '3': Capture('mixed_3', 'datasets/pcaps/mixed_capture_3/mixed.csv'), #763
    '4': Capture('mixed_4', 'datasets/pcaps/mixed_capture_4/mixed.csv', frame_infection_number=174) #407
}
botnet = {
    '1': Capture('botnet_1', 'datasets/pcaps/botnet-1/2013-10-01_capture-win12.pcap.csv'), #12145,
    '3': Capture('botnet_3', 'datasets/pcaps/botnet-3/2013-08-20_capture-win15.pcap.csv'), #188683,
    '5.1': Capture('botnet_5_1', 'datasets/pcaps/botnet-5/2013-08-20_capture-win12.pcap.csv'), #2782597,
    '5.2': Capture('botnet_5_2', 'datasets/pcaps/botnet-5/2013-08-20_capture-win13.pcap.csv')  #468388,
}
all_ = list(normal.values()) + list(mixed.values()) + list(botnet.values())
training = Capture('training', 'dataset/')