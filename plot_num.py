import math
import numpy as np

def plot_num(predictions, frame_detection_number = None, deltas = None):
    len__ = len(predictions)
    if deltas is None:
        last_delta = math.ceil(0.2*len__) if frame_detection_number is None else frame_detection_number
        deltas = [math.ceil(0.07*len__), math.ceil(0.1*len__), last_delta]

    good_binary = {}
    bad_binary = {}
    good_float = {}
    bad_float = {}
    x = {}
    for delta in deltas:
        slices_number = math.ceil(len__/delta)

        good_binary[delta] = np.zeros(slices_number*2)
        bad_binary[delta] = np.zeros(slices_number*2)
        good_float[delta] = np.zeros(slices_number*2)
        bad_float[delta] = np.zeros(slices_number*2)

        x[delta] = np.zeros(slices_number*2)

        for z in range(0, slices_number):
            l = (z+1)*delta if (z+1)*delta < len__ else len__

            zz = z*2
            bad_binary[delta][zz] = np.asarray(sum(1 for i in range(z*delta, l) if predictions[i] > 0.5))
            bad_float[delta][zz] = np.asarray(sum(predictions[i] - 0.5 for i in range(z*delta, l) if predictions[i] > 0.5))
            good_binary[delta][zz] = np.asarray(sum(1 for i in range(z*delta, l) if predictions[i] <= 0.5))
            good_float[delta][zz] = np.asarray(sum(0.5 - predictions[i] for i in range(z*delta, l) if predictions[i] <= 0.5))

            x[delta][zz] = z*delta
            x[delta][zz+1] = l-1
            bad_binary[delta][zz+1] = bad_binary[delta][zz]
            bad_float[delta][zz+1] = bad_float[delta][zz]
            good_binary[delta][zz+1] = good_binary[delta][zz]
            good_float[delta][zz+1] = good_float[delta][zz]

    return x, good_binary, bad_binary, good_float, bad_float