import os, math, json
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from dash.dependencies import Input, Output, State
from plotly.subplots import make_subplots
import sqlite3
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go


db_path = '/media/princio/ssd512/stratosphere/db_3.sqlite3'
dirs = {
    'botnet': '/media/princio/ssd512/stratosphere/pcap/csv/malware/',
    'normal': '/media/princio/ssd512/stratosphere/pcap/csv/normal/'
}
pcap_dict = {'normal':{}, 'botnet':{}}
pcap_grouped_dict = {}

DF = None

def get_df(pcap_row, reload=False):
    pcaptype = pcap_row['type']
    pcapname = pcap_row['name']
    df_path = os.path.join(dirs[pcaptype], pcapname)
    pcap_dict[pcaptype][pcapname] = pd.read_csv(df_path, usecols=list(range(0,12)))
    return pcap_dict[pcaptype][pcapname].copy()

default_pcap_id = 25

db = sqlite3.connect(db_path)
df_pcaps = pd.read_sql('SELECT * from pcap', db)
db.close()
df_pcaps = df_pcaps.drop(columns=['s_id', 's_win'])
df_pcaps.set_index('id', inplace=True, drop=False)
df_pcaps['unique_norm'] = df_pcaps['unique_norm'].mul(100).round(2)
df_pcaps.drop(columns=['qry/h'], inplace=True)

def get_row(pcap_id):
    return df_pcaps[df_pcaps.id == pcap_id].iloc[0].to_dict()


def fetch_df_grouped(pcap_id):
    db = sqlite3.connect(db_path)
    df = pd.read_sql('select * from pcap_queries_2 WHERE pcap_id = %d' % pcap_id, db)
    db.close()
    df['responses'] = df['tot'].sub(df['no'])
    df['top10m'] = df['top10m'].apply(lambda x: 'legit' if x == 1 else 'unknown')
    df['bad'] = df['tot'].sub(df['ok'])
    df['err'] = df['responses'].sub(df['ok'])
    df['oth'] = df['err'].sub(df['nx'])
    pcap_grouped_dict[pcap_id] = df.copy()
    return df


def treemap_unique(pcap_row):
    figures = []

    df = fetch_df_grouped(pcap_row['id']).copy()

    bins = np.concatenate([
            np.arange(start=0, stop=0.1, step=0.02),
            [0.1, 0.4, 0.6, 0.9],
            np.arange(start=0.92, stop=1.01, step=0.02)
        ],
        axis=None
    )
    bins = np.arange(start=0, stop=1.01, step=0.1)

    for l in ['ok', 'no', 'nx', 'oth']:
        df[l] = df[l].div(df.tot)

    df['nosfx_bin'] = pd.cut(df.nosfx, bins, right=True, include_lowest=True)
    df['ok_bin'] = pd.cut(df.ok, bins, right=True, include_lowest=True)

    df = df.groupby(['ok_bin', 'nosfx_bin']).count().reset_index()

    df = fetch_df_grouped(pcap_row['id']).copy()

    df['count'] = 1

    for l in ['ok', 'no', 'nx', 'oth']:
        df[l] = df[l].div(df.tot)

    df['nosfx_bin'] = pd.cut(df.nosfx, bins, right=True, include_lowest=True)
    df['ok_bin'] = pd.cut(df.ok, bins, right=True, include_lowest=True)

    df['query_tot'] = df.apply(lambda x: str(x.tot) + ':' + x['query'], axis=1)

    df = df.groupby(['ok_bin', 'nosfx_bin'])[['count', 'query_tot']].agg({
        'count': 'sum',
        'query_tot': lambda x: x.iloc[0:3].str.cat(sep=",")
    }).reset_index()

    x = df.ok_bin.apply(lambda x: x.right.round(2))
    y = df.nosfx_bin.apply(lambda x: x.right.round(2))
    z = df['count']
    cmax = df['count'].max() // 4

    fig = go.Figure(data=go.Heatmap(
        x=x,#df.ok_bin.astype(str),
        y=y,#df.nosfx_bin.astype(str),
        z=z,
        colorbar=dict(
            tickmode='array',
            tickvals=[1, cmax, cmax*2, cmax*3, df['count'].max()],
            thickness=10,
            x=0.78
            )
        )
    )
    fig.update_xaxes(
        title='ok',
        constrain='domain',
        type='category',
        tick0=0,
        dtick=0.1,
        nticks=10,
        tickson='boundaries',
        tickwidth=5,
        automargin=False,
        title_standoff=3,
    )
    fig.update_yaxes(
        title='nn',
        type='category',
        tick0=0,
        dtick=0.1,
        nticks=10,
        # autorange='reversed',
        tickson='boundaries',
        scaleanchor = 'x',
        scaleratio = 1,
        tickwidth=5,
        automargin=False,
        title_standoff=2,
    )
    fig.update_layout(
        title=dict(text=pcap_row['name'], x=0.5, xanchor='center', font_size=12),
        # height=400,
        autosize=False,
        margin=(dict(autoexpand=False, pad=0, t=50,b=50,r=50,l=20))
    )
    figures.append(fig)



    df['nnv']= df.nosfx_bin.apply(lambda x: x.right)
    df['okv'] = df.ok_bin.apply(lambda x: x.right)
    df.ok_bin = df.ok_bin.astype(str).str.replace('\(-0.001', '[0').apply(lambda x: f'${x}$')
    df.nosfx_bin= df.nosfx_bin.astype(str).str.replace('\(-0.001', '[0').apply(lambda x: f'${x}$')
    df = df[~df['count'].isna()]
    df['count'] = df['count'].astype(int)
    df = df.sort_values(['nnv', 'okv', 'count'], ascending=False)

    df = df.rename(columns={'nosfx_bin': 'nn', 'ok_bin': 'ok'}).set_index(['nn', 'ok', 'count'])

    df.query_tot = df.query_tot.str.split(',')
    df = df.explode(column='query_tot')
    df = df[df.query_tot.str.len() > 0]

    df_split = df.query_tot.str.split(':', expand=True)

    df['tot'] = df_split[0]
    df['query'] = df_split[1]

    df_latex = df.drop(columns='query_tot')

    print(df_latex)

    print(df_latex[df_latex.nnv <= 0.5][['tot', 'query']].to_latex(escape=False))
    print(df_latex[df_latex.nnv > 0.5][['tot', 'query']].to_latex(escape=False))

    table = dash_table.DataTable(
        id='datatable-query',
        columns=[
            {'name': i, 'id': i} for i in df.columns
        ],
        data=df.to_dict('records'),
        sort_action='native',
        sort_mode='multi',
        page_action='none',
    )

    return [dcc.Graph(figure=fig) for fig in figures] + [table]

def get_grouped_table(pcap_row):
    pcapname = pcap_row['name'] + '.pcap.csv'
    df = fetch_df_grouped(pcap_row['id']).copy()
    df.set_index('query', drop=False, inplace=True)   
    df.drop(columns=['pcap_id', 'basedomain', 'time_us', 'intervals_mean', 'intervals_std'], inplace=True)
    df['id'] = df['query']
    return [
        html.H3(pcapname),
        dash_table.DataTable(
            id='datatable-query',
            columns=[
                {'name': i, 'id': i, 'deletable': True} for i in df.columns
            ],
            data=df.to_dict('records'),
            editable=True,
            filter_action='native',
            sort_action='native',
            sort_mode='multi',
            page_action='none',
            style_table={'height': '300px', 'overflowY': 'auto'}
        )
    ]

def calc_llr(pcap_row):
    df = fetch_df_grouped(pcap_row['id']).copy()

    s_nosfx = df.nosfx

    num = s_nosfx.replace([0, 1], [0.000_000_000_1, 1-0.000_000_000_1])
    den = np.ones(len(num)) - num
    df['logit'] = np.log(num/den)

    return html.Div(df.logit.sum())

external_stylesheets = ['./style.css']
app = dash.Dash(__name__, external_stylesheets=external_stylesheets)
app.title = 'Dash Single PCAP'
app.layout = html.Div([
    dash_table.DataTable(
        id='datatable-pcap',
        columns=[
            {'name': i, 'id': i, 'deletable': True} for i in df_pcaps.columns if i != 'id'
        ],
        style_table={'height': '150px', 'overflowY': 'auto'},
        # style_cell={
        #     'overflow': 'hidden',
        #     'textOverflow': 'ellipsis',
        #     'maxWidth': 0
        # },
        tooltip_data=[
            {
                column: {'value': str(value), 'type': 'markdown'}
                for column, value in row.items()
            } for row in df_pcaps.to_dict('records')
        ],
        data=df_pcaps.to_dict('records'),
        editable=True,
        filter_action="native",
        sort_action="native",
        sort_mode='multi',
        page_action='none',
    ),
    html.Div(
        treemap_unique(get_row(default_pcap_id)),
        id='graph-container'
    ),
    # html.Div(
    #     get_grouped_table(get_row(default_pcap_id)),
    #     id='div-datatable-query',
    #     style={'height': '300px', 'overflowY': 'auto'}
    # ),
    # html.Div(
    #     calc_llr(get_row(default_pcap_id)),
    #     id='div-llr',
    #     style={'height': '300px', 'overflowY': 'auto'}
    # )
])


@app.callback(
    Output('div-datatable-query', 'children'),
    Input('datatable-pcap', 'active_cell'))
def update_table(active_cell):
    pcap_id = default_pcap_id if active_cell is None else active_cell['row_id']
    return get_grouped_table(get_row(pcap_id))

@app.callback(
    Output('graph-container', 'children'),
    Input('datatable-pcap', 'active_cell'))
def update_graph(active_cell):
    pcap_id = default_pcap_id if active_cell is None else active_cell['row_id']
    return treemap_unique(get_row(pcap_id))

@app.callback(
    Output('div-llr', 'children'),
    Input('datatable-pcap', 'active_cell'))
def update_llr(active_cell):
    pcap_id = default_pcap_id if active_cell is None else active_cell['row_id']
    return calc_llr(get_row(pcap_id))

if __name__ == '__main__':
    app.run_server(debug=False, port=8051)
