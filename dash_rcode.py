import math
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from dash.dependencies import Input, Output
from plotly.subplots import make_subplots
import sqlite3
import pandas as pd
import plotly.express as px
import numpy as np
import plotly.graph_objects as go
import os


db_path = '/media/princio/ssd512/stratosphere/db_3.sqlite3'
dirs = {
    'malware': '/media/princio/ssd512/stratosphere/pcap/csv/malware/',
    'normal': '/media/princio/ssd512/stratosphere/pcap/csv/normal/'
}
pcap_dict = {'normal': {}, 'botnet': {}}
pcap_names = {'normal': {}, 'botnet': {}}


def get_type(pcapname):
    bot_path = os.path.join(dirs['malware'], pcapname)
    nor_path = os.path.join(dirs['normal'], pcapname)
    if os.path.exists(bot_path):
        type_ = 'botnet'
        df_path = bot_path
    elif os.path.exists(nor_path):
        type_ = 'normal'
        df_path = nor_path
    else:
        raise Exception(pcapname + ' does not exists.')
    return type_, df_path


def get_df(pcapname, reload=False):
    if reload:
        type_, df_path = get_type(pcapname)
        pcap_dict[type_][pcapname] = pd.read_csv(
            df_path, usecols=list(range(0, 12)))
        return pcap_dict[type_][pcapname]

    if pcapname in pcap_dict['botnet']:
        return pcap_dict['botnet'][pcapname]
    if pcapname in pcap_dict['normal']:
        return pcap_dict['normal'][pcapname]

    type_, df_path = get_type(pcapname)
    pcap_dict[type_][pcapname] = pd.read_csv(
        df_path, usecols=[2, 3, 6, 8, 9, 10, 11])
    return pcap_dict[type_][pcapname].copy()


db = sqlite3.connect(db_path)
df_pcap = pd.read_sql('SELECT * from pcap', db)
df_app = pd.read_sql('SELECT * from pcap_queries_3', db)
db.close()


df_pcap = df_pcap.drop(columns=['qry/h'])
df_pcap.set_index('id', inplace=True, drop=False)
df_pcap['name2'] = df_pcap.type + '_' + df_pcap.id.astype(str)

df_app.set_index('query', inplace=True, drop=False)


df_pcap['99'] = 0
df_app_99 = df_app[df_app['nosfx'] > 0.99 ]
for idx, app in df_app_99.iterrows():
    pcap_id = app['pcap_id']
    df_pcap.at[pcap_id, '99'] = df_pcap.at[pcap_id, '99'] + 1

print(df_pcap)


def draw_LLR():
    figures = []

    fig = make_subplots(
        rows=1, cols=2,
        column_titles=['botnet', 'normal'],
        specs=[[{'type':'domain'} for j in range(2)] for i in range(1)]
    )


    df = df_pcap.groupby('type').sum().drop(columns=['id', 'unique_norm', 'oth'])[['no', 'ok', 'nx']]

    df_botnet = df.loc['botnet']
    fig.add_trace(go.Pie(
        labels=df_botnet.index,
        values=df_botnet.values
    ),
    row=1, col=1)

    df_normal = df.loc['normal']
    fig.add_trace(go.Pie(
        labels=df_normal.index,
        values=df_normal.values
    ),
    row=1, col=2)

    fig.update_layout(width=700)

    figures.append(fig)



    fig = make_subplots(
        rows=2, cols=1,
        shared_xaxes=True,
        vertical_spacing=0.02,
        specs=[[{'type':'xy'} for j in range(1)] for i in range(2)]
    )
    df = df_pcap#[(df_pcap.unique > 2000) & (df_pcap.unique < 6000)]
    df = df_pcap[df_pcap.unique > 1000].sort_values(by='tot')
    df['unique/tot'] = df.unique / df.tot

    fig.add_trace(
        go.Bar(x=df.name2, y=df.tot, marker_color=df.type.apply(lambda x: dict(botnet='blue', normal='red')[x])),
        row=1, col=1
    )

    # fig.add_trace(
    #     go.Bar( x=df.name2, y=df['unique'], marker_color=df.type.apply(lambda x: dict(botnet='blue', normal='red')[x])),
    #     row=2, col=1
    # )
    fig.add_trace(
        go.Bar( x=df.name2, y=df['unique/tot'], marker_color=df.type.apply(lambda x: dict(botnet='blue', normal='red')[x])),
        row=2, col=1
    )

    fig.update_yaxes(title_text="total", type="log", row=1, col=1)
    # fig.update_yaxes(title_text="unique", type="log", row=2, col=1)
    fig.update_yaxes(title_text="unique/tot", row=2, col=1)

    fig.update_layout(height=700, showlegend=False, margin=dict(t=0, r=0, l=0, b=0))
    figures.append(fig)




    print(df.name2.drop_duplicates())



    fig = make_subplots(
        rows=2, cols=1,
        shared_xaxes=True,
        vertical_spacing=0.02,
        specs=[[{'type':'xy'} for j in range(1)] for i in range(2)]
    )
    df = df_pcap#[(df_pcap.unique > 2000) & (df_pcap.unique < 6000)]
    df = df_pcap[df_pcap.unique > 1000].sort_values(by='tot').copy()


    fig.add_trace(
        go.Bar(x=df.name2, y=df.unique, marker_color=df.type.apply(lambda x: dict(botnet='blue', normal='red')[x])),
        row=1, col=1
    )

    fig.add_trace(
        go.Bar( x=df.name2, y=df['99']/df.unique, marker_color=df.type.apply(lambda x: dict(botnet='blue', normal='red')[x])),
        row=2, col=1
    )

    fig.update_yaxes(title_text="unique", type="log", row=1, col=1)
    fig.update_yaxes(title_text="unique > 99/unique", row=2, col=1)

    fig.update_layout(height=700, showlegend=False, margin=dict(t=0, r=0, l=0, b=0))
    figures.append(fig)


    return [dcc.Graph(figure=fig) for fig in figures]



app = dash.Dash(__name__)

app.layout = html.Div([
    html.Div(
        draw_LLR(),
        id='LLR-container'
    ),
    # html.Div(
    #     draw_pcap_nosfx_distribution(),
    #     id='pcap-nosfx-distribution-container'
    # ),
    # html.Div(
    #     draw_pcap_scatter(),
    #     id='pcap-container'
    # ),
])

if __name__ == '__main__':
    app.run_server(debug=False)
