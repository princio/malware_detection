
# check se è una request
# check se è stata già visitata
# 5 secondi di limite


import math
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from dash.dependencies import Input, Output
from plotly.subplots import make_subplots
import dash_bootstrap_components as dbc

import psycopg2
import pandas as pd
import plotly.express as px
import numpy as np
import plotly.graph_objects as go
import os
from sklearn.metrics import classification_report, confusion_matrix
import plotly.figure_factory as ff


db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")


df_pcap = pd.read_sql(
    'SELECT * FROM pcap ORDER BY qr ASC',
    db,
)



for _, pcap in df_pcap.iterrows():

    df = pd.read_sql(
        """SELECT
            transaction_id, qcode, server, COUNT(*) as bibo
        FROM message_compact
        WHERE pcap_id=%d
        GROUP BY transaction_id, qcode, server
        ORDER BY bibo DESC""" % pcap.id,
        db,
    )
    df = pd.read_sql(
        """SELECT
        transaction_id,
            COUNT(transaction_id) as bibo
        FROM message_compact
        WHERE pcap_id=%d
        GROUP BY transaction_id
        ORDER BY bibo DESC""" % pcap.id,
        db,
    )

    df = pd.read_sql(
        """SELECT *
        FROM message_compact
        WHERE pcap_id=%d
        ORDER BY time_ DESC""" % pcap.id,
        db,
    )

    df['visited'] = False

    df_q = df[df.is_response==False]

    for _, message in df.iterrows():

        # df.at[_, 'visited'] = True

        df_lookup = df_q.iloc[:_]
        # df_lookup = df_lookup[~df_lookup.visited]


        message_lookedup = df_lookup[df_lookup.transaction_id == message['transaction_id']]
        if message_lookedup.shape[0] == 0:
            continue
        print(pd.concat([
            message,
            message_lookedup.iloc[0]
        ], axis=1).T)

        
        if _ > 20:
            break
    
    break


