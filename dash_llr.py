import math
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from dash.dependencies import Input, Output
from plotly.subplots import make_subplots
import sqlite3
import pandas as pd
import plotly.express as px
import numpy as np
import plotly.graph_objects as go
import os


db_path = '/media/princio/ssd512/stratosphere/db_3.sqlite3'
dirs = {
    'malware': '/media/princio/ssd512/stratosphere/pcap/csv/malware/',
    'normal': '/media/princio/ssd512/stratosphere/pcap/csv/normal/'
}
pcap_dict = {'normal': {}, 'botnet': {}}
pcap_names = {'normal': {}, 'botnet': {}}


def get_type(pcapname):
    bot_path = os.path.join(dirs['malware'], pcapname)
    nor_path = os.path.join(dirs['normal'], pcapname)
    if os.path.exists(bot_path):
        type_ = 'botnet'
        df_path = bot_path
    elif os.path.exists(nor_path):
        type_ = 'normal'
        df_path = nor_path
    else:
        raise Exception(pcapname + ' does not exists.')
    return type_, df_path


def get_df(pcapname, reload=False):
    if reload:
        type_, df_path = get_type(pcapname)
        pcap_dict[type_][pcapname] = pd.read_csv(
            df_path, usecols=list(range(0, 12)))
        return pcap_dict[type_][pcapname]

    if pcapname in pcap_dict['botnet']:
        return pcap_dict['botnet'][pcapname]
    if pcapname in pcap_dict['normal']:
        return pcap_dict['normal'][pcapname]

    type_, df_path = get_type(pcapname)
    pcap_dict[type_][pcapname] = pd.read_csv(
        df_path, usecols=[2, 3, 6, 8, 9, 10, 11])
    return pcap_dict[type_][pcapname].copy()


db = sqlite3.connect(db_path)
df_pcap = pd.read_sql('SELECT * from pcap', db)
df_app = pd.read_sql('SELECT * from pcap_queries_3', db)
db.close()


df_pcap = df_pcap.drop(columns=['s_id', 's_win', 'qry/h'])
df_pcap.set_index('id', inplace=True, drop=False)

df_app.set_index('query', inplace=True, drop=False)

df_pcap = df_pcap[(df_pcap['unique_norm'] > 0.01)
                  & (df_pcap['tot'] > 500)].copy()


def f_llr(s_nosfx):
    num = s_nosfx.replace([0, 1], [0.000_000_000_1, 1-0.000_000_000_1])
    den = np.ones(len(num)) - num
    llr = np.log(num/den)
    return num/den, llr


thresholds = [0, 0.1, 0.25, 0.5, 0.75, 0.9, 0.999]
for th in thresholds:
    nd1, llr = f_llr(df_app.nosfx.apply(lambda x: 0.5 if x <= th else x))
    df_app['llr_%0.1f' % th] = llr
    print('llr_%0.1f' % th)
    l = df_app.nosfx.apply(lambda x: 0.5 if x <= th else x).sort_values()
    print(l[l == 0.5].shape[0])

# print(df_app.arg.sort_values())
# print(df_app.llr.sort_values())

for th in thresholds:
    df_pcap['llr_%0.1f' % th] = 0
df_pcap['nosfx >.5'] = 0

bins = np.concatenate([
        np.arange(start=0, stop=0.1, step=0.02),
        [0.1, 0.4, 0.6, 0.9],
        np.arange(start=0.92, stop=1.01, step=0.02)
    ],
    axis=None
)

bins = [0, 0.02, 0.9, 0.97, 1]

pcap_quartiles = {}
for pcap_id, pcap in df_pcap.iterrows():
    df_app_pcap = df_app[df_app['pcap_id'] == pcap_id].copy()
    df_pcap.at[pcap_id,
               'nosfx >.5'] = df_app_pcap[df_app_pcap['nosfx'] > 0.5].shape[0]
    for th in thresholds:
        llr = df_app_pcap['llr_%0.1f' % th].sum()
        df_pcap.at[pcap_id, 'llr_%0.1f' % th] = llr
    pcap_quartiles[(pcap['name'], pcap['type'])] = pd.cut(df_app_pcap.nosfx, bins, include_lowest=True).value_counts(normalize=True, sort=False)

df_pcap_quartiles = pd.DataFrame.from_dict(pcap_quartiles, orient='index')

df_pcap_quartiles.columns = [ str(c) for c in df_pcap_quartiles.columns.values ]

def draw_pcap_scatter():
    figures = []

    df = df_pcap.copy()

    for th in thresholds:
        fig = px.scatter(df,
                         x='unique',
                         y='llr_%0.1f' % th,
                         color='type', opacity=0.8,
                         # symbol='tot',
                         size_max=10,
                         hover_data=['ok', 'tot', 'no', 'nx']
                         )
        fig.update_layout(
            height=500,
            xaxis_nticks=36)
        figures.append(fig)

    return [dcc.Graph(figure=fig) for fig in figures]


def draw_pcap_nosfx_distribution():
    figures = []

    df = df_pcap_quartiles.copy().stack().reset_index().rename(columns=dict(level_0='name', level_1='type', level_2='bin'))

    print(df)
    fig = px.bar(df[df.type == 'botnet'],
                        x='name',
                        y=0,
                        color='bin'
                        )
    fig.update_layout(
        height=1000,
        xaxis_nticks=36)
    figures.append(fig)
    fig = px.bar(df[df.type == 'normal'],
                        x='name',
                        y=0,
                        color='bin'
                        )
    fig.update_layout(
        height=1000,
        xaxis_nticks=36)
    figures.append(fig)

    return [dcc.Graph(figure=fig) for fig in figures]


app = dash.Dash(__name__)

app.layout = html.Div([
    html.Div(
        draw_pcap_nosfx_distribution(),
        id='pcap-nosfx-distribution-container'
    ),
    html.Div(
        draw_pcap_scatter(),
        id='pcap-container'
    ),
])

if __name__ == '__main__':
    app.run_server(debug=False)
