import math
import dash
import dash_core_components as dcc
import dash_html_components as html
from dash_html_components.Div import Div
import dash_table
from dash.dependencies import Input, Output
from plotly.subplots import make_subplots
import dash_bootstrap_components as dbc

import psycopg2
import pandas as pd
import plotly.express as px
import numpy as np
import plotly.graph_objects as go
import os
from sklearn.metrics import classification_report, confusion_matrix
import plotly.figure_factory as ff


db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")

# pcap_list = [
#     ["27_2017_04_30-normal.pcap", 858],
#     ["32_2017-05-02_normal.pcap", 859],
#     ["29_2017-05-01_normal.pcap", 872],
#     ["30_2017-05-01_normal.pcap", 873],
#     ["31_2017-05-01_normal.pcap", 874],
#     ["10_2013-08-20_capture-win10.pcap", 80],
#     ["303-1_2017-08-12_capture-win2.pcap", 106],
#     ["5_2013-08-20_capture-win14.pcap", 845],
#     ["7_2013-08-20_capture-win1.pcap", 846],
#     ["10_2013-08-20_capture-win9.pcap", 847],
#     ["25-2_2014-01-25_capture_win3.pcap", 848],
#     ["6_2013-08-20_capture-win6.pcap", 849],
#     ["6_2013-08-20_capture-win11.pcap", 850],
#     ["10_2013-08-20_capture-win7.original.pcap", 851],
#     ["10_2013-08-20_capture-win7.pcap", 852],
#     ["110-6_2015-06-07_capture-win9.pcap", 853],
#     ["69_2014-04-07_capture-win17.pcap", 854],
#     ["71_2014-04-07_capture-win19.fixed.pcap", 855],
#     ["25-6_2014-12-20_capture-win3.pcap", 856],
#     ["170-1_capture-win6.pcap", 857]
# ]


df_th = (
    pd.read_sql(
        "SELECT window_size, th FROM threshold",
        db,
    )
    .set_index("window_size")
    .T
)


def calc_windows(window=1000, th=None):

    if not th:
        th = df_th[window].values[0]

    df = pd.read_sql(
        'SELECT malware_id, infected, q, W2.* FROM "window2" as W2 JOIN pcap on W2.pcap_id=pcap.id WHERE W2.size=%d ORDER BY W2.pcap_id, W2.window'
        % window,
        db,
    )

    # df["win_num"] = np.ceil(df.q / window).astype(int)
    df["win_gt"] = (df.llr > th).apply(lambda x: 1 if x else 0)
    df["win_le"] = (df.llr <= th).apply(lambda x: 1 if x else 0)

    dfg = (
        df[["pcap_id", "malware_id", "infected", "window", "win_gt", "win_le"]]
        .groupby(["pcap_id", "malware_id", "infected"])
        .aggregate(
            {"window": "count", "win_gt": ["first", "sum"], "win_le": ["first", "sum"]}
        )
    ).reset_index()

    dfg["aligned"] = (
        dfg[("win_gt", "sum")] - dfg[("win_le", "sum")]
    ) * dfg.infected.apply(lambda x: -1 if x else 1)

    tmp = dfg[("window", "count")].copy()
    dfg_norm = dfg.div(dfg[("window", "count")], axis=0).round(4)
    dfg_norm[("window", "count")] = tmp

    dfg_mw = dfg.groupby("malware_id").sum()
    dfg_mw = dfg_mw.append(dfg_mw.sum(axis=0).rename("tot"))
    tmp = dfg_mw[("window", "count")].copy()

    dfg_mw_norm = dfg_mw.div(dfg_mw[("window", "count")], axis=0).round(4)
    dfg_mw_norm[("window", "count")] = tmp

    y_true = df.infected.astype(bool)
    y_pred = df.llr > th

    report = classification_report(
        y_true, y_pred, target_names=["not infected", "infected"]
    )

    cmatrix2 = confusion_matrix(y_true, y_pred, normalize="true")
    cmatrix2 = np.round(cmatrix2, 2)
    cmatrix = np.copy(np.round(cmatrix2, 2))

    #       0   1          0   1
    #   1 [ TP, FN ]   1 [ TN, FN ]
    #   0 [ FP, TN ]   0 [ FP, TP ]
    cmatrix[1, 0] = cmatrix2[1, 1]  # TP=
    cmatrix[0, 0] = cmatrix2[0, 1]  # FP=
    cmatrix[0, 1] = cmatrix2[0, 0]  # TN=
    cmatrix[1, 1] = cmatrix2[1, 0]  # FN=

    first_window_below_th = df[df.llr > th].groupby(["infected", "pcap_id"]).first()

    x = ["infected", "normal"]
    y = ["normal", "infected"]
    z = cmatrix
    z_text = cmatrix
    fig = ff.create_annotated_heatmap(
        z, x=x, y=y, annotation_text=z_text, colorscale="Blues"
    )
    fig.update_layout(
        height=300, width=600, font=dict(size=24), margin=dict(t=20, l=20, b=20, r=20)
    )
    fig.update_xaxes(title="predict", title_font={"size": 20})
    fig.update_yaxes(title="true", title_font={"size": 20}, tickfont={"size": 20})

    dfg.columns = dfg.columns.map("|".join).str.strip("|")

    table = dash_table.DataTable(
        id="pcap-table",
        columns=[{"id": i, "name": i} for i in dfg.columns],
        data=dfg.to_dict("records"),
    )

    return [
        html.Div([table]),
        html.Div(
            [
                html.H2("Window: %d" % window),
                html.H2("True: Pcap-label"),
                html.H2("Predict: LLR"),
            ],
            # style={"width": "450px", "height": "100%", "margin-top": "50px"},
        ),
        html.Div(
            [
                html.Div(dcc.Graph(figure=fig)),
                html.Pre(
                    report, style={"font-family": "monospace", "font-size": "20px"}
                ),
            ],
            style={
                "display": "flex",
                "flex-direction": "column",
                "align-self": "center",
                "border": "1px solid black",
                "padding": "20px",
            },
        ),
        dcc.Markdown(first_window_below_th[["window", "size", "llr"]].to_markdown()),
        dcc.Markdown(df["pcap_id"].drop_duplicates().to_markdown()),
    ]


app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])


def gen_div(app, id=1):

    window_form = dbc.Row(
        [
            dbc.Col(dbc.Label("Window:"), width=2),
            dbc.Col(
                dcc.Dropdown(
                    id="window-dropdown-%d" % id,
                    options=[
                        {"label": str(w), "value": w} for w in [100, 500, 1000, 2000]
                    ],
                    value=1000,
                ),
                width=10,
            ),
        ]
    )

    th_form = dbc.Row(
        [
            dbc.Col(
                dbc.FormGroup(
                    [
                        dbc.Label("Threshold:", html_for="th-select-%d" % id, width=2),
                        dbc.Col(
                            dbc.Input(id="th-select-%d" % id, type="number", value=0),
                            width=10,
                        ),
                    ],
                    row=True,
                ),
                width=6,
            ),
        ]
    )

    dbc_button = dbc.Button(
        "update",
        id="button-submit-%d" % id,
        style={"font-family": "monospace", "font-size": "24px"},
    )

    bo = dbc.Row([dbc.Col(dbc_button, width=2)])

    form = dbc.FormGroup(
        [
            window_form,
            th_form,
            bo,
            html.Div(id="result-container-%d" % id),
        ],
        style={"padding": "20px"},
    )

    def fun_submit(n_clicks, vwindow, vth):
        return calc_windows(window=vwindow, th=vth)

    app.callback(
        Output("result-container-%d" % id, "children"),
        [dash.dependencies.Input("button-submit-%d" % id, "n_clicks")],
        [
            dash.dependencies.State("window-dropdown-%d" % id, "value"),
            dash.dependencies.State("th-select-%d" % id, "value"),
        ],
    )(fun_submit)

    return form


app.layout = html.Div(
    [
        html.Div(gen_div(app, 1), id="container-1", style={"width": "50%"}),
        html.Div(gen_div(app, 2), id="container-2", style={"width": "50%"}),
    ],
    style={"display": "flex", "flex-direction": "row"},
)


if __name__ == "__main__":
    app.run_server(debug=False, port=8051)
