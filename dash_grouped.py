import math
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from dash.dependencies import Input, Output
from plotly.subplots import make_subplots
import sqlite3
import pandas as pd
import plotly.express as px
import numpy as np
import plotly.graph_objects as go
import os


db_path = '/media/princio/ssd512/stratosphere/db_3.sqlite3'
dirs = {
    'malware': '/media/princio/ssd512/stratosphere/pcap/csv/malware/',
    'normal': '/media/princio/ssd512/stratosphere/pcap/csv/normal/'
}
pcap_dict = {'normal':{}, 'botnet':{}}
pcap_names = {'normal':{}, 'botnet':{}}

def get_type(pcapname):
    bot_path = os.path.join(dirs['malware'], pcapname)
    nor_path = os.path.join(dirs['normal'], pcapname)
    if os.path.exists(bot_path):
        type_='botnet'
        df_path = bot_path
    elif os.path.exists(nor_path):
        type_='normal'
        df_path = nor_path
    else:
        raise Exception(pcapname + ' does not exists.')
    return type_, df_path

def get_df(pcapname, reload=False):
    if reload:
        type_, df_path = get_type(pcapname)
        pcap_dict[type_][pcapname] = pd.read_csv(df_path, usecols=list(range(0,12)))
        return pcap_dict[type_][pcapname]
    
    if pcapname in pcap_dict['botnet']:
        return pcap_dict['botnet'][pcapname]
    if pcapname in pcap_dict['normal']:
        return pcap_dict['normal'][pcapname]
    
    type_, df_path = get_type(pcapname)
    pcap_dict[type_][pcapname] = pd.read_csv(df_path, usecols=[2, 3, 6, 8, 9, 10, 11])
    return pcap_dict[type_][pcapname].copy()



db = sqlite3.connect(db_path)
df_pcaps = pd.read_sql('SELECT * from pcap', db)
db.close()
df_pcaps = df_pcaps.drop(columns=['s_id', 's_win'])
df_pcaps.set_index('id', inplace=True, drop=False)
df_pcaps['uniques/tot'] = df_pcaps['uniques/tot'].mul(100).round(2)
df_pcaps.drop(columns=['qry/h'], inplace=True)
df_pcaps.rename(columns={
    'uniques': 'uniq',
    'uniques/tot': '%uniq',
    'no-response': 'no res',
    'response-ok': 'OK',
    'response-error': 'ERR',
    'response-err': 'no-such-name',
    'legit_list': 'top10m'
}, inplace=True)
app = dash.Dash(__name__)


def draw_timeline(pcap_id, nn=False):
    pcap_name = df_pcaps[df_pcaps.id == pcap_id].iloc[0]['name']
    df = get_df(pcap_name).rename(columns={'frame.time_epoch_req': 'req_time'})
    df['req_time'] = pd.DatetimeIndex(df['req_time']*1_000_000_000)
    n = df.shape[0]
    y = math.ceil(math.sqrt((9/16) * n))
    x = math.ceil(n / y)

    df2 = df[['req_time']].copy()

    req_time = np.repeat([ df['req_time'].iloc[i * x] for i in range(y) ], x)
    df2['req_time'] = req_time[0:n]
    df2['x'] = np.tile(np.arange(0,x), y)[0:n]
    rows = [ df['req_time'].iloc[i * x] for i in range(y) ]
    # rows = pd.Series(rows).strftime('%Y/%m/%d %H:%M')
    rows = pd.Series(rows).dt.strftime('%Y/%m/%d %H:%M:%S')
    cols = np.arange(0,x)

    nans = np.empty(x*y - df2.shape[0])
    nans[:] = np.nan


    text = 'query: ' +  df['dns.qry.name'] + '<br>rcode: ' + df['dns.flags.rcode'].fillna('no').astype(str)
    queries = text.values
    text = np.reshape(np.concatenate((text, nans)), (y, x))

    if not nn:
        rcode = df['dns.flags.rcode'].values
        rcode = np.where(rcode==3, 0.25, rcode)
        rcode = np.where(rcode==2, 4, rcode)
        rcode = np.where(rcode>3, 0.5, rcode)
        rcode = np.where(np.isnan(rcode), 1, rcode)
        df2['rcode'] = rcode
        df_value = df2.pivot(index='req_time', values='rcode', columns='x')
        rcode = np.reshape(np.concatenate((rcode, nans)), (y, x))

        print('-----------rcode----------', np.shape(df_value.columns.values))
        print('-----------rcode----------', np.shape(rcode), np.shape(cols), np.shape(rows))
        print(rcode)
        fig = go.Figure(data=go.Heatmap(
                z=rcode,
                x=cols, #df_value.columns.values,
                y=rows, #df_value.index.strftime('%Y/%m/%d %H:%M'),
                text=text,
                colorscale=[
                    [0, 'green'], [0.25, 'green'],
                    [0.25, 'orange'], [0.5, 'orange'],
                    [0.5, 'red'], [0.75, 'red'],
                    [0.75, 'lightgrey'], [1, 'lightgrey'],
                ],
                colorbar=dict(tick0=0, dtick=1,
                                thickness=25, 
                                tickvals=[0.125, 0.375, 0.625, 0.875], 
                                ticktext=['ok', 'nx', 'err', 'no'])))
    else:
        nosfx = np.reshape(np.concatenate((df['nosfx_0.1'].values, nans)), (y, x))
        # df_value = df2.pivot(index='req_time', values='nosfx', columns='x')
        print(nosfx)
        fig = go.Figure(data=go.Heatmap(
                z=nosfx, #, df_value.values,
                x=cols, #df_value.columns.values,
                y=rows, #df_value.index.strftime('%Y/%m/%d %H:%M'),
                zmax=1,
                zmin=0,
                text=text #df_query.values
            ))

    fig.update_layout(title='GitHub commits per day',
                        yaxis_nticks=20,
                        xaxis_nticks=36)
    return fig

def draw_timeline2(pcap_id):
    pcap_name = df_pcaps[df_pcaps.id == pcap_id].iloc[0]['name']
    df = get_df(pcap_name).rename(columns={'frame.time_epoch_req': 'req_time'})
    df['req_time'] = pd.DatetimeIndex(df['req_time']*1_000_000_000)
    df.index = df['req_time'].copy()
    nbar = 50
    resampling_seconds = (df.index[-1] - df.index[0]).total_seconds() // nbar
    df['count'] = 1
    df['NO'] = df['dns.flags.rcode'].isna().astype(int)
    df['OK'] = df['dns.flags.rcode'].apply(lambda x: x == 0).astype(int)
    df['NX'] = df['dns.flags.rcode'].apply(lambda x: x == 3).astype(int)
    df['OTH'] = df['dns.flags.rcode'].apply(lambda x: x > 0 and x != 3).astype(int)
    df.drop(columns='dns.flags.rcode', inplace=True)
    df = df.resample(f'{resampling_seconds}T').sum()
    df['req_time'] = df.index
    df = df.melt(id_vars=['req_time'], value_vars=['OK', 'NO', 'NX', 'OTH'])#.sort_values(by='req_time')
    return px.bar(df,
                    x='req_time',
                    y='value',
                    color='variable',
                    opacity=0.5)


app.layout = html.Div([
        html.Div([
            dash_table.DataTable(
                id='left-datatable-row-ids',
                columns=[
                    {'name': i, 'id': i, 'deletable': True} for i in df_pcaps.columns if i != 'id'
                ],
                data=df_pcaps.to_dict('records'),
                editable=True,
                filter_action="native",
                sort_action="native",
                sort_mode='multi',
                row_selectable='multi',
                row_deletable=True,
                selected_rows=[],
                page_action='none',
                style_table={'height': '300px', 'overflowY': 'auto', 'overflowX': 'auto'},
                style_cell={
                    'overflow': 'hidden',
                    'textOverflow': 'ellipsis',
                    'maxWidth': 0
                }
            ),
            html.Div(id='left-datatable-row-ids-container')
        ],
        style={'width': '50%'}),
        html.Div([
            dash_table.DataTable(
                id='right-datatable-row-ids',
                columns=[
                    {'name': i, 'id': i, 'deletable': True} for i in df_pcaps.columns if i != 'id'
                ],
                data=df_pcaps.to_dict('records'),
                editable=True,
                filter_action="native",
                sort_action="native",
                sort_mode='multi',
                row_selectable='multi',
                row_deletable=True,
                selected_rows=[],
                page_action='none',
                style_table={'height': '300px', 'overflowY': 'auto', 'overflowX': 'auto'},
                style_cell={
                    'overflow': 'hidden',
                    'textOverflow': 'ellipsis',
                    'maxWidth': 0
                }
            ),
            html.Div(id='right-datatable-row-ids-container')
        ],
        style={'width': '50%'})
    ],
    style={'display': 'flex', 'flex-direction': 'row'}
)

template='seaborn'
color_scale='rainbow'

def update_graphs_logic(active_cell):
    if active_cell is None: return []
    pcap_id = active_cell['row_id']
    db = sqlite3.connect(db_path)
    df = pd.read_sql('select * from pcap_queries_2 WHERE pcap_id = %d' % pcap_id, db)
    db.close()

    df['responses'] = df['count'].sub(df['no-response'])
    count = 'count'
    req_tot = df[count].sum()
    res_tot = df['responses'].sum()

    for count in ['count', 'responses']:
        df['%s_log10' % count] = df[count].apply(np.log10).round(0)

    def size_(x):
        if x < 10: return 5
        if x < 100: return 6
        if x < 500: return 7
        if x < 1000: return 8
        return  9

    df['size'] = df['count'].apply(size_)

    df["top10m"] = df["legit_list"].apply(lambda x: 'legit' if x == 1 else 'unknown')

    df.rename(columns={'response-ok': 'ok', 'no-such-name': 'nx', 'no-response': 'no'}, inplace=True)

    df['bad'] = df['count'].sub(df['ok'])
    df['err'] = df['responses'].sub(df['ok'])

    figures = []
    figures.append(draw_timeline(pcap_id))
    figures.append(draw_timeline(pcap_id, True))
    return [ dcc.Graph(figure=figure) for figure in figures ]

    for col in ['ok', 'nx', 'no']:
        for count in ['count', 'responses']:
            if count == 'responses' and col == 'no': continue
            col2 = '%s / %s' % (col, count)
            df[col2] = df[col].div(df[count])
            fig = px.scatter(df,
                    template=template,
                    x=col2,
                    y="nosfx", 
                    color='%s_log10' % count, opacity=0.8,
                    symbol='top10m',
                    hover_data=['query', 'ok', count, 'no', 'nx', 'intervals_mean', 'intervals_std'])
            figures.append(fig)

    textfont = {'family': "Times", 'size': [18, 21, 20], 'color': ["IndianRed", "MediumPurple", "DarkOrange"]}
    for i, figure in enumerate(figures):
        figure.add_hline(y=0.5, line_width=3, line_dash="dash", line_color="black")
        figure.add_vline(x=0.5, line_width=3, line_dash="dash", line_color="black")
        figure.add_annotation(text="<b style='color: red'>True Malware</b>",  xref="x", yref="y", x=-0.1, y=1.1, showarrow=False)
        figure.add_annotation(text="<b style='color: blue'>False Malware</b>", xref="x", yref="y", x= 1.1, y=1.1, showarrow=False)
        figure.add_annotation(text="<b style='color: black'>False Legit</b>", xref="x", yref="y", x=-0.1, y=-0.1, showarrow=False)
        figure.add_annotation(text="<b style='color: grey'>True Legit</b>",  xref="x", yref="y", x= 1.1, y=-0.1, showarrow=False)
        # figure.update_layout(
        #     #coloraxis_colorbar=dict(len=100, lenmode='pixels'),
        #     yaxis=dict(
        #         range=[-0.1, 1.1],
        #         dtick=0.2,
        #         tick0=0,
        #         nticks=5
        #     )
        # )

    df_map = df.copy().set_index('query').sort_values(by='count', ascending=False)
    df_rcode = df_map[['no', 'ok', 'nx', 'bad', 'err']].copy()
    df_rcode = df_rcode.div(df_map['count'], axis=0)
    df_rcode['count'] = df_map['count'].div(df_map['count'].sum())
    df_rcode['nosfx'] = df_map['nosfx']
    df_rcode = df_rcode.sort_values(by='nosfx')
    fig = go.Figure(data=go.Heatmap(
            z=df_rcode.T.to_numpy(),
            x=df_rcode.index.values,
            y=df_rcode.columns.values,
            colorscale='Viridis'))
    fig.update_layout(
        title='GitHub commits per day',
        yaxis_nticks=len(df_rcode.columns.values),
        xaxis_nticks=36)
    figures.append(fig)

    df['ok/bad'] = df['ok']/df['bad']
    fig = px.scatter(df,
            template=template,
            x='ok/bad',
            y='nosfx', 
            color='no / count', opacity=0.8,
            size='size', size_max=10,
            symbol='top10m',
            hover_data=['query', 'ok', count, 'no', 'nx', 'intervals_mean', 'intervals_std'])
    figures.append(fig)

    df['ok/err'] = df['ok']/df['err']
    fig = px.scatter(df,
            template=template,
            x='ok/err',
            y='nosfx', 
            color='no / count', opacity=0.8,
            size='size', size_max=10,
            symbol='top10m',
            hover_data=['query', 'ok', count, 'no', 'nx', 'intervals_mean', 'intervals_std'])
    figures.append(fig)


    df['ok/err'] = df['ok']/df['err']
    fig = px.scatter(df,
            template=template,
            x='ok/err',
            y='nosfx', 
            color='no / count', opacity=0.8,
            size='size', size_max=10,
            symbol='top10m',
            hover_data=['query', 'ok', count, 'no', 'nx', 'intervals_mean', 'intervals_std'])
    figures.append(fig)

    df_conf = dict(
        true_malware = df[(df['nosfx'] > 0.5) & (df['ok / %s' % count] < 0.5)].shape[0],
        false_malware = df[(df['nosfx'] > 0.5) & (df['ok / %s' % count] > 0.5)].shape[0],
        false_legit = df[(df['nosfx'] < 0.5) & (df['ok / %s' % count] < 0.5)].shape[0],
        true_legit = df[(df['nosfx'] < 0.5) & (df['ok / %s' % count] > 0.5)].shape[0]
    )
    colors = ['red', 'blue', 'black', 'lightgrey']
    fig = go.Figure(data=[go.Pie(labels=list(df_conf.keys()), values=list(df_conf.values()))])
    fig.update_traces(marker=dict(colors=colors, line=dict(color='#000000', width=2)))
    fig.update_layout(title='OK on %s' % count)
    figures.append(fig)

    df_conf = dict(
        true_malware = df[(df['nosfx'] > 0.5) & (df['nx / %s' % count] < 0.5)].shape[0],
        false_malware = df[(df['nosfx'] > 0.5) & (df['nx / %s' % count] > 0.5)].shape[0],
        false_legit = df[(df['nosfx'] < 0.5) & (df['nx / %s' % count] < 0.5)].shape[0],
        true_legit = df[(df['nosfx'] < 0.5) & (df['nx / %s' % count] > 0.5)].shape[0]
    )
    colors = ['red', 'blue', 'black', 'lightgrey']
    fig = go.Figure(data=[go.Pie(labels=list(df_conf.keys()), values=list(df_conf.values()))])
    fig.update_traces(marker=dict(colors=colors, line=dict(color='#000000', width=2)))
    fig.update_layout(title='nx on %s' % count)
    figures.append(fig)

    df_conf = dict(
        response_ok = df['ok'].sum(),
        no_such_name = df['nx'].sum(),
        no_response = df['no'].sum(),
        response_other_error = df['response-error'].sum()-df['nx'].sum(),
    )
    colors = ['red', 'blue', 'black', 'white']
    fig = go.Figure(data=[go.Pie(labels=list(df_conf.keys()), values=list(df_conf.values()))])
    fig.update_traces(marker=dict(colors=colors, line=dict(color='#000000', width=2)))
    figures.append(fig)

    return [ dcc.Graph(figure=figure) for figure in figures ]

@app.callback(
    Output('left-datatable-row-ids-container', 'children'),
    Input('left-datatable-row-ids', 'active_cell'))
def update_graphs(*args, **kwargs):
    return update_graphs_logic(*args, **kwargs)

@app.callback(
    Output('right-datatable-row-ids-container', 'children'),
    Input('right-datatable-row-ids', 'active_cell'))
def update_graphs(*args, **kwargs):
    return update_graphs_logic(*args, **kwargs)

print(px.data.medals_wide(indexed=True))

if __name__ == '__main__':
    app.run_server(debug=False)
