from typing import Dict
import csv
import random
import datetime
import hashlib
from Dataset import Dataset
from Model import Model
from Metrics import Metrics

class DatasetRepository:
    def __init__(self):
        pass

    @staticmethod
    def fetch_all(connection, type_ = 'malware', shuffled = False):
        cursor = connection.cursor()
        cursor.execute("""SELECT id, hash, name, type, inputs_number, date, supports, labels
	                        FROM public.datasets
                            WHERE type=%s AND shuffled=%s""",
                            (type_, shuffled))

        datasets = {}
        f = cursor.fetchall()
        for dataset in f:  
            datasets[dataset[0]] = Dataset.fill(dataset)
        return datasets

class ModelRepository:
    def __init__(self):
        pass

    @staticmethod
    def fetch_all(connection) -> Dict[str, Model]:
        cursor = connection.cursor()
        cursor.execute("""SELECT * FROM public.models""")

        models = {}
        f = cursor.fetchall()
        for model in f:  
            models[model[0]] = Model.fill(model)

        return models

class MetricsRepository:
    def __init__(self):
        pass

    @staticmethod
    def fetch(connection, model, dataset) -> Metrics:
        cursor = connection.cursor()
        cursor.execute("""SELECT metrics FROM public.metrics WHERE model_id=%s AND dataset_id=%s""", (model.id, dataset.id))
        return None if cursor.rowcount == 0 else Metrics.fromlist(model.classes, cursor.fetchone()[0])

    @staticmethod
    def exists(connection, model, dataset):
        cursor = connection.cursor()
        cursor.execute("""SELECT COUNT(*)
	                        FROM public.metrics WHERE model_id=%s AND dataset_id=%s;""", (model.id, dataset.id,))
        return cursor.fetchone()[0] > 0

    @staticmethod
    def save(connection, model, dataset, metrics):
        cursor = connection.cursor()
        cursor.execute("""INSERT INTO public.metrics(model_id, dataset_id, metrics) VALUES (%s, %s, %s);""",
                        (model.id, dataset.id, metrics.tolist()))
        connection.commit()