from typing import Dict
import csv
import random
import datetime
import hashlib
from Dataset import Dataset
from Model import Model
from Metrics import Metrics

class DatasetRepository:
    def __init__(self):
        pass
        
    @staticmethod
    def fetchall(connection, type_ = 'malware') -> Dict[str, Dataset]:
        cursor = connection.cursor()
        cursor.execute("""SELECT * FROM public.datasets WHERE type=%s""", (type_,))

        datasets = {}
        f = cursor.fetchall()
        for dataset in f:  
            datasets[dataset[0]] = Dataset.fill(dataset)
        return datasets

    @staticmethod
    def fetch_by_hash(connection, hash_):
        cursor = connection.cursor()
        cursor.execute("""SELECT * FROM public.datasets WHERE hash=%s""", (hash_,))
        if cursor.rowcount == 0:
            return None
        return Dataset.fill(cursor.fetchone())
        
    @staticmethod
    def fetchone(connection, id) -> Dataset:
        cursor = connection.cursor()
        cursor.execute("""SELECT * FROM public.datasets WHERE id = %s""", (id,))
        return Dataset.fill(cursor.fetchone()) if cursor.rowcount == 1 else None

    @staticmethod
    def fetchmany(connection, id) -> Dataset:
        cursor = connection.cursor()
        cursor.execute("""SELECT * FROM public.datasets WHERE id in %s""", (id,))
        if cursor.rowcount == 1:
            return Dataset.fill(cursor.fetchone())
        elif cursor.rowcount > 1:
            datasets = []
            for _i in range(cursor.rowcount):
                datasets.append(Dataset.fill(cursor.fetchone()))
            return datasets
        return None

class ModelRepository:
    def __init__(self):
        pass

    @staticmethod
    def fetchall(connection) -> Dict[str, Model]:
        cursor = connection.cursor()
        cursor.execute(Model.SELECT)

        models = []
        f = cursor.fetchall()
        for model in f:  
            models.append(Model.fill(connection, model))

        return models

    @staticmethod
    def fetchmany(connection, ids) -> Model:
        cursor = connection.cursor()
        cursor.execute(Model.SELECT + """WHERE id in %""",
                            (ids, ))

        models = []
        f = cursor.fetchall()
        for model in f:  
            models.append(Model.fill(connection, model))

        return models


class MetricsRepository:
    def __init__(self):
        pass

    @staticmethod
    def fetch(connection, model, dataset) -> Metrics:
        cursor = connection.cursor()
        cursor.execute("""SELECT metrics FROM public.metrics WHERE model_id=%s AND dataset_id=%s""", (model.id, dataset.id))
        return None if cursor.rowcount == 0 else Metrics.fromlist(model.classes, dataset.dga, cursor.fetchone()[0])

    @staticmethod
    def exists(connection, model, dataset):
        cursor = connection.cursor()
        cursor.execute("""SELECT COUNT(*)
	                        FROM public.metrics WHERE model_id=%s AND dataset_id=%s;""", (model.id, dataset.id,))
        return cursor.fetchone()[0] > 0

    @staticmethod
    def save(connection, model, dataset, metrics):
        cursor = connection.cursor()
        cursor.execute("""INSERT INTO public.metrics(model_id, dataset_id, metrics) VALUES (%s, %s, %s);""",
                        (model.id, dataset.id, metrics.tolist()))
        connection.commit()