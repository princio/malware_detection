import csv, os, numpy as np
from enum import Enum
from DomainLevel import DomainLevel, extractor
import pandas as pd

class ModelView:
    MAXLEN=66

    def __init__(self, path, dl):
        self.path = path
        self.dl = dl
        self.nn = None
        self.maxlen = None

    @property
    def name(self):
        return 'model_' + self.dl.name

    @staticmethod
    def load(dl: DomainLevel):
        if dl == DomainLevel.LOWERT:
            return ModelView('models/model_binary.lowert', dl)
        if dl == DomainLevel.BOTH:
            return ModelView('models/model_binary.both', dl)
        if dl == DomainLevel.LOWER:
            return ModelView('models/model_binary.lower', dl)
        if dl == DomainLevel.SIDE:
            return ModelView('models/model_binary.side.granatiero.DIFFERENT_ALPHABET', dl)

class InputView:
    def __init__(self, capture, dl):
        self.capture = capture
        self.dl = dl
        self.name = self.capture.name + '.' + self.dl.name
        self.X_str = None
        pass

    def generate(self):
        if self.X_str is None:
            self.X_str = self.capture.domain.apply(dl.translate).rename('input')

    @property
    def domain(self):
        return self.capture.domain

    @property
    def label(self):
        return self.capture.label

    @property
    def labeled(self):
        return self.capture.labeled

    @property
    def tld(self):
        return self.capture.dls


class OutputView:
    def __init__(self, inputv, model):
        self.inputv = inputv
        self.model = model
        self.name = self.inputv.name + '.' + self.model.name
        path = f'predictions/{self.inputv.capture.name}/dl_{self.inputv.dl.name}/{self.inputv.name}.{model.name}.csv'
        self._prediction = pd.read_csv(path, index_col=0)
        pass

    @property
    def df(self):
        return pd.concat([self.inputv.df, self.prediction], axis=1)

    @property
    def prediction(self):
        return self._prediction.rename(columns={'prediction': (self.inputv.dl.name, self.model.name)})

    @property
    def pclass(self, th = 0.5):
        """predicted class"""
        return self._prediction['prediction'].apply(lambda x: 'legit' if x < th else 'dga')


    @property
    def legit(self, th = 0.5):
        """predicted class"""
        return self._prediction['prediction'].apply(lambda x: 1 if x < th else 0)

    @property
    def dga(self, th = 0.5):
        """predicted class"""
        return self._prediction['prediction'].apply(lambda x: 1 if x >= th else 0)

    @property
    def whole(self):
        df = self.domain.reset_index()
        df.insert(1, 'dl', df['domain'].shape[0]*[self.inputv.dl.name])
        df.insert(2, 'model', df['domain'].shape[0]*[self.model.name])
        return df

    @property
    def domain(self):
        def d_rl(x):
            if 'label' in x:
                distance = abs((0 if x['label'] == 'legit' else 1) - x['prediction'])
                rightness = 1 if (x['label'] == 'legit' and x['prediction'] < 0.5) or (x['label'] == 'dga' and x['prediction'] >= 0.5) else 0
                return distance, rightness
            else:
                distance = abs(0.5 - x['prediction'])
                dganess = 0 if x['prediction'] < 0.5 else 1
                return distance, dganess

        if self.inputv.capture.labeled:
            df = pd.concat([self.inputv.domain, self.inputv.label, self._prediction], axis=1)
        else:
            df = pd.concat([self.inputv.domain, self._prediction], axis=1)

        df_d_rl = df.apply(d_rl, axis=1, result_type='expand')
        df_d_rl.columns = ['distance', 'rightness' if self.inputv.capture.labeled else 'dganess']
        
        df = pd.concat([self.inputv.domain, self._prediction, df_d_rl], axis=1)


        return df.set_index('domain')

    @property
    def input(self):
        def d_rl(x):
            if 'label' in x:
                distance = abs((0 if x['label'] == 'legit' else 1) - x['prediction'])
                rightness = 1 if (x['label'] == 'legit' and x['prediction'] < 0.5) or (x['label'] == 'dga' and x['prediction'] >= 0.5) else 0
                return distance, rightness
            else:
                distance = abs(0.5 - x['prediction'])
                dganess = 0 if x['prediction'] < 0.5 else 1
                return distance, dganess

        if self.inputv.capture.labeled:
            df = pd.concat([self.inputv.domain, self.inputv.X_str, self.inputv.label, self._prediction], axis=1)
        else:
            df = pd.concat([self.inputv.domain, self.inputv.X_str, self._prediction], axis=1)

        df_d_rl = df.apply(d_rl, axis=1, result_type='expand')
        df_d_rl.columns = ['distance', 'rightness' if self.inputv.capture.labeled else 'dganess']
        
        df = pd.concat([self.inputv.domain, self.inputv.X_str, self._prediction, df_d_rl], axis=1)
        
        df = df.drop_duplicates().set_index(['domain', 'input'], append=True)
        df.index = pd.MultiIndex.from_tuples(df.index)
        df.index.names = ['num', 'domain', 'input']
        return df
    

    @property
    def dga2(self):
        df = self.domain
        return df[df['dganess'] == 1]

    @property
    def tld(self):
        df = pd.concat([self.inputv.domain, self.inputv.capture.tld, self._prediction], axis=1)
        df.set_index('domain', inplace=True)
        dfg = df.groupby('tld').aggregate(['mean', 'sum', 'count'])
        return dfg.droplevel(0, axis=1)