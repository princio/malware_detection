
const d3 = require('d3');

const get_cm = function (df, th) {
    const cm = {};

    for (const k of [ 'all', 1, 2, 3 ]) cm[k] =  { tn: 0, fp: 0, fn: 0, tp: 0 };

    const v_wcount = df['wcount'].values;
    const v_wvalue = df['wvalue'].values;
    const v_dga = df['dga'].values;

    for (let j = 0; j < v_dga.length; j++) {
        let l;
        if (v_dga[j] === 0) {
            l = (v_wvalue[j] > th) ? 'fp' : 'tn';
            for (const k in cm) cm[k][l] +=  v_wcount[j];
        }
        else {
            l = (v_wvalue[j] > th) ? 'tp' : 'fn';
            cm.all[l] +=  v_wcount[j];
            cm[v_dga[j]][l] +=  v_wcount[j];
        }
    }

    return cm;
}

const get_dgas = function(dga1, dga2, dga3) {
    return {
        1: dga1,
        2: dga2,
        3: dga3
    }
}

const get_ths = function(fields) {
    const step = +((fields.bounds.max - fields.bounds.min) / fields.sampling).toPrecision(2);

    const ths = [];

    for (let i = fields.bounds.min; i <= fields.bounds.max; i += step) {
        ths.push(Number(i));
    }

    return ths;
}

const get_cms = function(df, ths) {
    return ths.map(th => get_cm(df, th));
}

const calculate_plot = function (cms, relative=true) {

    const x = [];
    const y_n = [];
    const y_p = [];

    let p = 1;
    let n = 1;
    if (relative) {
        const tmp = cms[Object.keys(cms)[0]].cm;
        p = tmp.tp + tmp.fn;
        n = tmp.tn + tmp.fp;
    }

    for (const cm of cms) {
        x.push(cm.th);
        y_n.push(+(cm.cm.fp/n).toPrecision(2));
        y_p.push(+(cm.cm.tp/p).toPrecision(2));
    }

    return { x, y_n, y_p };
};

const report = function (cm) {

    const { tn, fp, fn, tp } = cm;

    const normal = {
        pr: tn / (tn + fn),
        re: tn / (tn + fp),
        tnr: tn / (tn + fp),
        f1: null
    }
    normal['f1'] = 2 * (normal.pr * normal.re) / (normal.pr + normal.re);

    const infected = {
        pr: tp / (tp + fp),
        re: tp / (tp + fn),
        tpr: tp / (tp + fn),
        f1: null
    }
    infected['f1'] = 2 * (infected.pr * infected.re) / (infected.pr + infected.re);

    const macro = {
        pr: (normal.pr + infected.pr) / 2,
        re: (normal.re + infected.re) / 2,
        tr: (normal.tnr + infected.tpr) / 2,
        f1: (normal.f1 + infected.f1) / 2,
        accuracy: (tp + tn) / (tp + tn + fp + fn)
    }

    return {
        normal,
        infected,
        macro
    }
};

const generate_frame = function (apply, visual_cm, fields) {

    const f = d3.format('.2s');

    const dgas_str = Object.keys(fields.dgas).map((dd) => fields.dgas[dd] ? dd : '').join('');

    const fn = `plot_${apply.wtype}_${apply.windowing}_${apply.wsize}_${f(apply.top10m)}_${dgas_str}_th${f(fields.th).replace('−', '-')}_${visual_cm.tp}_${visual_cm.tn}`;

    const frame = `
          
    \\begin{frame}{ww=${apply.windowing}, s=${apply.wsize}, vDGA=${dgas_str}, $t^*$=\\numprint{${apply.top10m}}}
    
        \\begin{align*}
            &th = ${f(fields.th).replace('−', '-')} \\\\
            &\\begin{pmatrix}
                    ${visual_cm.tn} & ${visual_cm.fp} \\\\
                    ${visual_cm.fn} & ${visual_cm.tp} \\\\
                \\end{pmatrix}
        \\end{align*}
        \\begin{center}
            \\includegraphics[trim={2cm 0 0 3.5cm},clip, width=\\textwidth]{plots/${fn}.jpeg}
        \\end{center}
    
    \\end{frame}
    `;

    return { frame, fn };
};

const copy2clipboard = function (document, tocopy) {
    let textArea = document.createElement("textarea");
    textArea.value = tocopy;
    // make the textarea out of viewport
    textArea.style.position = "fixed";
    textArea.style.left = "-999999px";
    textArea.style.top = "-999999px";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    new Promise((res, rej) => {
        // here the magic happens
        document.execCommand('copy') ? res() : rej();
        textArea.remove();
    });
}

const get_plotly = function (plot, th) {

    var trace1 = {
        x: plot.x,
        y: plot.y_n,
        type: 'scatter',
        name: 'tnr'
    };

    var trace2 = {
        x: plot.x,
        y: plot.y_p,
        type: 'scatter',
        name: 'tpr'
    };

    var data = [trace1, trace2];

    const { annotation, shape } = get_plotly_annotations_for_th(th);

    return {
        data,
        layout: {
            width: 800,
            height: 400,
            margins: { l: 10, r: 10, t: 10, b: 10 },
            xaxis: {
                title: 'Threshold',
                showgrid: false,
                zeroline: false,
            },
            yaxis: {

                title: 'True Positive/Negative Ratio',
                showgrid: false,
                zeroline: false,
                fixedranged: true,
                range: [-0.1, 1.1]
            },
            annotations: [
                annotation
            ],
            shapes: [
                shape
            ]
        },
        // options: {
        //     modeBarButtonsToAdd: [
        //         {
        //             name: 'download&copy',
        //             icon: Plotly.Icons.pencil,
        //             click: (gd) => {
        //                 const { frame, fn } = generate_frame(apply, visual_cm, th, dgas);
        //                 copy2clipboard(document, frame);
        //                 Plotly.downloadImage(gd, {
        //                     filename: fn,
        //                     format: 'jpeg',
        //                     width: gd._fullLayout.width,
        //                     height: gd._fullLayout.height
        //                 });
        //             }
        //         },
        //     ],
        // }
    };
}


const get_plotly2 = function (cms, ths, th, relative = true) {

    const x = [];
    const y = {};

    for (const k of [ 'all', 1, 2, 3 ]) y[k] = { tp: [], fp: [] };

    let p = {};
    let n = 1;
    if (relative) {
        n = cms[0].all.tn + cms[0].all.fp;
        for (const k in y) {
            p[k] = cms[0][k].fn + cms[0][k].tp;
        }
    }

    for (const i in cms) {
        const cm = cms[i];
        x.push(ths[i]);
        for (const k in y) {
            y[k].fp.push(+(cm[k].fp/n).toPrecision(2))
            y[k].tp.push(+(cm[k].tp/p[k]).toPrecision(2))
        }
    }

    const data = [];

    for (const k in y) {

        var trace_fp = {
            x: x,
            y: y[k].fp,
            type: 'scatter',
            name: `[${k}] fp`
        };
        var trace_tp = {
            x: x,
            y: y[k].tp,
            type: 'scatter',
            name: `[${k}] tp`

        }
    
        data.push(trace_fp, trace_tp);
    }

    console.log(th);

    const { annotation, shape } = get_plotly_annotations_for_th(th);

    return {
        data,
        layout: {
            width: 800,
            height: 400,
            margins: { l: 10, r: 10, t: 10, b: 10 },
            xaxis: {
                title: 'Threshold',
                showgrid: false,
                zeroline: false,
            },
            yaxis: {

                title: 'True Positive/Negative Ratio',
                showgrid: false,
                zeroline: false,
                fixedranged: true,
                range: [-0.1, 1.1]
            },
            annotations: [
                annotation
            ],
            shapes: [
                shape
            ]
        },
    };
}

const get_plotly_annotations_for_th = function (th) {

    const f = d3.format('.2s');

    const annotation = {
        text: 'th=' + f(th),
        x: th,
        y: 1.05,
        align: 'right',
        xanchor: 'left',
        showarrow: false
    }

    const shape = {
        type: 'line',
        x0: th,
        y0: 0,
        x1: th,
        y1: 1,
        line: {
            color: 'grey',
            width: 1.5,
            dash: 'dot'
        }
    };

    return { annotation, shape };
}

export {
    get_cm,
    get_ths,
    get_cms,
    get_dgas,
    calculate_plot,
    report,
    generate_frame,
    copy2clipboard,
    get_plotly,
    get_plotly2,
    get_plotly_annotations_for_th
}