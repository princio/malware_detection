
<template>
  <div id="apply">
    <div v-if="unwindowed.state">
      {{ unwindowed.message }}
      <button v-on:click="apply_exec()">{{ execution }}</button>
    </div>
    <table v-if="!unwindowed.state">
      <tbody>
        <tr>
          <td>
            <div class="row">
              <input
                type="range"
                :min="bounds.min"
                :max="bounds.max"
                step=1
                v-on:change="update_cm"
                v-model.number="th"
              />
              <input type="text" style="width:50px"
                v-on:change="update_cm"
                v-model.number="th"
              />
            </div>
          </td>
          <td>
            {{ apply.wsize }}
          </td>
          <td>
            {{ apply.wtype }}
          </td>
          <td>
            {{ apply.top10m }}
          </td>
          <td>
            <div style="display: flex; flex-direction: row;">
              <div style="font-size: 48px">(</div>
              <table style="margin: 0; padding: 0;">
                <tbody>
                  <tr>
                    <td>{{ tn }}</td>
                    <td>{{ fp }}</td>
                  </tr>
                  <tr>
                    <td>{{ fn }}</td>
                    <td>{{ tp }}</td>
                  </tr>
                </tbody>
              </table>
              <div style="font-size: 48px">)</div>
            </div>
          </td>
          <td>
            campionamento:
            <div class="row">
              <input
                type="range"
                :min="5"
                :max="100"
                :step="5"
                v-on:change="fetch_df"
                v-model.number="rounder_step"
              />
              <input type="text" style="width:50px"
                v-on:change="fetch_df"
                v-model.number="rounder_step"
              />
            </div>
          </td>
          <td>
            <div id="myDiv"></div>
          </td>
        </tr>
      </tbody>
    </table>
    <span>{{ console }}</span>
  </div>
</template>

<script>
const dfd = require('danfojs/dist/index')
const Plotly = require('plotly.js-dist')
const axios = require('axios');

export default {
  name: "App",
  components: {
  },
  props: [ 'apply_id' ],
  data: function () {
    return {
      apply: {
        wsize: '--',
        wtype: '--',
        top10m: '--',
      },
      console: "",
      execution: "Exec",
      df: null,
      th: 50,
      rounder_step: 5,
      size: 100,
      top10m: 0,
      windowing: 'resreq',
      dga: 3,
      macro: {},
      normal: {},
      infected: {},
      cf: {
        tn: 0, tp: 0, fn: 0, fp: 0
      },
      unwindowed: {
        state: false,
        message: "Function not applied"
      },
      bounds: {
        min: 0, max: 100
      },
      tn: 0, tp: 0, fn: 0, fp: 0
    };
  },
  created() {
  },
  async mounted() {

    if (this.apply_check()) {
      await this.fetch_df();
      this.update_cm();
    }
    else {
      this.unwindowed.state = true;
      this.unwindowed.message = "Apply not executed.";
    }

  },
  computed: {
  },
  methods: {
    async apply_check() {
      let resp;
      try {
        resp = (await axios.get(`http://127.0.0.1:3000/mwdb/apply/check/${this.apply_id}`)).data
      } catch (exc) {
        this.unwindowed.state = true;
        this.unwindowed.message = "Check failed.";
        this.console = exc;
        return;
      }

      return resp.check;
    },
    async apply_exec() {
      let resp;
      try {
        resp = (await axios.post(`http://127.0.0.1:3000/mwdb/apply/exec/${this.apply_id}`)).data
      } catch (exc) {
        this.console = exc;
        this.execution = "Execution";
        this.unwindowed.state = true;
        this.unwindowed.message = "Execution failed.";
        return;
      }

      this.execution = "State?";
      this.unwindowed.state = resp.executing === 'success' ? false : true;
      this.unwindowed.message = resp.message;
      if (this.unwindowed.state) {
        await this.fetch_df();
      }
    },
    async fetch_df() {

      this.console = this.rounder;
      
      let windows;

      try {
        windows = (await axios.post(`http://127.0.0.1:3000/mwdb/apply/${this.apply_id}`, { rounder: this.rounder_step })).data;
      } catch (exc) {
        this.unwindowed.state = true;
      }
      if (windows.values.length === 0) {
        this.unwindowed.state = true;
        return null;
      }

      console.log(windows);

      this.apply = windows.apply;
      this.steps = windows.steps;

      console.log(this.apply);

      
      this.df = new dfd.DataFrame(windows.values, { columns: windows.columns });

      this.bounds.min = this.df['wvalue'].min() - 5;
      this.bounds.max = this.df['wvalue'].max() + 5;

      const y_n = [];
      const y_p = [];
      const x = [];

      for (let i = this.bounds.min; i <= this.bounds.max; i += 10) {
        const cm = this.get_cm(i);
        
        y_n.push(cm.tn / (cm.tn + cm.fp));
        y_p.push(cm.tp / (cm.tp + cm.fn));

        x.push(i);
      }


      var trace1 = {
        x,
        y: y_p,
        type: 'scatter',
        name: 'tnr'
      };

      var trace2 = {
        x,
        y: y_n,
        type: 'scatter',
        name: 'tpr'
      };

      var data = [trace1, trace2];

      Plotly.newPlot('myDiv', data, {
        xaxis: {
          title: 'Threshold',
          showgrid: false,
          zeroline: false
        },
        yaxis: {
          title: 'True Positive/Negative Ratio',
          showgrid: false,
          zeroline: false
        },
      });
    },
    get_cm(th) {
      const s_det = new dfd.Series(this.df['wvalue'].gt(th).values);
      const s_ndet = s_det.apply((x) => !x)

      const tn = this.df['wcount'].loc(s_ndet.and(this.df['dga'].eq(0))).sum();
      const fp = this.df['wcount'].loc( s_det.and(this.df['dga'].eq(0))).sum();
      const fn = this.df['wcount'].loc(s_ndet.and(this.df['dga'].le(this.dga))).sum();
      const tp = this.df['wcount'].loc( s_det.and(this.df['dga'].le(this.dga))).sum();

      return { tn, fp, fn, tp };
    },
    update_cm() {

      const { tn, fp, fn, tp } = this.get_cm(this.th);

      const normal = {
        pr: tn / (tn + fn),
        re: tn / (tn + fp),
        tnr: tn / (tn + fp),
        f1: null
      }
      normal['f1'] = 2 * (normal.pr * normal.re) / (normal.pr + normal.re);

      const infected = {
        pr: tp / (tp + fp),
        re: tp / (tp + fn),
        tpr: tp / (tp + fn),
        f1: null
      }
      infected['f1'] = 2 * (infected.pr * infected.re) / (infected.pr + infected.re);

      const macro = {
        pr: (normal.pr + infected.pr) / 2,
        re: (normal.re + infected.re) / 2,
        tr: (normal.tnr + infected.tpr) / 2,
        f1: (normal.f1 + infected.f1)/2,
        accuracy: (tp + tn) / (tp + tn + fp + fn)
      }

      this.normal = normal;
      this.infected = infected;
      this.macro = macro;

      this.cf = { tn, fn, fp, tp };

      this.tn = tn;
      this.fn = fn;
      this.fp = fp;
      this.tp = tp;

    },
  },
  updated: function () {
  },
  watch: {
  }
};
</script>

<style>
.left {
  text-align: left;
}
.center {
  text-align: center;
  margin: auto;
}
.nopadding {
  padding: 0;
  margin: auto;
  text-align: left;
  margin: auto;
}
.greenclass {
  color: yellowgreen;
}
.redclass {
  color: red;
}
.btn {
  border: 0;
  background-color: transparent;
  color: white;
  font-size: 20px;
}
.column {
  display: flex;
  flex-direction: column;
  justify-content: space-around;
  width: 100%;
  text-align: left;
}
.row {
  display: flex;
  flex-direction: row;
}
table > tbody > tr > td {
  vertical-align: middle;
  text-align: center;
  padding: 0 10px;
}
table > tbody > tr > th {
  text-align: left;
  padding: 0 20px;
}
table, .dataframe {
  border: 0 !important;
  padding: 50px 0px 0 0;
}
body {
  margin: 0;
  background-color: rgb(53, 53, 53);
}
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: white; /*#2c3e50;*/
  padding: 20px;
}
th,
td {
  vertical-align: top;
}
</style>