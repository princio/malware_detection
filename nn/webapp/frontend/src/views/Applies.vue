<template>
  <div class="applies">
    <table
      v-if="Object.values(applies).length > 0"
      class="center"
      ref="applies_table"
    >
      <thead>
        <tr>
          <th
            style="width: 60px"
            v-for="(col_id, col_view) in applies[Object.keys(applies)[0]]"
            :key="`appcol_${col_id}`"
          >
            <div class="column">
              <span style="height: 40px">
                {{ col_view }}
              </span>
              <div>
                <button class="btn" v-on:click="setHSort(hindex, false)">
                  <font-awesome-icon :icon="['fas', 'sort-numeric-up-alt']" />
                </button>
                <button class="btn" v-on:click="setHSort(hindex, true)">
                  <font-awesome-icon :icon="['fas', 'sort-numeric-down']" />
                </button>
              </div>
            </div>
          </th>
          <th></th>
        </tr>
      </thead>
      <tbody ref="applies_table_body">
        <tr v-for="(apply, hash) in applies" :key="`row_${hash}`">
          <td
            v-for="(value, name) in apply"
            :key="`cell_index_${hash}_${name}`"
          >
            <span v-if="name === 'hash'">
              {{ value.substring(0, 8) }}
            </span>
            <span v-else-if="name === 'model_id'">
              {{ models[value].name }}
            </span>
            <span v-else-if="name === 'color'">
              <input
                type="text"
                v-model="applies[hash].color"
                v-on:change="applies_changed"
              />
            </span>
            <span v-else-if="name === 'name'">
              <input
                type="text"
                v-model="applies[hash].name"
                v-on:change="applies_changed"
              />
            </span>
            <span v-else-if="name === 'checked'">
              <input
                type="checkbox"
                v-model="applies[hash].checked"
                v-on:change="applies_changed"
              />
            </span>
            <span v-else-if="name === 'dgas'">
              <div class="row">
                <div
                class="checkbox-button"
                  v-for="dga in [ 1, 2, 3, 'all' ]" :key="`checkbox_dga_${hash}_${dga}`"
                >
                  <label>
                    <input type="checkbox"
                      v-model="applies[hash].dgas[dga]"
                      v-on:click="change_dga(hash, dga)"
                    />
                    <span>{{ dga }}</span>
                  </label>
                </div>
              </div>
            </span>
            <span v-else>
              {{ value }}
            </span>
          </td>
        </tr>
      </tbody>
    </table>
    <div class="center">
      <apply-new-bar
        v-on:update:hash="applies_fetch"
        :mounted="mounted"
      ></apply-new-bar>
      <apply-plot-bar
        v-on:update:fields="updateBarFields"
        :applies="applies"
        :mounted="mounted"
      ></apply-plot-bar>
      <apply-plot-dgas
        v-if="Object.keys(applies).length > 0"
        :show_infos="true"
        :applies="applies_checked"
        :fields.sync="fields"
        :dfs="dfs"
      ></apply-plot-dgas>
    </div>
  </div>
</template>

<script>
import ApplyNewBar from "../components/apply/NewBar.vue";
import ApplyPlotBar from "../components/apply/PlotBar.vue";
import ApplyPlot2 from "../components/apply/Plot2.vue";

const axios = require("axios");
const dfd = require("danfojs/dist/index");

export default {
  name: "Applies",
  components: {
    "apply-new-bar": ApplyNewBar,
    "apply-plot-bar": ApplyPlotBar,
    "apply-plot-dgas": ApplyPlot2,
  },
  data: function () {
    this.ths_measures = {};
    return {
      applies: {},
      applies_checked: [],
      cms: [],
      dfs: {},
      fields: {
        applies: {},
        bounds: { min: -100, max: 100 },
        dgas: {},
        sampling: 100,
        th: 50,
      },
      mounted: false,
      values: [],
      models: {},
    };
  },
  async mounted() {
    this.models = (
      await axios.get("http://127.0.0.1:3000/mwdb/model/fetch")
    ).data.models;

    this.models = this.models.reduce((map, model) => {
      map[model.id] = model;
      return map;
    }, {});

    await this.applies_fetch();
    await this.fetch_dfs();
    this.mounted = true;
  },
  methods: {
    applies_changed() {
      if (Object.keys(this.applies).length === 0) return;

      this.applies_checked = Object.keys(this.applies).reduce((aps, hash) => {
        const ap = this.applies[hash];
        ap.hash = hash;
        if (ap.checked) aps.push(ap);
        return aps;
      }, []);
    },
    async apply_delete(hash) {
      this.loading = true;
      axios
        .post("http://127.0.0.1:3000/mwdb/apply/delete", {
          hash: hash,
        })
        .then((res) => {
          this.hash = res.data.hash;
          this.emit_fields();
          this.loading = false;
        })
        .catch(() => {
          this.loading = false;
        });
    },
    async applies_fetch() {
      this.applies = (
        await axios.get("http://127.0.0.1:3000/mwdb/apply/fetch")
      ).data.applies;

      for (const h in this.applies) {
        const _name = this.applies[h].name;
        delete this.applies[h].name;
        this.applies[h].name = _name;
        this.applies[h].color = 'black';
        this.applies[h].checked = true;
        this.applies[h].dgas = { 1: false, 2: false, 3: false, all: true };
      }
    },
    change_dga(hash, dga) {
      this.applies[hash].dgas[dga] = !this.applies[hash].dgas[dga];
      this.applies_changed();
    },
    async fetch_dfs() {
      const df_applies = (
        await axios.post("http://127.0.0.1:3000/mwdb/apply/all", {
          rounder: this.fields.sampling,
        })
      ).data;

      this.dfs = Object.fromEntries(
        Object.keys(df_applies).map((apply_id) => [
          Number(apply_id),
          new dfd.DataFrame(df_applies[apply_id].values, {
            columns: df_applies[apply_id].columns,
          }),
        ])
      );
    },
    updateBarFields(fields) {
      this.fields = fields;
    },
  },
  watch: {
    "fields.sampling": {
      async handler() {
        await this.fetch_dfs();
      },
      deep: true,
    },
  },
};
</script>


<style scoped>
.active {
  background-color: lightskyblue;
}
.boldd {
  font-weight: bold;
  font-size: 16px;
}
.center {
  text-align: center;
  margin: auto;
}
#app > div.applies > table > tbody {
  text-align: left;
}
table > tbody > tr > td,
th {
  text-align: left;
}
</style>