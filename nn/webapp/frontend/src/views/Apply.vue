
<template>
  <div id="apply">
  </div>
</template>

<script>
const dfd = require('danfojs/dist/index')
const axios = require('axios');

const apply_id = 1;

const SIZES = [ 100, 500, 2500 ];
const FXS = ["llr", "nx", "gt09", 'llrt' ];


function get_row(cm, normalized = true) {
  const _2d = (n) => (n >= 0.99 && n < 1) ? 0.99 : ((n > 0 && n <= 0.01) ? 0.01 : n.toFixed(2));

  const _print = (n, reverse=false, color=true) => {
    let t;
    let colors = [ 'red', 'YellowGreen' ];
    if (reverse)
      colors = colors.reverse();

    n = _2d(n);

    if (n == 1) t = `1`;
    else
    if (n == 0) t = `0`;
    else
      t = `${n}`.slice(1)

    if (color) {
      if (isNaN(n)) t = '{\\color{yellow}-}';
      
      if (n <= 0.5)
        t = `{\\color{${colors[0]}} ${t}}`
      else
      if (n >= 0.5)
        t = `{\\color{${colors[1]}} ${t}}`
    }
    return t;
  };

  let tn = cm.cm.tn;
  let fn = cm.cm.fn;
  let fp = cm.cm.fp;
  let tp = cm.cm.tp;
  if (normalized) {
    const p = cm.cm.tp + cm.cm.fn;
    const n = cm.cm.tn + cm.cm.fp;
    tn = _print(tn/n);
    fp = _print(fp/n, true, false);
    fn = _print(fn/p, true, false);
    tp = _print(tp/p);
  }

  const col1 = `$\\small\\begin{pmatrix} ${tn} & ${fp} \\\\ ${fn} & ${tp} \\end{pmatrix}$`;


  return [
    cm.r.fx,
    cm.r.size,
    cm.r.dga,
    cm.cm.th,
    col1,
    _2d(cm.cm.report.normal.tpr),
    _2d(cm.cm.report.infected.tpr),
    _2d(cm.cm.report.macro.accuracy),
  ];
} //end get_row

export default {
  name: "App",
  components: {},
  data: function () {
    return {
      df: null
    };
  },

  async created() {
    const data = (await axios.get(`http://127.0.0.1:3000/mwdb/window/grouped/${apply_id}`)).data;
    this.df = new dfd.DataFrame(data.values, { columns: data.columns });
  },

  async mounted() {
    this.renderMathJax([this.$refs.toolbar]);

    for (const fx of this.fxs) {
      if (fx === 'ratio') continue;
      
      this.cms[fx] = []
      this.dfs[fx] = await dfd.read_csv(`http://127.0.0.1:3000/csv/${fx}.csv`);
    }

    this.ths_measures = (await axios.get('http://127.0.0.1:3000/csv/measures.json')).data;
    
    this.set_ths_to_type('mean');

    this.reload();
    this.render();
  },

  computed: {
    compiledHtml: function () {
      return this.input;
    },
    compiledBounds: function () {
      return this.bounds;
    },
    legend_btn_label: function () {
      return this.legend_show ? "Hide" : "Show";
    },
    bounds_btn_label: function () {
      return this.bounds_show ? "Hide" : "Show";
    },
    th_measure_sym: function () {
      return {
        mean: '\\bar{\\mu}',
        max: '\\bar{M}'
      }
    },
    thsbounds: function() {
      
      const ths = {};
      for (const fx of FXS) {
        ths[fx] = {}
        for (const size of SIZES) {
          ths[fx][size] = {}
          let min = Math.min(...Object.keys(this.ths_measures[fx][size]).map((dga) => this.ths_measures[fx][size][dga].min));
          let max = Math.max(...Object.keys(this.ths_measures[fx][size]).map((dga) => this.ths_measures[fx][size][dga].max));
          for (const dga of [ 1, 2, 3 ]) {
            ths[fx][size][dga] = {
              min,
              max
            }
          }
        }
      }

      return ths;
    },
    sortedArray: function() {
      return this.values.slice().sort((r1, r2) => {
        let a = r1[this.hindex];
        a = a === 'NaN' ? -1 : a;
        let b = r2[this.hindex];
        b = b === 'NaN' ? -1 : b;
        return (this.hasc ? (a - b) : (b - a))
      });
    },
  },
  methods: {
    async setHSort(hindex, asc) {
      this.hindex = hindex;
      this.hasc = asc;
    },
    get_cm(fx, size, dga, th) {
      let df = this.dfs[fx];
      df = df.query({ condition: df['size'].eq(Number(size)).and(df['dga'].eq(0).or(df['dga'].eq(Number(dga)))) });
      
      df.addColumn({ column: 'detected', values: df[fx].gt(th), inplace: true });
      
      const s_det = df['detected']
      const s_ndet = df['detected'].apply((x) => !x)

      const tn = df['window'].loc(s_ndet.and(df['dga'].eq(0))).sum();
      const fp = df['window'].loc( s_det.and(df['dga'].eq(0))).sum();
      const fn = df['window'].loc(s_ndet.and(df['dga'].eq(dga))).sum();
      const tp = df['window'].loc( s_det.and(df['dga'].eq(dga))).sum();

      let normal = {
        pr: tn / (tn + fn),
        re: tn / (tn + fp),
        tpr: tn / (tn + fp)
      }
      normal['f1'] = 2 * (normal.pr * normal.re) / (normal.pr + normal.re);

      const infected = {
        pr: tp / (tp + fp),
        re: tp / (tp + fn),
        tpr: tp / (tp + fn)
      }
      infected['f1'] = 2 * (infected.pr * infected.re) / (infected.pr + infected.re);

      const macro = {
        pr: (normal.pr + infected.pr) / 2,
        re: (normal.re + infected.re) / 2,
        tpr: (normal.tpr + infected.tpr) / 2,
        f1: (normal.f1 + infected.f1)/2,
        accuracy: (tp + tn) / (tp + tn + fp + fn)
      }

      return {
        r: { fx, size, dga },
        cm: {
          th,
          tn, fp, fn, tp,
          report: { normal, infected, macro }
        }
      };
    },
    clearMathJax() {
      const nodes = {}
      for (const node of window.MathJax.startup.document.getMathItemsWithin(this.$refs.cms_table_body)) {
        const cellIndex = node.end.node.parentElement.parentElement.rowIndex;
        if (cellIndex in nodes) {
          nodes[cellIndex].remove();
          nodes[cellIndex] = node.end.node;
        }
        else
          nodes[cellIndex] = node.end.node;
      }
    },
    get_cms() {
      const cms = [];
      for (const fx of this.checkedFxs) {
        if (fx === 'ratio') continue;
        for (const size of this.checkedSizes) {
          for (const dga of this.checkedDgas) {
            const th = this.ths[fx][size][dga];
            cms.push(this.get_cm(fx, size, dga, th));
          }
        }
      }
      return cms;
    },
    async update_row(index) {
      const row = this.values[index];
      const cm = this.get_cm(row[0], row[1], row[2]);
      this.values[index] = get_row(cm, this.normalized);
    },
    async reload() {
      this.values = this.get_cms().map((cm) => get_row(cm, this.normalized));
      await this.$nextTick();
      this.clearMathJax();
      this.renderMathJax([this.$refs.cms_table_body]);
    },
    set_ths_to_type(type) {
      for (const fx of this.fxs) {
        for (const size of this.sizes) {
          for (const dga of [ 1,2,3 ]) {
            this.ths[fx][size][dga] = this.ths_measures[fx][size][dga][type];
          }
        }
      }
      this.reload()
    },
    set_ths_with_same_dgas(fx, size) {
      const dga_chosen = this.ths_dgas[fx][size].dga;
      const thmm_chosen = this.ths_dgas[fx][size].measure;
      const m = this.ths_measures[fx][size][dga_chosen][thmm_chosen]
      for (const dga of this.dgas) {
        this.ths[fx][size][dga] = m;
      }
      this.reload()
    },
    fx_symbol(fx) {
      return {
        'llr': '$\\lambda$',
        'nx': '$nx$',
        'gt09': '$gt_{0.9}$',
        'ratio': '$p$',
        'llrt': '$\\lambda_l$',
      }[fx]
    },
    toggle_legend() {
      this.legend_show = !this.legend_show;
    },
    toggle_bounds() {
      this.bounds_show = !this.bounds_show;
    },
    render() {
      this.renderMathJax([this.$refs.toolbar]);
      this.renderMathJax([this.$refs.mathJaxEl]);
      if (this.legend_show)
        this.renderMathJax([this.$refs.legend]);
      if (this.bounds_show)
        this.renderMathJax([this.$refs.bounds]);
      this.renderMathJax([this.$refs.cms_table]);
    },
    renderMathJax(refs = [this.$refs.mathJaxEl]) {
      if (!refs ||  refs.length === 0 || !refs[0])
        return
      if (window.MathJax && window.MathJax.typesetPromise)
          window.MathJax.typesetPromise(refs);
    },
    tolatex() {
      let lx = `\\begin{tabular}{lllcrrrr}\n`
      for (const row of this.values) {
        for (const idx in row) {
          let value = row[idx];
          if (idx == 3) {
            value = Number.parseFloat(row[idx] / this.ths_measures[row[0]][row[1]][0].max).toFixed(2);
            value = `{\\small$${value}\\cdot\\bar{M}$}`
          }
          if (typeof(value) == 'string') 
            lx += ` ${value.replaceAll('YellowGreen', 'OliveGreen')} &`
          else
            lx += ` ${value} &`
        }
        lx = lx.substring(0, lx.length-1) + `\\\\\n`
      }
      lx += `\\end{tabular}`
      navigator.clipboard.writeText(lx).then(function() {
        console.log('Async: Copying to clipboard was successful!');
      }, function(err) {
        console.error('Async: Could not copy text: ', err);
      });
    }
  },
  updated: function () {
    this.$nextTick(function () {
      if(this.renderTable) {
        this.renderMathJax([this.$refs.cms_table_body]);
        this.clearMathJax();
        this.renderTable = false;
      }
    })
  },
};
</script>

<style>
.left {
  text-align: left;
}
.center {
  text-align: center;
  margin: auto;
}
.nopadding {
  padding: 0;
  margin: auto;
  text-align: left;
  margin: auto;
}
.greenclass {
  color: yellowgreen;
}
.redclass {
  color: red;
}
.btn {
  border: 0;
  background-color: transparent;
  color: white;
  font-size: 20px;
}
.column {
  display: flex;
  flex-direction: column;
  justify-content: space-around;
  width: 100%;
  text-align: left;
}
.row {
  display: flex;
  flex-direction: row;
}
table > tbody > tr > td {
  vertical-align: middle;
  text-align: center;
  padding: 0 10px;
}
table > tbody > tr > th {
  text-align: left;
  padding: 0 20px;
}
table, .dataframe {
  border: 0 !important;
  padding: 50px 0px 0 0;
}
body {
  margin: 0;
  background-color: rgb(53, 53, 53);
}
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: white; /*#2c3e50;*/
  padding: 20px;
}
th,
td {
  vertical-align: top;
}
</style>