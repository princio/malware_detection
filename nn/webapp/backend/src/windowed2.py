import json

import pandas as pd

import numpy as np

import requests

import re
import base64

df_windows = pd.read_csv("df_windows.csv")

configs = {
    "llr": {
        "fx": "$\lambda$",
        "label": "$\\bar{M}_{\lambda}^{%d}\cdot%0.1f$",
        "function": lambda df, th: df.llr > th
    },
    "nx": {
        "fx": "$nx$",
        "label": "$\\bar{M}_{nx}^{%d}\cdot%0.1f$",
        "function": lambda df, th: df.nx > th
    },
    "gt_": {
        "fx": "$gt$",
        "label": "$\\bar{M}^{%d}_" + "{gt_{%0.1f}}" % 0.9 + "\cdot%0.1f$",
        "function": lambda df, th: df.gt_ > th
    }
}

def cm_latex(df_cm):
    result = df_cm.to_latex(escape=False)\
        .replace("\n", "")\
        .replace(r"\toprule{}", "")\
        .replace(r"\midrule", "")\
        .replace(r"\bottomrule", "")\
        .replace(r"tabular}{lrr}", r"tabular}")\
        .replace(r"tabular", r"pmatrix")
    
    regex = r"[ ]+"
    subst = " "
    result = re.sub(regex, subst, result, 0, re.MULTILINE)
    
    regex = r"\s*&\s*NIp\s*&\s*Ip\s*\\\\\s*NIt\s*&\s*"
    subst = " "
    result = re.sub(regex, subst, result, 0, re.MULTILINE | re.VERBOSE)
    
    regex = r"\s*It\s*&\s*"
    subst = " "
    result = re.sub(regex, subst, result, 0, re.MULTILINE | re.VERBOSE)

    return f"${result}$"

def tnfntpfp(tn,fn,tp,fp):
    pri = tp / (tp + fp)
    rei = tp / (tp + fn)
    f1i = 2 * (pri * rei) / (pri + rei)
    prni = tn / (tn + fn)
    reni = tn / (tn + fp)
    f1ni = 2 * (prni * reni) / (prni + reni)
    ac = (tp + tn) / (tp + tn + fp + fn)
    prm = (pri + prni)/2
    rem = (rei + reni)/2
    f1m = (f1i + f1ni)/2
    return {
        ('normal', 'pr'): tn / (tn + fn), ('normal', 're'): tn / (tn + fp),# ('normal', 'f1'): 2 * (prni * reni) / (prni + reni),
        ('normal', 'tpr'): tn / (tn + fp),
        ('infected', 'pr'): tp / (tp + fp), ('infected', 're'): tp / (tp + fn),# ('infected', 'f1'): 2 * (pri * rei) / (pri + rei),
        #('macro', 'pr'): (pri + prni)/2, ('macro', 're'): (rei + reni)/2, ('macro', 'f1'): (f1i + f1ni)/2,
        ('infected', 'tpr'): tp / (tp + fn),
        ('macro', 'f1'): (f1i + f1ni)/2,
        ('', 'accuracy'): (tp + tn) / (tp + tn + fp + fn)
    }

def results(df_windows, function, th, dga, gt = True):

    if gt:
        df = df_windows[(~df_windows.infected) | (df_windows.dga >= dga)].copy()
    else:
        df = df_windows[(~df_windows.infected) | (df_windows.dga == dga)].copy()

    df["$n$"] = 1

    n_windows = df["$n$"].sum()

    df_inf = df[df.infected].copy()
    
    s_inf_detected = function(df_inf, th)

    df_inf_detected = df_inf[s_inf_detected].groupby("pcap_id").aggregate({
        "window": ["first", "count"]
    })

    normalizer = df_inf.groupby("pcap_id").aggregate({
        "window": ["count"]
    })

    df_win2 = normalizer.join(df_inf_detected, on="pcap_id", how="left", lsuffix="_tot")


    pcap_undetected = df_win2[("window", "first")].isna().sum()
    pcap_detected = df_win2.shape[0] - pcap_undetected


    df_win2_detected = df_win2[~df_win2[("window", "first")].isna()]
    window_first_mean = (df_win2_detected[("window", "first")] / df_win2_detected[("window", "count")]).mean()

    s_detected = function(df, th)

    tp = ((s_detected) & (df.infected)).sum()
    fp = ((s_detected) & (~df.infected)).sum()
    fn = ((~s_detected) & (df.infected)).sum()
    tn = ((~s_detected) & (~df.infected)).sum()

    df_cm = pd.DataFrame.from_dict({'NIt': { 'NIp': tn, 'Ip': fp }, 'It': {'NIp': fn, 'Ip': tp } }, orient='index')

    report = tnfntpfp(tn, fn, tp, fp)
    df = pd.DataFrame.from_dict(report, orient="index").T
    df.columns = pd.MultiIndex.from_tuples(df.columns)

    df.reset_index()

    detected_over = "%d/%d" % (pcap_detected, pcap_detected + pcap_undetected)

    return n_windows, [detected_over, "%0.2f" % window_first_mean,  cm_latex(df_cm)] + df.round(2).to_numpy().tolist()[0], df.columns



def process(dga_gt, sizes, dgas, cff = { 'llr': 0.5, 'nx': 0.5, 'gt_': 0.5 }, iterators_chosen = [ "size", "dga", "configs" ]):
    """
    dga_gt: vDGA >= gt if dga_gt else vDGA = gt 
    """
    df = df_windows[['infected', 'pcap_id', 'size', 'llr', 'gt_', 'nx', 'dga']].copy()

    df = df.groupby(['infected', 'size', 'dga']).aggregate({
        'llr': ['max', 'min', 'mean', 'std'],
        'nx': ['max', 'min', 'mean', 'std'],
        'gt_': ['max', 'min', 'mean', 'std'],
    }).astype(int)

    df_ths = df.unstack(0).unstack(1).copy()

    labels = {
        "s": "$s$", "vDGA": "vDGA", "n_w": "$n_w$", "th": "$th_f$", "fx": "$f$"
    }

    labels_map = {
        "size": ["s", "n_w"],
        "dga": ["vDGA"],
        "configs": ["fx", "th"]
    }

    sizes = sizes
    dgas = dgas[::-1]

    iterators = { "size": sizes, "dga": dgas, "configs": configs }

    labels_names = [ l for ll in [ labels_map[i] for i in iterators_chosen ] for l in ll]

    def iters(vvs):
        ret_ = [ 0, 0, 0 ]
        iterators_map = { "size": 0, "dga": 1, "configs": 2 }
        for i, it in enumerate(iterators_chosen):
            ret_[iterators_map[it]] = vvs[i]
        return tuple(ret_)

    values = {}
    for v0 in iterators[iterators_chosen[0]]:
        for v1 in iterators[iterators_chosen[1]]:
            for v2 in iterators[iterators_chosen[2]]:

                ( size, dga, fx_name ) = iters([ v0, v1, v2 ])

                fx = configs[fx_name]

                th = cff[fx_name] * df_ths[(fx_name, 'max', False, 1)][size]

                n_windows, vv, columns = results(df_windows[df_windows["size"] == size].copy(), fx["function"], th, dga, dga_gt)

                index = {
                    "s": size,
                    "vDGA": "$%s %d$" % ("\gt" if dga_gt else "=", dga),   
                    "n_w": "$%d$" % (n_windows),
                    "fx": fx["fx"],
                    "th": cff[fx_name]
                }

                values[tuple([index[i] for i in labels_names ])] = vv

    cols = [( "", "$n_p^d/n_p$"), ("", "$N_w$"), ("", "CM")] + list(columns)

    df = pd.DataFrame.from_dict(values, orient="index")
    df.columns = pd.MultiIndex.from_tuples(cols)
    df.index = pd.MultiIndex.from_tuples(df.index.values, names=[labels[l] for l in labels_names])

    return df


def get_html(gt, sizes, dgas, ths, fxs):

    df = process(gt, sizes, dgas, ths)

    def highlight_lt(s, v, props=''):
        return np.where(s <= v, props, '')
    def highlight_gt(s, v, props=''):
        return np.where(s > v, props, '')
    def all(s,v,props=''):
        return [props] * s.shape[0]

    df['fx'] = [ v[-2] for v in df.index ]

    df = df.loc[pd.IndexSlice[:, :, :, [ configs[fx]['fx'] for fx in fxs]], :]

    df = df.sort_index(axis=0, level=[ 0, 2 ])#.sort_index(axis=0, level=[ 0 ])

    slice_ = [
        ('normal', 'pr'), ('normal', 're'), ('normal', 'tpr'), 
        ('infected', 'pr'), ('infected', 're'), ('infected', 'tpr'), 
    ]
    html = df.style\
            .apply(highlight_lt,  axis=1, subset=slice_, v=0.5, props='color:orange;')\
            .apply(highlight_lt, axis=1, subset=slice_, v=0.25, props='color:red;',)\
            .apply(highlight_gt, axis=1, subset=slice_, v=0.5, props='color:green;',)\
            .apply(highlight_gt, axis=1, subset=slice_, v=0.75, props='color:lightgreen;',)\
            .apply(all, axis=1, subset=[('normal', 'tpr'),('infected', 'tpr')], v=0.75, props='font-weight:800;')\
            .format(precision=2).to_html()

    b_html = bytes(html, 'utf-8')
    b64_html = base64.b64encode(b_html)
    return {
        "statusCode": 200,
        "body": json.dumps({
            "html": b64_html.decode('ascii'),
            # "location": ip.text.replace("\n", "")
        }),
    }

def get_json(gt, sizes, dgas, ths):

    df = process(gt, sizes, dgas, ths)

    df['fx'] = [ v[-1] for v in df.index ]

    return {
        "statusCode": 200,
        "body": json.dumps({
            "json": df.to_json(),
            # "location": ip.text.replace("\n", "")
        }),
    }
