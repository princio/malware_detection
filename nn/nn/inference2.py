import argparse
import pandas as pd
import os
import sys
from pslregex import PSLdict
import re

max_len = 60

vocabulary = ['', '-', '.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '_', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

pslremove_order = [
    'private', 'icann', 'tld'
]

def show_test(df_dn):
    df_dn = df_dn.loc[df_dn.icann.str.count('\.').sort_values().index]
    print(df_dn[~df_dn.private.isna()].head())
    print(df_dn[df_dn.private.isna() & (df_dn.icann.str.count('\.') > 1 ) & ~df_dn.icann.isna()].head())
    print(df_dn[df_dn.private.isna() & ~df_dn.icann.isna()].head())
    print(df_dn[df_dn.private.isna() & df_dn.icann.isna() & ~df_dn.tld.isna()].head())
    print(df_dn[df_dn.private.isna() & df_dn.icann.isna() & df_dn.tld.isna()].head())
    pass


def parse_dn(s_dn: pd.Series):
    psldict = PSLdict()
    psldict.init(download=False, update=False)

    ds = s_dn.to_frame(name='dn')

    sfx = [ psldict.match(dn) for dn in ds.dn.values ]

    ds['tld'] = ds.dn.apply(lambda dn: None if dn.count('.') == 0 or dn[-1] == '.' else dn[dn.rfind('.')+1:])
    ds['icann'] = [ s['icann']['suffix'] if s['icann'] is not None else None for s in sfx if s is not None ]
    ds['private'] = [ s['private']['suffix'] if s['private'] is not None else None for s in sfx if s is not None ]


    # https://stackoverflow.com/a/26987741
    regex = re.compile(r'^(((?!\-))(xn\-\-)?[a-z0-9\-_]{0,61}[a-z0-9]{1,1}\.)*(xn\-\-)?([a-z0-9\-]{1,61}|[a-z0-9\-]{1,30})\.[a-z]{2,}$')


    ds['invalid'] = ds.dn.apply(lambda dn: regex.match(dn) is None)

    return ds


def predict(modelpath, df_dn, pslremove):
    from keras.models import load_model as keras_load_model
    from keras.preprocessing.sequence import pad_sequences
    from tensorflow import convert_to_tensor

    pslremove_order = [
        'private', 'icann', 'tld'
    ]

    def remove_psl(row, pslremove=''):
        if row['invalid']:
            return row['dn']

        availables = []
        for pslr in pslremove_order:
            if row[pslr] is not None:
                availables += [ pslr ]

        if pslremove in availables:
            nlabels = row[pslremove].count('.') + 1
            return '.'.join(row['dn'].split('.')[0:-nlabels])
        elif len(availables) > 0:
            nlabels = row[availables[0]].count('.') + 1
            return '.'.join(row['dn'].split('.')[0:-nlabels])
            
        return row['dn']
    
    if pslremove == 'none':
        X = df_dn.dn.copy()
    else:
        X = df_dn.apply(remove_psl, axis=1, pslremove=pslremove)
    
    df_dn['X2'] = X
    
    X = X.apply(lambda x: '.'.join(x.split('.')[::-1]))

    df_dn['X_'] = X

    X = X.apply(lambda x: [ vocabulary.index(c) for c in x[:max_len] ])
    X = pad_sequences(
        X.values.tolist(), maxlen=max_len, padding='post', dtype="int32",
        truncating='pre', value=vocabulary.index('')
    )

    X = convert_to_tensor(X)

    df_dn['X'] = [ str(x) for x in X ]

    nn = keras_load_model(modelpath)

    df_dn['Y'] = nn.predict(X, batch_size=128, verbose=1)[:,0]

    return df_dn[['dn', 'X2', 'Y']]



if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Inference domain names.')
    parser.add_argument('csvpath', metavar="PATH", type=str, help='The csv file path containing the nn output.')
    parser.add_argument('column', metavar="COLUMN", type=str, help='The column name of domain names of the CSV file.')
    parser.add_argument('model',
            metavar="MODEL",
            type=str,
            help="""The model chosen.
            NONE: the whole domain name.
            TLD:  remove only the last label: google.co.uk -> google.co
            ICANN: remove the ICANN suffix: google.co.uk -> google
            PRIVATE: remove the PRIVATE suffix: last.s3.cn-north-1.amazonaws.com.cn -> last
            """,
            default="none",
            choices=[ "none", "tld", "icann", "private" ])
    parser.add_argument('-o', '--outpath', metavar="PATH", type=str, help='The output file.', required=False)
    args = parser.parse_args()

    df_dn = pd.read_csv(args.csvpath)

    if os.path.exists(args.csvpath):
        df_dn = pd.read_csv(args.csvpath)
    else:
        raise Exception("File not exist")

    if  args.column not in df_dn.columns:
        raise Exception("Domain name column not exists.")


    modelpath = {
        'none': '/home/princio/nns/malware/nns_1/nns_NONE_1_f2e20',
        'tld': '/home/princio/nns/malware/nns_1/nns_TLD_1_f8e20',
        'icann': '/home/princio/nns/malware/nns_1/nns_ICANN_1_f2e20',
        'private': '/home/princio/nns/malware/nns_1/nns_PRIVATE_1_f1e20'
    }[args.model]


    df = parse_dn(df_dn[args.column])
    df = predict(modelpath, df, args.model)

    if args.outpath is not None:
        outpath = sys.argv[4]
    else:
        outpath = os.path.splitext(sys.argv[1])[0] + '.%s.csv' % args.model

    df.to_csv(outpath)
