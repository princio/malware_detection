from re import DEBUG
from numpy.lib.arraysetops import unique
import psycopg2
from psycopg2.extras import execute_values
import pandas as pd
import math
import pprint
import argparse
import numpy as np
import utils

pp = pprint.PrettyPrinter(indent=4)

db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")

def psql_array_fns(df):
    cat = ('{' + df['first_fn'].astype(str) + ',' + df['last_fn'].astype(str) + '}').str.cat(sep=',')
    return f"{{{cat}}}"

def run(fn, wsize):

    pd.options.display.float_format = '{:.2f}'.format

    pcaps = pd.read_sql(
        f"""SELECT * FROM PCAP ORDER BY qr """,
        db,
    )

    cur = db.cursor()
    for pcap_id in pcaps["id"].values.tolist():

        tmp_llr = f"""CASE
                WHEN LOGIT = 'Infinity'
                THEN {fn["pinf"]}
                ElSE (CASE WHEN LOGIT='-Infinity' THEN {fn["ninf"]} ELSE LOGIT END)
            END"""
        
        if not(fn['top10m'] is None):
            tmp_llr = f"""CASE
                WHEN TOP10M <= {fn["top10m"]}
                THEN 0
                ElSE ({tmp_llr})
            END"""

        tmp_where = ("WHERE IS_RESPONSE IS %s " % ("FALSE" if fn["windowing"] == "req" else "TRUE")) if fn["windowing"] != "both" else ""

        query = f"""
            SELECT
                COUNT(*) as wcount,
                SUM({tmp_llr}) AS wvalue,
                FLOOR(M.FN_REQ / {wsize}) AS wnum
            FROM MESSAGES_{pcap_id} AS M
                JOIN DN ON (M.DN_ID = DN.ID)
                JOIN DN_NN AS DI ON (M.DN_ID = DI.DN_ID AND NN_ID = 1)
            {tmp_where}
            GROUP BY wnum """

        df_windows = pd.read_sql(query, db)

        df_windows['pcap_id'] = pcap_id
        df_windows['fn_id'] = fn['id']
        df_windows['wsize'] = wsize

        execute_values(
            cur,
            """INSERT INTO public.applies(
                    pcap_id, fn_id, wnum, wsize, wcount, wvalue)
                VALUES  %s;""",
            df_windows[['pcap_id', 'fn_id', 'wnum', 'wsize', 'wcount', 'wvalue']].values.tolist()
        )
        db.commit()
    pass #end batch



if __name__ == "__main__":

    max_top10m = utils.max_top10m(db)

    parser = argparse.ArgumentParser(description='Apply LLR window function.')
    parser.add_argument('--model', metavar="MODEL", type=str, required=True,
                        help='The model name.')
    parser.add_argument('--top10m', required=False,
                        type=int,
                        help=f'If a DN has a top10m rank lower than \'value\' then it will be zeroed. Between 0 and {max_top10m}')
    parser.add_argument('--wsize', required=False,
                        default=500,
                        type=int,
                        choices=[ 100, 500, 2500 ],
                        help=f'Windows size.')
    parser.add_argument('--windowing', required=False,
                        default="both",
                        choices=[ "both", "req", "res" ],
                        help=f'How windows are defined.')
    parser.add_argument('--positive-inf', required=False,
                        default=100,
                        type=int,
                        help=f'Replace value for positive infinite.')
    parser.add_argument('--negative-inf', required=False,
                        default=-100,
                        type=int,
                        help=f'Replace value for negative infinite.')
    parser.add_argument('--inf', required=False,
                        default=None,
                        type=int,
                        help=f'Replace absolute value for both infinite.')
    parser.add_argument('name', metavar="NAME", help='The name of this LLR window function.')
    args = parser.parse_args()

    if args.inf is not None:
        pinf = args.inf
        ninf = -args.inf
    else:
        pinf = args.positive_inf
        ninf = args.negative_inf

    model = utils.get_model(db, args.model)
    if model is None:
        print(f"Model [{args.model}] doesn't exists")
        exit(1)
    
    ###
    dn_number = utils.get_dn_number(db)
    inferenced_number = utils.get_inferenced_number(db, model['id'])
    if utils.get_dn_number(db) != utils.get_inferenced_number(db, model['id']):
        print(f"Mismatch between infereced and DN number: should be {dn_number} while it is {inferenced_number}")
        exit(1)
    ###

    fn = dict(name=args.name, nn_id=model["id"], top10m=args.top10m, windowing=args.windowing, pinf=pinf, ninf=ninf)

    ###
    fn_tmp = utils.get_fn(db, fn)
    
    if fn_tmp is None:
        yn = utils.get_yn("Function not exists, create it? [Y/n]")
        if yn == 'y':
            with db.cursor(cursor_factory=psycopg2.extras.DictCursor) as cur:
                cur.execute(
                    "INSERT INTO fns (name, fn_type, nn_id, top10m, windowing, pinf, ninf) VALUES (%s, 'llr', %s, %s, %s, %s, %s) RETURNING ID",
                    [ args.name, model['id'], args.top10m, args.windowing, pinf, ninf ]
                )
                fn["id"] = cur.fetchone()[0]
                db.commit()
        else:
            exit(0)
    else:
        fn = fn_tmp
    ###

    ###
    num_applied_windows = utils.count_applied_windows(db, fn['id'], args.wsize)
    if num_applied_windows > 0:
        yn = utils.get_yn(f"{num_applied_windows} already applied with '{fn['name']}' and wsize {args.wsize}, overwrite? [Y/n]")
        if yn == 'y':
            with db.cursor(cursor_factory=psycopg2.extras.DictCursor) as cur:
                cur.execute("DELETE FROM applies WHERE fn_id=%s", [ fn[0] ])
            print("Deleted previous apply.")
    ###

    run(fn, args.wsize)
    
    pass
