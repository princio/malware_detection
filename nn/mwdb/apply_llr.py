from re import DEBUG
from numpy.lib.arraysetops import unique
import psycopg2
from psycopg2.extras import execute_values
import pandas as pd
import math
import pprint
import argparse
import numpy as np
import utils

pp = pprint.PrettyPrinter(indent=4)

db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")

def psql_array_fns(df):
    cat = ('{' + df['first_fn'].astype(str) + ',' + df['last_fn'].astype(str) + '}').str.cat(sep=',')
    return f"{{{cat}}}"

def run(fn):

    pd.options.display.float_format = '{:.2f}'.format

    df_windows = pd.read_sql(
        f"""SELECT WINDOWS.*
            FROM WINDOWS
                LEFT JOIN APPLIES ON (WINDOWS.ID = APPLIES.WINDOW_ID AND APPLIES.FN_ID={fn["id"]})
            WHERE APPLIES.ID IS NULL
            ORDER BY pcap_id, "window" """,
        db,
    )

    batch_windows = 1000
    cur = db.cursor()
    for _, size in df_windows["size"].drop_duplicates().iteritems():
        for pcap_id in df_windows.pcap_id.drop_duplicates().values.tolist():
            df_w_pcap = df_windows[df_windows.pcap_id == pcap_id]

            print(f"Doing for pcap {pcap_id}: {df_w_pcap.shape[0]} windows")
            steps = math.ceil(df_w_pcap.shape[0] / batch_windows)
            for i in range(steps):
                print(f"Step {i+1}/{steps}...")

                df_w_pcap_batch = df_w_pcap.iloc[i:(i+1)*batch_windows].copy()

                tmp_first_fn = df_w_pcap_batch.iloc[0]['first_fn']
                tmp_last_fn = df_w_pcap_batch.iloc[-1]['last_fn']
                tmp_windowing = ("WHERE IS_RESPONSE IS %s " % ("FALSE" if fn["windowing"] == "req" else "TRUE")) if fn["windowing"] != "both" else ""
                query = f"""
                SELECT
                    MES.FN,
                    "value",
                    top10m,
                    LOGIT,
                    W.WINDOW
                FROM
                    MESSAGES_{pcap_id} AS MES
                    JOIN DN ON MES.DN_ID=DN.ID
                    JOIN DN_NN AS DI ON MES.DN_ID = DI.DN_ID AND NN_ID={fn["nn_id"]}
                    JOIN
                        (SELECT * FROM WINDOWS WHERE FIRST_FN >= {tmp_first_fn} AND LAST_FN <= {tmp_last_fn} AND PCAP_ID={pcap_id} AND "size"={size}) AS W
                        ON MES.FN>=W.FIRST_FN AND MES.FN<=W.LAST_FN
                    {tmp_windowing}
                ORDER BY FN"""

                print(query)
            
                exit(1)

                df_m = pd.read_sql(query, db)

                if fn["top10m"] is not None:
                    df_m['logit'] = df_m[['top10m', 'logit']].apply(lambda x: 0 if (x['top10m'] is not None and x['top10m'] <= fn['top10m']) else x['logit'], axis=1)
                
                a = df_m[(df_m['logit'] == np.inf) | (df_m['logit'] == -np.inf)]
                df_m['logit'] = df_m['logit'].apply(lambda logit: fn['pinf'] if logit == np.inf else (fn['ninf'] if logit == -np.inf else logit) )

                print(a.sort_values(by="logit", ascending=True))
                print(df_m.loc[a.index].sort_values(by="logit", ascending=True))

                df_final = df_m[['window', 'logit']].groupby(['window']).aggregate({ 'logit': 'sum' })

                df_final = df_final.reset_index().astype(int)

                df_final['fn_id'] = fn['id']

                execute_values(
                    cur,
                    """INSERT INTO public.applies(
                            window_id, fn_id, value)
                        VALUES  %s;""",
                    df_final[['window', 'fn_id', 'logit']].values.tolist()
                )
                db.commit()
            pass
        pass #end batch
    pass



if __name__ == "__main__":

    max_top10m = utils.max_top10m(db)

    parser = argparse.ArgumentParser(description='Apply LLR window function.')
    parser.add_argument('--model', metavar="MODEL", type=str, required=True,
                        help='The model name.')
    parser.add_argument('--top10m', required=False,
                        type=int,
                        help=f'If a DN has a top10m rank lower than \'value\' then it will be zeroed. Between 0 and {max_top10m}')
    parser.add_argument('--windowing', required=False,
                        default="both",
                        choices=[ "both", "req", "res" ],
                        help=f'How windows are defined.')
    parser.add_argument('--positive-inf', required=False,
                        default=100,
                        type=int,
                        help=f'Replace value for positive infinite.')
    parser.add_argument('--negative-inf', required=False,
                        default=-100,
                        type=int,
                        help=f'Replace value for negative infinite.')
    parser.add_argument('--inf', required=False,
                        default=None,
                        type=int,
                        help=f'Replace absolute value for both infinite.')
    parser.add_argument('name', metavar="NAME", help='The name of this LLR window function.')
    args = parser.parse_args()

    if args.inf is not None:
        pinf = args.inf
        ninf = -args.inf
    else:
        pinf = args.positive_inf
        ninf = args.negative_inf

    model = utils.get_model(db, args.model)
    if model is None:
        print(f"Model [{args.model}] doesn't exists")
        exit(1)
    
    ###
    dn_number = utils.get_dn_number(db)
    inferenced_number = utils.get_inferenced_number(db, model['id'])
    if utils.get_dn_number(db) != utils.get_inferenced_number(db, model['id']):
        print(f"Mismatch between infereced and DN number: should be {dn_number} while it is {inferenced_number}")
        exit(1)
    ###

    fn = dict(name=args.name, nn_id=model["id"], top10m=args.top10m, windowing=args.windowing, pinf=pinf, ninf=ninf)

    ###
    fn_tmp = utils.get_fn(db, fn)
    
    if fn_tmp is None:
        yn = utils.get_yn("Function not exists, create it? [Y/n]")
        if yn == 'y':
            with db.cursor(cursor_factory=psycopg2.extras.DictCursor) as cur:
                cur.execute(
                    "INSERT INTO fns (name, fn_type, nn_id, top10m, windowing, pinf, ninf) VALUES (%s, 'llr', %s, %s, %s, %s, %s) RETURNING ID",
                    [ args.name, model['id'], args.top10m, args.windowing, pinf, ninf ]
                )
                fn["id"] = cur.fetchone()[0]
                db.commit()
        else:
            exit(0)
    else:
        fn = fn_tmp
    ###

    ###
    num_windows = utils.count_windows(db)
    num_applied_windows = utils.count_applied_windows(db, fn['id'])
    if num_applied_windows > 0 and num_windows > num_applied_windows:
        yn = utils.get_yn(f"{num_applied_windows} already applied with '{fn['name']}', overwrite? [Y/n]")
        if yn == 'y':
            with db.cursor(cursor_factory=psycopg2.extras.DictCursor) as cur:
                cur.execute("DELETE FROM applies WHERE fn_id=%s", [ fn[0] ])
            print("Deleted previous apply.")
    ###

    run(fn)
    
    pass
