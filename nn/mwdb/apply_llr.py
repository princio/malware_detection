from re import DEBUG
from numpy.lib.arraysetops import unique
import psycopg2
from psycopg2.extras import execute_values
import pandas as pd
import sys
import math
import pprint
import time
import numpy as np

pp = pprint.PrettyPrinter(indent=4)

db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")

def psql_array_fns(df):
    cat = ('{' + df['first_fn'].astype(str) + ',' + df['last_fn'].astype(str) + '}').str.cat(sep=',')
    return f"{{{cat}}}"

def run(fn_type, nn_name = None):

    pd.options.display.float_format = '{:.2f}'.format

    if fn_type != 'nx':
        nn = pd.read_sql(
            f'SELECT * FROM nns WHERE name=\'{nn_name}\'',
            db,)
        if nn.empty:
            print(f"Wrong nn name: {nn_name}")
            exit(1)
        fn = pd.read_sql(
            f'SELECT * FROM fns WHERE fn_type=\'{fn_type}\' AND nn_id=\'{nn["id"]}\'',
            db,)
    else:
        fn = pd.read_sql(
            f'SELECT * FROM fns WHERE fn_type=\'nx\'',
            db,)

    if fn.empty:
        print(f"Wrong function: type={fn_type} and nn={nn_name}")
        exit(1)
    

    df_windows = pd.read_sql(
        """SELECT WINDOWS.*
            FROM WINDOWS
            LEFT JOIN APPLIES ON WINDOWS.ID = APPLIES.WINDOW_ID
            WHERE APPLIES.ID IS NULL
            ORDER BY pcap_id, "window" """,
        db,
    )
    
    batch_windows = 1000
    cur = db.cursor()
    for pcap_id in df_windows.pcap_id.drop_duplicates().values.tolist():
        df_w_pcap = df_windows[df_windows.pcap_id == pcap_id]

        print(f"Doing {fn_type} for pcap {pcap_id}: {df_w_pcap.shape[0]} windows")
        steps = math.ceil(df_w_pcap.shape[0] / batch_windows)
        for i in range(steps):
            print(f"Step {i}/{steps}...")

            df_w_pcap_batch = df_w_pcap.iloc[i:(i+1)*batch_windows].copy()

            wids = np.zeros((df_w_pcap_batch['r']).sum())
            begin = 0
            for _, row in df_w_pcap_batch.iterrows():
                offset = int(row['r'])
                wids[begin:begin+offset] = row['id']
                begin += offset

            df_m = pd.read_sql(
                """SELECT fn, (CASE WHEN rcode=3 THEN 1 ELSE 0 END) as v
                FROM messages_%d
                WHERE
                IS_RESPONSE is TRUE AND fn >= %d AND fn <= %d
                ORDER BY FN
                """ % (pcap_id, df_w_pcap_batch.iloc[0]['first_fn'], df_w_pcap_batch.iloc[-1]['last_fn']), db)

            df_m['w'] = wids

            bibo = df_m[['w', 'v']].groupby(['w']).aggregate({ 'v': 'sum' })

            bibo = bibo.reset_index().astype(int)

            bibo['fn_id'] = fn['id'].values[0]

            # with db.cursor() as cur2:
            #     if fn_type == 'nx':
            #         cur2.execute("""SELECT FUN_NX(%s, %s)""", (pcap_id, psql_array_fns(df_w_pcap_batch)))
            #         print(cur2.query)
            #     else:
            #         cur2.execute("""SELECT FUN_LLR(%s, %s, %s)""", (pcap_id, psql_array_fns(df_w_pcap_batch), nn['id'].values[0].item()))
            #     df_w_pcap_batch['v'] = cur2.fetchall()[0][0]
            
            # df_w_pcap_batch['fn_id'] = fn['id'].values[0]

            execute_values(
                cur,
                """INSERT INTO public.applies(
                        window_id, fn_id, value)
                    VALUES  %s;""",
                bibo[['w', 'fn_id', 'v']].values.tolist()
            )
            db.commit()
        pass #end batch
    pass



if __name__ == "__main__":
    if len(sys.argv) < 2:
        print('Too few arguments', sys.argv)
        exit(1)

    fn_type = sys.argv[1]

    if fn_type not in [ 'llr', 'llrt', 'nx' ]:
        print(f"Wrong fn type: {fn_type}")
    
    if fn_type == 'nx':
        run(fn_type)
    else:
        nn_name = sys.argv[2]
        run(fn_type, nn_name)
    
    pass
