from re import DEBUG
from numpy.lib.arraysetops import unique
import psycopg2
from psycopg2.extras import execute_values
import pandas as pd
import math
import pprint
import argparse
import numpy as np
import utils

pp = pprint.PrettyPrinter(indent=4)

db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")

def psql_array_fns(df):
    cat = ('{' + df['first_fn'].astype(str) + ',' + df['last_fn'].astype(str) + '}').str.cat(sep=',')
    return f"{{{cat}}}"

def run(fn):

    pd.options.display.float_format = '{:.2f}'.format

    df_windows = pd.read_sql(
        f"""SELECT WINDOWS.*
            FROM WINDOWS
                LEFT JOIN APPLIES ON (WINDOWS.ID = APPLIES.WINDOW_ID AND APPLIES.FN_ID={fn["id"]})
            WHERE APPLIES.ID IS NULL
            ORDER BY pcap_id, "window" """,
        db,
    )

    print(df_windows)

    batch_windows = 1000
    cur = db.cursor()
    for _, size in df_windows["size"].drop_duplicates().iteritems():
        for pcap_id in df_windows.pcap_id.drop_duplicates().values.tolist():
            df_w_pcap = df_windows[df_windows.pcap_id == pcap_id]

            print(f"Doing for pcap {pcap_id}: {df_w_pcap.shape[0]} windows")
            steps = math.ceil(df_w_pcap.shape[0] / batch_windows)
            for i in range(steps):
                print(f"Step {i+1}/{steps}...")

                df_w_pcap_batch = df_w_pcap.iloc[i:(i+1)*batch_windows].copy()

                print(df_w_pcap_batch)

                wids = np.zeros((df_w_pcap_batch['r']).sum())
                begin = 0
                for _, row in df_w_pcap_batch.iterrows():
                    offset = int(row['r'])
                    wids[begin:begin+offset] = row['id']
                    begin += offset

                tmp_first_fn = df_w_pcap_batch.iloc[0]['first_fn']
                tmp_last_fn = df_w_pcap_batch.iloc[-1]['last_fn']
                tmp_windowing = ("WHERE IS_RESPONSE IS %s " % ("FALSE" if fn["windowing"] == "req" else "TRUE")) if fn["windowing"] != "both" else ""
                query = f"""
                SELECT
                    MES.FN,
                    "value",
                    top10m,
                    LOGIT,
                    W.WINDOW
                FROM
                    MESSAGES_{pcap_id} AS MES
                    JOIN DN ON MES.DN_ID=DN.ID
                    JOIN DN_NN AS DI ON MES.DN_ID = DI.DN_ID AND NN_ID={fn["nn_id"]}
                    JOIN
                        (SELECT * FROM WINDOWS WHERE FIRST_FN >= {tmp_first_fn} AND LAST_FN <= {tmp_last_fn} AND PCAP_ID={pcap_id} AND "size"={size}) AS W
                        ON MES.FN>=W.FIRST_FN AND MES.FN<=W.LAST_FN
                    {tmp_windowing}
                ORDER BY FN"""

                df_m = pd.read_sql(query, db)

                if fn["top10m"] is not None:
                    df_m['logit'] = df_m.apply(lambda x: 0 if (x['top10m'] is not None and x['top10m'] <= fn['top10m']) else x['logit'], axis=1)

                bibo = df_m[['window', 'logit']].groupby(['w']).aggregate({ 'logit': 'sum' })

                bibo = bibo.reset_index().astype(int)

                bibo['fn_id'] = fn['id'].values[0]

                # with db.cursor() as cur2:
                #     if fn_type == 'nx':
                #         cur2.execute("""SELECT FUN_NX(%s, %s)""", (pcap_id, psql_array_fns(df_w_pcap_batch)))
                #         print(cur2.query)
                #     else:
                #         cur2.execute("""SELECT FUN_LLR(%s, %s, %s)""", (pcap_id, psql_array_fns(df_w_pcap_batch), nn['id'].values[0].item()))
                #     df_w_pcap_batch['v'] = cur2.fetchall()[0][0]
                
                # df_w_pcap_batch['fn_id'] = fn['id'].values[0]

                execute_values(
                    cur,
                    """INSERT INTO public.applies(
                            window_id, fn_id, value)
                        VALUES  %s;""",
                    bibo[['w', 'fn_id', 'v']].values.tolist()
                )
                db.commit()
            pass
        pass #end batch
    pass



if __name__ == "__main__":

    max_top10m = utils.max_top10m(db)

    parser = argparse.ArgumentParser(description='Apply LLR window function.')
    parser.add_argument('--model', metavar="MODEL", type=str, required=True,
                        help='The model name.')
    parser.add_argument('--top10m', required=False,
                        help=f'If a DN has a top10m rank lower than \'value\' then it will be zeroed. Between 0 and {max_top10m}')
    parser.add_argument('--windowing', required=False,
                        default="both",
                        choices=[ "both", "req", "res" ],
                        help=f'How windows are defined.')
    parser.add_argument('name', metavar="NAME", help='The name of this LLR window function.')
    args = parser.parse_args()


    model = utils.get_model(db, args.model)
    if model is None:
        print(f"Model [{args.model}] doesn't exists")
        exit(1)
    
    ###
    dn_number = utils.get_dn_number(db)
    inferenced_number = utils.get_inferenced_number(db, model['id'])
    if utils.get_dn_number(db) != utils.get_inferenced_number(db, model['id']):
        print(f"Mismatch between infereced and DN number: should be {dn_number} while it is {inferenced_number}")
        exit(1)
    ###

    ###
    fn = utils.get_fn(db, args.name, model["id"], args.top10m, args.windowing)
    
    if fn is None:
        yn = utils.get_yn("Function not exists, create it? [Y/n]")
        if yn == 'y':
            with db.cursor(cursor_factory=psycopg2.extras.DictCursor) as cur:
                cur.execute(
                    "INSERT INTO fns (name, fn_type, nn_id, top10m, windowing) VALUES (%s, 'llr', %s, %s, %s)",
                    [ args.name, model['id'], args.top10m, args.windowing ]
                )
                db.commit()
        else:
            exit(0)
    fn = utils.get_fn(db, args.name, model["id"], args.top10m, args.windowing)
    ###

    ###
    num_windows = utils.count_windows(db)
    num_applied_windows = utils.count_applied_windows(db, fn['id'])
    if num_applied_windows > 0 and num_windows > num_applied_windows:
        yn = utils.get_yn(f"{num_applied_windows} already applied with '{fn['name']}', overwrite? [Y/n]")
        if yn == 'y':
            with db.cursor(cursor_factory=psycopg2.extras.DictCursor) as cur:
                cur.execute("DELETE FROM applies WHERE fn_id=%s", [ fn[0] ])
            print("Deleted previous apply.")
    ###

    run(fn)
    
    pass
