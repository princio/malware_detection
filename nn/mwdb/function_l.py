from re import DEBUG
import psycopg2
import pandas as pd
from function_g import function_g
import utils
from sqlalchemy import create_engine
import numpy as np

eng = create_engine("postgresql://postgres:postgres@localhost/dns",)
db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")

def __test_1(cms_ths):
    """
    Tests if:
        - TN + FP is equal thorugh all the confusion matrixs.
        - FN + TP is equal thorugh all the confusion matrixs, for any dga.
    """
    cm = cms_ths[0]
    n = cm[0] + cm[1]
    p = sum([cm[2][dga] + cm[3][dga] for dga in [ 1, 2, 3 ]])
    
    for cm in cms_ths:
        if cm[0] + cm[1] != n:
            raise f"Exception N"
        if p != sum([cm[2][dga] + cm[3][dga] for dga in [ 1, 2, 3 ]]):
            raise Exception(f"Exception P")
        if (cm[2][0] + cm[3][0]) != sum([cm[2][dga] + cm[3][dga] for dga in [ 1, 2, 3 ]]):
            raise Exception(f"Exception P")
    pass

def function_l(df_f, nth):
    """
    Input:
        - df_f: an F-Dataframe.
        - nth:  the number of threshold chosen linearly within the domain used to
                calculate the confusion matrixs.
    
    Ouput:
        - cms: an nth array of confusion matrixs.
    
    Given an F-Dataframe, returns an nth array of confusion matrixs.
    Each confusion matrix is calculated using the F-Dataframe and a threshold th.
    The nth thresholds are obtained from the domain:
        [ df_f.wvalue.min(), df_f.wvalue.max() ]
    and chosen linearly in this domain.

    Each confusion matrix has this format:
        [ TN, FP, [ FN0, FN1, FN2, FN3 ], [ TP0, TP1, TP2, TP3 ] ]
    """
    cms = []

    ths = np.linspace(df_f.wvalue.min(), df_f.wvalue.max(), num=nth, dtype=np.float32)

    p = { 0: sum(df_f.dga > 0)}
    p = p | { dga: sum(df_f.dga == dga) for dga in [ 1, 2, 3 ] }
    n = sum(df_f.dga == 0)
    
    for th in ths:
        cms.append(function_g(df_f, th, n, p))
        pass
    
    __test_1(cms)
    
    return cms