from re import DEBUG
import psycopg2
import pandas as pd
from sqlalchemy import create_engine
import numpy as np

eng = create_engine("postgresql://postgres:postgres@localhost/dns",)
db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")

dgas = [ 0, 1, 2, 3 ]


TN = 0
FP = 1
FN = 2
TP = 3

#
# this function works with more configs
# input:
#       metrics:     array of metrics, one per each config
#       th2s:        [ 0.25, 0.5, 0.75 ]
# output:
#       cms:        [ cm_th0, cm_th1, ..., cm_thn, ]
def function_s(configs, metricss, metrics, var):

    df_configs = pd.DataFrame([{ ('config', k) : v  for k,v in config.__dict__.items() } for config in configs ])
    df_metricss = pd.DataFrame([{ (k1, k2): d2 for k1, d1 in metrics.items() for k2, d2 in d1.items() } for metrics in metricss ])

    df = pd.concat([df_configs, df_metricss], axis=1)

    df.columns = pd.MultiIndex.from_tuples(df.columns)


    fixed_config = [ col for col in df.columns if col[0] == 'config' and col[1] != var ]

    df  = df.sort_values(by=fixed_config + [('config', var)])
    df  = df.set_index(fixed_config)

    stats = []
    for i in df.index.drop_duplicates():
        stat = {}
        for metric in metrics:
            _df_ = df.loc[i].sort_values(metric, ascending=False)
            print(_df_[metric].to_numpy())
            stat[( metric, 'mean' )] = _df_[metric].mean()
            stat[( metric, 'std' )] = _df_[metric].std()
            stat[( metric, 'best' )] = _df_[('config', var)].iloc[0]
            # print(_df_)
            pass
        stats.append(stat)
        pass
    
    df_s = pd.DataFrame(stats)

    df_s.columns = pd.MultiIndex.from_tuples(df_s.columns)

    df_s = df_s.round(3)

    dbts = []
    for metric in metrics:
        dbt = {}

        dbt[('mean', 'mean')] = df_s[(metric, 'mean')].mean()
        dbt[('mean', 'max')] = df_s[(metric, 'mean')].max()
        dbt[('mean', 'min')] = df_s[(metric, 'mean')].min()

        dbt[('std', 'mean')] = df_s[(metric, 'std')].mean()
        dbt[('std', 'max')] = df_s[(metric, 'std')].max()
        dbt[('std', 'min')] = df_s[(metric, 'std')].min()

        dbt[('std', '%min')] = (100 * (df_s[(metric, 'std')] / df_s[(metric, 'mean')]).min())
        dbt[('std', '%max')] = (100 * (df_s[(metric, 'std')] / df_s[(metric, 'mean')]).max())
        dbt[('std', '%mean')] = (100 * (df_s[(metric, 'std')] / df_s[(metric, 'mean')]).mean())

        dbt[('best', '1')] = ', '.join([ f'{k[0]}' for i, k in enumerate(df_s[(metric, 'best')].value_counts().iteritems()) ])

        dbts.append(dbt)

        pass

    df_compare = pd.DataFrame(dbts, index=metrics)

    df_compare.columns = pd.MultiIndex.from_tuples(df_compare)

    return df_compare