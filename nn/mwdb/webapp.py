from flask import Flask, request, send_from_directory
from flask_cors import CORS, cross_origin
import os
import json
import psycopg2
import psycopg2.extras
import pandas as pd
import apply as apply_lib
import threading
import utils

apply_threads = {}

app = Flask(__name__)
CORS(app)
DIR_CSV = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'csv')

db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")


@app.route('/csv/<string:filename>')
@cross_origin()
def send_json(filename):
    return send_from_directory(DIR_CSV, filename, as_attachment=False)


@app.route('/mwdb/pcap')
@cross_origin()
def get_pcaps():

    df = pd.read_sql("""SELECT * FROM pcap""", db)

    df = df.drop(columns='hash')

    return {
        'header': df.columns.tolist(),
        'values': df.values.tolist() #.to_json(orient='values')
    }


@app.route('/mwdb/pcap/json')
@cross_origin()
def get_pcaps_json():

    df = pd.read_sql("""SELECT * FROM pcap""", db)

    return df.to_json(orient='records')


@app.route('/mwdb/apply/get/<apply_id>', methods = ['GET'])
@cross_origin()
def get_apply(apply_id):
    with db.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
        cur.execute("""
            SELECT *
                FROM applies
                WHERE
                id=%s""",
            [ apply_id ])
        apply = cur.fetchone()
        pass

    summer = utils.apply_qr_count(db, apply_id)
    apply['check'] = summer['wsum'] == summer['psum']

    return { "apply": apply }


@app.route('/mwdb/applies')
@cross_origin()
def get_applies():

    df = pd.read_sql(
        """SELECT a.*, max(w.wvalue), min(w.wvalue) FROM applies as a
            JOIN windows as w
            ON a.id=w.apply_id
            GROUP BY a.id""",
        db).fillna("--")

    df['check'] = None

    for i, a in df.iterrows():
        summer = utils.apply_qr_count(db, a['id'])
        df.at[i, 'check'] = summer['wsum'] == summer['psum']

    return {
        "applies": df.to_dict(orient='records')
    }

@app.route('/mwdb/apply/<apply_id>', methods = ['POST'])
@cross_origin()
def apply_fetch(apply_id, rounder=10):

    if 'rounder' in request.get_json() and type(request.get_json()['rounder']) == int:
        rounder = request.get_json()['rounder']

    with db.cursor() as cur:
        cur.execute("""
            SELECT MAX(WVALUE), MIN(WVALUE)
                FROM windows
                WHERE
                apply_id=%s""",
            [ apply_id ])
        bounds = cur.fetchone()
        rounder = int((bounds[0] - bounds[1])/rounder)
        pass

    df = pd.read_sql(f"""
        SELECT COUNT(*) AS WCOUNT,
            COUNT(DISTINCT PCAP_ID) AS PCAPS,
            MW.DGA,
            WVALUE
        FROM
            (SELECT 
                    PCAP_ID,
                    ROUND(WVALUE::float / {rounder}) * {rounder} AS WVALUE
                FROM WINDOWS
                WHERE APPLY_ID={apply_id}) AS W
        JOIN PCAP AS P ON W.PCAP_ID = P.ID
        JOIN MALWARE AS MW ON MW.ID = P.MALWARE_ID
        GROUP BY WVALUE, DGA;""", db)

    with db.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
        cur.execute("""
            SELECT *
                FROM applies
                WHERE
                id=%s""",
            [ apply_id ])
        apply = cur.fetchone()
        pass

    # with db.cursor() as cur:
    #     cur.execute(f"""
    #         SELECT 
    #         MIN(ABS(W.WVALUE - W2.WVALUE))::integer AS "MIN",
    #         MAX(ABS(W.WVALUE - W2.WVALUE))::integer AS "MAX",
    #         AVG(ABS(W.WVALUE - W2.WVALUE))::integer AS "AVG"
    #         FROM WINDOWS AS W
    #         LEFT JOIN WINDOWS AS W2 ON W.PCAP_ID = W2.PCAP_ID
    #         AND W.WNUM = (W2.WNUM-1)
    #         AND W.APPLY_ID = W2.APPLY_ID
    #         WHERE W.APPLY_ID=%s
    #         """,
    #         [ apply_id ])
    #     steps = cur.fetchone()
    #     steps = dict(zip(['min','max','avg'], steps))
    #     pass

    return {
        "apply": apply,
        # "steps": steps,
        "values": df.values.tolist(),
        "columns": df.columns.tolist()
    }

@app.route('/mwdb/apply/check/<apply_id>', methods = ['GET'])
@cross_origin()
def apply_check(apply_id):

    summer = utils.apply_qr_count(db, apply_id)

    return {
        'wsum': summer['wsum'],
        'psum': summer['psum'],
        'check': summer['wsum'] == summer['psum']
    }
    


@app.route('/mwdb/apply/exec/<apply_id>', methods = ['POST'])
@cross_origin()
def apply_exec(apply_id):

    with db.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
        cur.execute("""
            SELECT *
                FROM applies
                WHERE
                id=%s""",
            [ apply_id ])
        apply = cur.fetchone()
        pass
    
    executing = 'none'
    message = ''
    if apply_id not in apply_threads:
        apply_threads[apply_id] = threading.Thread(target=apply_lib.run, args=(apply,))
        apply_threads[apply_id].start()
        message = 'Execution started.'
        executing = 'started'
    else:
        if apply_threads[apply_id].is_alive():
            message = 'Executing...'
            executing = 'progress'
        else:
            message = 'Done.'
            executing = 'success'

    return {
        'executing': executing,
        'message': message
    }

if __name__ == "__main__":
    app.run(port=3000, debug=True)