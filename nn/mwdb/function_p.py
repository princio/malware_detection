from re import DEBUG
import psycopg2
import pandas as pd
import utils
from sqlalchemy import create_engine
import numpy as np

eng = create_engine("postgresql://postgres:postgres@localhost/dns",)
db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")

dgas = [ 0, 1, 2, 3 ]


def cmss_to_df(cmss):
    df_cmss = pd.DataFrame()

    df_cmss[('N', 'tn')] = np.asarray([ cm[0] for cms in cmss for cm in cms ])
    df_cmss[('N', 'fp')] = np.asarray([ cm[1] for cms in cmss for cm in cms ])

    for dga in [ 0, 1, 2, 3 ]:
        df_cmss[( dga, 'fn' )] = np.asarray([ cm[2][dga] for cms in cmss for cm in cms ])
        df_cmss[( dga, 'tp' )] = np.asarray([ cm[3][dga] for cms in cmss for cm in cms ])

    df_cmss.columns = pd.MultiIndex.from_tuples(df_cmss.columns.to_list())

    return df_cmss



def cms_to_df(cms):
    df_cms = pd.DataFrame()

    df_cms[('N', 'tn')] = np.asarray([ cm[0] for cm in cms ])
    df_cms[('N', 'fp')] = np.asarray([ cm[1] for cm in cms ])

    for dga in [ 0, 1, 2, 3 ]:
        df_cms[( dga, 'fn' )] = np.asarray([ cm[2][dga] for cm in cms ])
        df_cms[( dga, 'tp' )] = np.asarray([ cm[3][dga] for cm in cms ])

    df_cms.columns = pd.MultiIndex.from_tuples(df_cms.columns.to_list())

    return df_cms


TN = 0
FP = 1
FN = 2
TP = 3


# input:
#       cms:         array of cm, one per threshold: [tn, fp, [fn0, fn1, fn2, fn3], [tp0, tp1, tp2, tp3]]
#       th2s:        [ 0.25, 0.5, 0.75 ]
# output:
#       metrics:     - dga
#                       - tn2+tp2:  sqrt(tn^2 + tp^2)
#                       - tn,tp
#                       - th2s:
#                           - th2: % of contiguos th in ths where (tn > th2 and tp > th2)
def function_p(cms, th2s):

    n = cms[0][TN] + cms[0][FP]
    p = {
        dga: cms[0][FN][dga] + cms[0][TP][dga]
        for dga in dgas
    }

    df_cms = pd.DataFrame()

    df_cms[('N', 'tn')] = np.asarray([ cm[0] for cm in cms ])
    df_cms[('N', 'fp')] = np.asarray([ cm[1] for cm in cms ])

    for dga in [ 0, 1, 2, 3 ]:
        df_cms[( dga, 'fn' )] = np.asarray([ cm[2][dga] for cm in cms ])
        df_cms[( dga, 'tp' )] = np.asarray([ cm[3][dga] for cm in cms ])

    df_cms.columns = pd.MultiIndex.from_tuples(df_cms.columns.to_list())


    df_cms_relative = df_cms.copy()
    for column in df_cms.columns:
        if column[0] == 'N':
            df_cms_relative[column] = df_cms[column] / n
        else:
            df_cms_relative[column] = (df_cms[column] / p[column[0]]) if p[column[0]] > 0 else 0

    df_cms_relative = df_cms_relative[[('N', 'tn')] + [(dga, 'tp') for dga in dgas]]

    metrics = {}
    for dga in dgas:
        # k: a series of sqrt(tn^2 + tp^2)
        s_tn2tnp2 = (df_cms_relative[('N', 'tn')].pow(2) + df_cms_relative[(dga, 'tp')].pow(2)).pow(1/2)

        max_tn2tnp2 = s_tn2tnp2.idxmax()
        
        tn_max = df_cms_relative[('N', 'tn')].iloc[max_tn2tnp2]
        tp_max = df_cms_relative[(dga, 'tp')].iloc[max_tn2tnp2]

        metrics[dga] = {
            'tn2+tp2': s_tn2tnp2.max(),
            'tn_max': tn_max,
            'tp_max': tp_max
        }

        for th2 in th2s:
            df_th2 = pd.DataFrame({
                'tn': df_cms_relative[('N', 'tn')] >= th2,
                'tp': df_cms_relative[(dga, 'tp')] >= th2
            })
            
            # select the longest group of consecutive wvalues greaters then th2
            s = df_th2['tn'] & df_th2['tp']
            s = s.cumsum()-s.cumsum().where(~s).ffill().fillna(0).astype(int)
            metrics[dga][th2] = s.max() / s.shape[0]

            pass

    return metrics