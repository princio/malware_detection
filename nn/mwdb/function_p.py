from distutils.command.config import config
import pickle
import json
from re import DEBUG
import sys
import psycopg2
import pandas as pd
from sqlalchemy import create_engine
import numpy as np
import matplotlib.pyplot as plt

eng = create_engine("postgresql://postgres:postgres@localhost/dns",)
db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")

dgas = [ 0, 1, 2, 3 ]


def load(config_hash, nth=200):
    df_f = pd.read_csv(f'./functions_output/f/{config_hash}.csv')

    path_f = f'./functions_output/f/{config_hash}.pickle'
    with open(path_f, 'rb') as f:
        cms_ths = pickle.load(f)

    ths = np.linspace(df_f.wvalue.min(), df_f.wvalue.max(), num=nth, dtype=np.float32)

    return df_f, cms_ths, ths

def cmss_to_df(cmss):
    df_cmss = pd.DataFrame()

    df_cmss[('N', 'tn')] = np.asarray([ cm[0] for cms in cmss for cm in cms ])
    df_cmss[('N', 'fp')] = np.asarray([ cm[1] for cms in cmss for cm in cms ])

    for dga in [ 0, 1, 2, 3 ]:
        df_cmss[( dga, 'fn' )] = np.asarray([ cm[2][dga] for cms in cmss for cm in cms ])
        df_cmss[( dga, 'tp' )] = np.asarray([ cm[3][dga] for cms in cmss for cm in cms ])

    df_cmss.columns = pd.MultiIndex.from_tuples(df_cmss.columns.to_list())

    return df_cmss



def cms_to_df(cms):
    df_cms = pd.DataFrame()

    df_cms[('N', 'tn')] = np.asarray([ cm[0] for cm in cms ])
    df_cms[('N', 'fp')] = np.asarray([ cm[1] for cm in cms ])

    for dga in [ 0, 1, 2, 3 ]:
        df_cms[( dga, 'fn' )] = np.asarray([ cm[2][dga] for cm in cms ])
        df_cms[( dga, 'tp' )] = np.asarray([ cm[3][dga] for cm in cms ])

    df_cms.columns = pd.MultiIndex.from_tuples(df_cms.columns.to_list())

    return df_cms


TN = 0
FP = 1
FN = 2
TP = 3


def get_cms_relative(cms):
    n = cms[0][TN] + cms[0][FP]
    p = {
        dga: cms[0][FN][dga] + cms[0][TP][dga]
        for dga in dgas
    }

    df_cms = pd.DataFrame()

    df_cms[('N', 'tn')] = np.asarray([ cm[0] for cm in cms ])
    df_cms[('N', 'fp')] = np.asarray([ cm[1] for cm in cms ])

    for dga in [ 0, 1, 2, 3 ]:
        df_cms[( dga, 'fn' )] = np.asarray([ cm[2][dga] for cm in cms ])
        df_cms[( dga, 'tp' )] = np.asarray([ cm[3][dga] for cm in cms ])


    

    # cms = [
    #     np.asarray([ cm[0] for cm in cms ]),
    #     np.asarray([ cm[1] for cm in cms ]),
    #     [ np.asarray([ cm[2][dga] for cm in cms ]) for dga in [ 0, 1, 2, 3 ] ],
    #     [ np.asarray([ cm[3][dga] for cm in cms ]) for dga in [ 0, 1, 2, 3 ] ]
    # ]

    cms_relative = [
        np.asarray([ cm[0] for cm in cms ]),
        np.asarray([ cm[1] for cm in cms ]),
        [ np.asarray([ cm[2][dga] for cm in cms ]) for dga in [ 0, 1, 2, 3 ] ],
        [ np.asarray([ cm[3][dga] for cm in cms ]) for dga in [ 0, 1, 2, 3 ] ]
    ]

    cms_relative = [
        cms_relative[TN] / n,
        cms_relative[FP] / n,
        [ cms_relative[FN][dga] / p[dga] for dga in [ 0, 1, 2, 3 ] ],
        [ cms_relative[TP][dga] / p[dga] for dga in [ 0, 1, 2, 3 ] ],
    ]

    return cms_relative


def function_p(cms, ths, plot=False) -> dict:
    """
    Input:
        - cms: an nth array of confusion matrixs.
        - th2s: an array thresholds indicating the minimum value that tn and tp should have.
    
    Output:
        - metrics: a dictionary of metrics.

    Given an array of confusion matrixs, it calculates the following metrics:
        - for each dga:
            - tn2+tp2:  the maxinum value of sqrt(tn^2 + tp^2)
            - tn,tp:    the maxinum value of tn,tp
            - for each th2 in th2s:
                - the maxinum domain portion of contiguos th where (tn > th2 and tp > th2)
    
    Returns an array of metrics:
        [ ]
    """

    cms_relative = get_cms_relative(cms)

    if plot:
        _, axs = plt.subplots(4, figsize=(5, 10))
        plt.tight_layout()

    metrics = {}

    nth = len(cms_relative[TN])
    for dga in dgas:
        metrics[dga] = {}

        step = ths[1] - ths[0]
        aree = []

        tns = cms_relative[TN]
        tps = cms_relative[TP][dga]

        y = [ tns[i] if (tns[i] < tps[i]) else tps[i] for i in range(nth) ]
        
        area_sottesa = sum([ y[i] * step for i in range(nth) ])
        area_totale  = ths[-1] - ths[0]

        tn_above = cms_relative[TN] >= 0.5
        tp_above = cms_relative[TP][dga] >= 0.5
        
        s = pd.Series(tn_above & tp_above) # select the longest group of consecutive wvalues greaters then th2
        s = s.cumsum()-s.cumsum().where(~s).ffill().fillna(0).astype(int)

        metrics[dga][0.5] = s.max() / s.shape[0]
        
        metrics[dga]['integrale'] = area_sottesa / area_totale

        if plot:
            axs[dga].set_title('dga=%d, %0.2f' % (dga, area_sottesa / area_totale))
            axs[dga].plot(ths, cms_relative[TN])
            axs[dga].plot(ths, cms_relative[TP][dga])
            axs[dga].plot(ths, y)

    if plot:
        plt.show()

    return metrics


def annot(df, th2s, nth, tp, thmin, thmax, ax):
    for th2 in th2s:

        s = (df['tn'] > th2) & (df[tp] > th2)

        c = 0
        start = 0
        maxg = 0
        group = []
        for i, a in s.iteritems():
            if c == 0 and a != 0:
                start = i
            if c != 0 and a == 0:
                if maxg < c:
                    group = [ start, i ]
                c = 0
            c = a + c

        if group != []:
            th_start = df.th[group[0] - 1 if group[0] > 0 else group[0]]
            th_end = df.th[group[1] + 1 if group[1] > nth else group[1]]


            ax.annotate('', xy=(th_start, th2), xytext=(th_end, th2), arrowprops=dict(arrowstyle='<->', linewidth=0.5))
            ax.annotate(f'$th_2={th2:.2f}$', xy=(-36000, th2), horizontalalignment='center', verticalalignment='top')
            ax.annotate('%0.2f' % ((th_end - th_start)/(thmax-thmin)), xy=(th_start + (th_end - th_start) / 2, th2 - 0.07), fontsize=8, horizontalalignment='center', verticalalignment='center')

        pass

def plot_(cms_ths, ths):

    df = pd.DataFrame()
    df['th'] = ths
    df['tn'] = [ cm[TN] for cm in cms_ths ]
    df['tn'] = df['tn'] / (cms_ths[0][TN] +  cms_ths[0][FP])

    for dga in [ 0,1,2,3 ]:
        df['tp_%d' % dga] = [ cm[TP][dga] for cm in cms_ths ]
        df['tp_%d' % dga] = df['tp_%d' % dga] / (cms_ths[0][TP][dga] +  cms_ths[0][FN][dga])
        df['tn*tp_%d' % dga] = df.tn * df['tp_%d' % dga]

    fig, axs = plt.subplots(4)
    for dga in [ 0,1,2,3 ]:
        df.plot(x='th', y=['tn', 'tp_%d' % dga], ax=axs[dga])
        df.plot(x='th', y=['tn*tp_%d' % dga], style='.', ax=axs[dga])
        annot(df, th2s, configs['nth'], 'tp_%d' % dga, df.th.min(), df.th.max(), axs[dga])

    plt.show()

    pass

if __name__ == "__main__":

    with open('functions_output/configs.json', 'r') as fp:
        configs = json.load(fp)


    th2s = [ 0.25, 0.5, 0.75 ]
    for config_hash in configs:
        if config_hash in [ 'th2s', 'nth' ]: continue

        df_f, cms_ths, ths = load(config_hash)

        metrics = function_p(cms_ths, ths, plot=True)

        # for dga in [ 0, 1, 2, 3 ]:
        #     plot_(cms_ths, ths)
        #     if metrics[dga][0.50] > metrics[dga][0.25]:
        #         print(dga, '0.50 > 0.25', metrics[dga][0.50], metrics[dga][0.25])
        #     if metrics[dga][0.75] > metrics[dga][0.50]:
        #         print(dga, '0.75 > 0.50', metrics[dga][0.50], metrics[dga][0.75])
        #     if metrics[dga][0.75] > metrics[dga][0.25]:
        #         print(dga, '0.75 > 0.25', metrics[dga][0.75], metrics[dga][0.25])
        #     pass
        pass

    hashes = list(configs.keys())

    config_hash = hashes[int(sys.argv[1])]
    