from re import DEBUG
import psycopg2
import pandas as pd
import utils
from sqlalchemy import create_engine
import numpy as np

eng = create_engine("postgresql://postgres:postgres@localhost/dns",)
db = psycopg2.connect("host=localhost dbname=dns user=postgres password=postgres")

dgas = [ 0, 1, 2, 3 ]


def cmss_to_df(cmss):
    df_cmss = pd.DataFrame()

    df_cmss[('N', 'tn')] = np.asarray([ cm[0] for cms in cmss for cm in cms ])
    df_cmss[('N', 'fp')] = np.asarray([ cm[1] for cms in cmss for cm in cms ])

    for dga in [ 0, 1, 2, 3 ]:
        df_cmss[( dga, 'fn' )] = np.asarray([ cm[2][dga] for cms in cmss for cm in cms ])
        df_cmss[( dga, 'tp' )] = np.asarray([ cm[3][dga] for cms in cmss for cm in cms ])

    df_cmss.columns = pd.MultiIndex.from_tuples(df_cmss.columns.to_list())

    return df_cmss



def cms_to_df(cms):
    df_cms = pd.DataFrame()

    df_cms[('N', 'tn')] = np.asarray([ cm[0] for cm in cms ])
    df_cms[('N', 'fp')] = np.asarray([ cm[1] for cm in cms ])

    for dga in [ 0, 1, 2, 3 ]:
        df_cms[( dga, 'fn' )] = np.asarray([ cm[2][dga] for cm in cms ])
        df_cms[( dga, 'tp' )] = np.asarray([ cm[3][dga] for cm in cms ])

    df_cms.columns = pd.MultiIndex.from_tuples(df_cms.columns.to_list())

    return df_cms


TN = 0
FP = 1
FN = 2
TP = 3


def function_p(cms, th2s) -> dict:
    """
    Input:
        - cms: an nth array of confusion matrixs.
        - th2s: an array thresholds indicating the minimum value that tn and tp should have.
    
    Output:
        - metrics: a dictionary of metrics.

    Given an array of confusion matrixs, it calculates the following metrics:
        - for each dga:
            - tn2+tp2:  the maxinum value of sqrt(tn^2 + tp^2)
            - tn,tp:    the maxinum value of tn,tp
            - for each th2 in th2s:
                - the maxinum domain portion of contiguos th where (tn > th2 and tp > th2)
    
    Returns an array of metrics:
        [ ]
    """

    n = cms[0][TN] + cms[0][FP]
    p = {
        dga: cms[0][FN][dga] + cms[0][TP][dga]
        for dga in dgas
    }

    df_cms = pd.DataFrame()

    df_cms[('N', 'tn')] = np.asarray([ cm[0] for cm in cms ])
    df_cms[('N', 'fp')] = np.asarray([ cm[1] for cm in cms ])

    for dga in [ 0, 1, 2, 3 ]:
        df_cms[( dga, 'fn' )] = np.asarray([ cm[2][dga] for cm in cms ])
        df_cms[( dga, 'tp' )] = np.asarray([ cm[3][dga] for cm in cms ])


    

    # cms = [
    #     np.asarray([ cm[0] for cm in cms ]),
    #     np.asarray([ cm[1] for cm in cms ]),
    #     [ np.asarray([ cm[2][dga] for cm in cms ]) for dga in [ 0, 1, 2, 3 ] ],
    #     [ np.asarray([ cm[3][dga] for cm in cms ]) for dga in [ 0, 1, 2, 3 ] ]
    # ]

    cms_relative = [
        np.asarray([ cm[0] for cm in cms ]),
        np.asarray([ cm[1] for cm in cms ]),
        [ np.asarray([ cm[2][dga] for cm in cms ]) for dga in [ 0, 1, 2, 3 ] ],
        [ np.asarray([ cm[3][dga] for cm in cms ]) for dga in [ 0, 1, 2, 3 ] ]
    ]

    cms_relative = [
        cms_relative[TN] / n,
        cms_relative[FP] / n,
        [ cms_relative[FN][dga] / p[dga] for dga in [ 0, 1, 2, 3 ] ],
        [ cms_relative[TP][dga] / p[dga] for dga in [ 0, 1, 2, 3 ] ],
    ]

    metrics = {}
    for dga in dgas:
        # k: a series of sqrt(tn^2 + tp^2)
        s_tn2tnp2 = (cms_relative[TN] ** 2 + cms_relative[TP][dga] ** 2) ** 0.5

        max_tn2tnp2 = s_tn2tnp2.argmax()
        
        tn_max = cms_relative[TN][max_tn2tnp2]
        tp_max = cms_relative[TP][dga][max_tn2tnp2]

        metrics[dga] = {
            'tn2+tp2': s_tn2tnp2.max(),
            'tn_max': tn_max,
            'tp_max': tp_max
        }

        for th2 in th2s:

            tn_above = cms_relative[TN] >= th2
            tp_above = cms_relative[TP][dga] >= th2
            
            # select the longest group of consecutive wvalues greaters then th2
            s = pd.Series(tn_above & tp_above)

            s = s.cumsum()-s.cumsum().where(~s).ffill().fillna(0).astype(int)

            metrics[dga][th2] = s.max() / s.shape[0]

            pass

    return metrics