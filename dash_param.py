import math
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from dash.dependencies import Input, Output
from plotly.subplots import make_subplots
import sqlite3
import pandas as pd
import plotly.express as px
import numpy as np
import plotly.graph_objects as go
import os


db_path = '/media/princio/ssd512/stratosphere/db_3.sqlite3'
dirs = {
    'malware': '/media/princio/ssd512/stratosphere/pcap/csv/malware/',
    'normal': '/media/princio/ssd512/stratosphere/pcap/csv/normal/'
}
pcap_dict = {'normal':{}, 'botnet':{}}
pcap_names = {'normal':{}, 'botnet':{}}

def get_type(pcapname):
    bot_path = os.path.join(dirs['malware'], pcapname)
    nor_path = os.path.join(dirs['normal'], pcapname)
    if os.path.exists(bot_path):
        type_='botnet'
        df_path = bot_path
    elif os.path.exists(nor_path):
        type_='normal'
        df_path = nor_path
    else:
        raise Exception(pcapname + ' does not exists.')
    return type_, df_path

def get_df(pcapname, reload=False):
    if reload:
        type_, df_path = get_type(pcapname)
        pcap_dict[type_][pcapname] = pd.read_csv(df_path, usecols=list(range(0,12)))
        return pcap_dict[type_][pcapname]
    
    if pcapname in pcap_dict['botnet']:
        return pcap_dict['botnet'][pcapname]
    if pcapname in pcap_dict['normal']:
        return pcap_dict['normal'][pcapname]
    
    type_, df_path = get_type(pcapname)
    pcap_dict[type_][pcapname] = pd.read_csv(df_path, usecols=[2, 3, 6, 8, 9, 10, 11])
    return pcap_dict[type_][pcapname].copy()



db = sqlite3.connect(db_path)
df_pcaps = pd.read_sql('SELECT * from pcap', db)
df_app = pd.read_sql('SELECT * from pcap_queries_3', db)
db.close()


df_pcaps = df_pcaps.drop(columns=['s_id', 's_win', 'qry/h'])
df_pcaps.set_index('id', inplace=True, drop=False)

df_app.set_index('query', inplace=True, drop=False)



app = dash.Dash(__name__)

print(df_app)

app.layout = html.Div([
        html.Div([
            dash_table.DataTable(
                id='left-datatable-row-ids',
                columns=[
                    {'name': i, 'id': i, 'deletable': True} for i in df_pcaps.columns if i != 'id'
                ],
                data=df_pcaps.to_dict('records'),
                editable=True,
                filter_action="native",
                sort_action="native",
                sort_mode='multi',
                row_selectable='multi',
                row_deletable=True,
                selected_rows=[],
                page_action='none',
                style_table={'height': '300px', 'overflowY': 'auto', 'overflowX': 'auto'},
                style_cell={
                    'overflow': 'hidden',
                    'textOverflow': 'ellipsis',
                    'maxWidth': 0
                }
            ),
            html.Div(id='left-datatable-row-ids-container')
        ],
        style={'width': '50%'}),
        html.Div([
            dash_table.DataTable(
                id='right-datatable-row-ids',
                columns=[
                    {'name': i, 'id': i, 'deletable': True} for i in df_pcaps.columns if i != 'id'
                ],
                data=df_pcaps.to_dict('records'),
                editable=True,
                filter_action="native",
                sort_action="native",
                sort_mode='multi',
                row_selectable='multi',
                row_deletable=True,
                selected_rows=[],
                page_action='none',
                style_table={'height': '300px', 'overflowY': 'auto', 'overflowX': 'auto'},
                style_cell={
                    'overflow': 'hidden',
                    'textOverflow': 'ellipsis',
                    'maxWidth': 0
                }
            ),
            html.Div(id='right-datatable-row-ids-container')
        ],
        style={'width': '50%'})
    ],
    style={'display': 'flex', 'flex-direction': 'row'}
)

template='seaborn'
color_scale='rainbow'

def update_graphs_logic(active_cell):
    if active_cell is None: return []
    pcap_id = active_cell['row_id']
    db = sqlite3.connect(db_path)
    df = pd.read_sql('select * from pcap_queries_2 WHERE pcap_id = %d' % pcap_id, db)
    db.close()

    print('--------------------', df['no-such-name'].sum())

    df['responses'] = df['count'].sub(df['no-response'])
    count = 'count'
    req_tot = df[count].sum()
    res_tot = df['responses'].sum()

    for count in ['count', 'responses']:
        df['%s_log10' % count] = df[count].apply(np.log10).round(0)

    def size_(x):
        if x < 10: return 5
        if x < 100: return 6
        if x < 500: return 7
        if x < 1000: return 8
        return  9

    print('--------------------', df['no-such-name'].sum())

    df['size'] = df['count'].apply(size_)

    df["top10m"] = df["legit_list"].apply(lambda x: 'legit' if x == 1 else 'unknown')

    df.rename(columns={'response-ok': 'ok', 'no-such-name': 'nx', 'no-response': 'no'}, inplace=True)

    df['bad'] = df['count'].sub(df['ok'])
    df['err'] = df['responses'].sub(df['ok'])
    df['oth'] = df['err'].sub(df['nx'])


    print('--------------------', df['nx'].sum())

    return [ dcc.Graph( figure = heatmap_unique(df) ) ]

    figures = []
    # figures += draw_timeline(pcap_id)

    for col in ['ok', 'nx', 'no']:
        for count in ['count', 'responses']:
            if count == 'responses' and col == 'no': continue
            col2 = '%s / %s' % (col, count)
            df[col2] = df[col].div(df[count])
            fig = px.scatter(df,
                    template=template,
                    x=col2,
                    y="nosfx", 
                    color='%s_log10' % count, opacity=0.8,
                    symbol='top10m',
                    hover_data=['query', 'ok', count, 'no', 'nx', 'intervals_mean', 'intervals_std'])
            figures.append(fig)

    textfont = {'family': "Times", 'size': [18, 21, 20], 'color': ["IndianRed", "MediumPurple", "DarkOrange"]}
    for i, figure in enumerate(figures):
        figure.add_hline(y=0.5, line_width=3, line_dash="dash", line_color="black")
        figure.add_vline(x=0.5, line_width=3, line_dash="dash", line_color="black")
        figure.add_annotation(text="<b style='color: red'>True Malware</b>",  xref="x", yref="y", x=-0.1, y=1.1, showarrow=False)
        figure.add_annotation(text="<b style='color: blue'>False Malware</b>", xref="x", yref="y", x= 1.1, y=1.1, showarrow=False)
        figure.add_annotation(text="<b style='color: black'>False Legit</b>", xref="x", yref="y", x=-0.1, y=-0.1, showarrow=False)
        figure.add_annotation(text="<b style='color: grey'>True Legit</b>",  xref="x", yref="y", x= 1.1, y=-0.1, showarrow=False)
        # figure.update_layout(
        #     #coloraxis_colorbar=dict(len=100, lenmode='pixels'),
        #     yaxis=dict(
        #         range=[-0.1, 1.1],
        #         dtick=0.2,
        #         tick0=0,
        #         nticks=5
        #     )
        # )

    figures.append(heatmap_unique(df))

    df['ok/bad'] = df['ok']/df['bad']
    fig = px.scatter(df,
            template=template,
            x='ok/bad',
            y='nosfx', 
            color='no / count', opacity=0.8,
            size='size', size_max=10,
            symbol='top10m',
            hover_data=['query', 'ok', count, 'no', 'nx', 'intervals_mean', 'intervals_std'])
    figures.append(fig)

    df['ok/err'] = df['ok']/df['err']
    fig = px.scatter(df,
            template=template,
            x='ok/err',
            y='nosfx', 
            color='no / count', opacity=0.8,
            size='size', size_max=10,
            symbol='top10m',
            hover_data=['query', 'ok', count, 'no', 'nx', 'intervals_mean', 'intervals_std'])
    figures.append(fig)


    df['ok/err'] = df['ok']/df['err']
    fig = px.scatter(df,
            template=template,
            x='ok/err',
            y='nosfx', 
            color='no / count', opacity=0.8,
            size='size', size_max=10,
            symbol='top10m',
            hover_data=['query', 'ok', count, 'no', 'nx', 'intervals_mean', 'intervals_std'])
    figures.append(fig)

    df_conf = dict(
        true_malware = df[(df['nosfx'] > 0.5) & (df['ok / %s' % count] < 0.5)].shape[0],
        false_malware = df[(df['nosfx'] > 0.5) & (df['ok / %s' % count] > 0.5)].shape[0],
        false_legit = df[(df['nosfx'] < 0.5) & (df['ok / %s' % count] < 0.5)].shape[0],
        true_legit = df[(df['nosfx'] < 0.5) & (df['ok / %s' % count] > 0.5)].shape[0]
    )
    colors = ['red', 'blue', 'black', 'lightgrey']
    fig = go.Figure(data=[go.Pie(labels=list(df_conf.keys()), values=list(df_conf.values()))])
    fig.update_traces(marker=dict(colors=colors, line=dict(color='#000000', width=2)))
    fig.update_layout(title='OK on %s' % count)
    figures.append(fig)

    df_conf = dict(
        true_malware = df[(df['nosfx'] > 0.5) & (df['nx / %s' % count] < 0.5)].shape[0],
        false_malware = df[(df['nosfx'] > 0.5) & (df['nx / %s' % count] > 0.5)].shape[0],
        false_legit = df[(df['nosfx'] < 0.5) & (df['nx / %s' % count] < 0.5)].shape[0],
        true_legit = df[(df['nosfx'] < 0.5) & (df['nx / %s' % count] > 0.5)].shape[0]
    )
    colors = ['red', 'blue', 'black', 'lightgrey']
    fig = go.Figure(data=[go.Pie(labels=list(df_conf.keys()), values=list(df_conf.values()))])
    fig.update_traces(marker=dict(colors=colors, line=dict(color='#000000', width=2)))
    fig.update_layout(title='nx on %s' % count)
    figures.append(fig)

    df_conf = dict(
        response_ok = df['ok'].sum(),
        no_such_name = df['nx'].sum(),
        no_response = df['no'].sum(),
        response_other_error = df['response-error'].sum()-df['nx'].sum(),
    )
    colors = ['red', 'blue', 'black', 'white']
    fig = go.Figure(data=[go.Pie(labels=list(df_conf.keys()), values=list(df_conf.values()))])
    fig.update_traces(marker=dict(colors=colors, line=dict(color='#000000', width=2)))
    figures.append(fig)

    return [ dcc.Graph(figure=figure) for figure in figures ]

@app.callback(
    Output('left-datatable-row-ids-container', 'children'),
    Input('left-datatable-row-ids', 'active_cell'))
def update_graphs(*args, **kwargs):
    return update_graphs_logic(*args, **kwargs)

@app.callback(
    Output('right-datatable-row-ids-container', 'children'),
    Input('right-datatable-row-ids', 'active_cell'))
def update_graphs(*args, **kwargs):
    return update_graphs_logic(*args, **kwargs)

print(px.data.medals_wide(indexed=True))

if __name__ == '__main__':
    app.run_server(debug=False)
