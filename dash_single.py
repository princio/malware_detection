
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from dash.dependencies import Input, Output, State
from plotly.subplots import make_subplots
import sqlite3
import pandas as pd
import os
import plotly.express as px
import numpy as np


db_path = '/media/princio/ssd512/stratosphere/db_3.sqlite3'
dirs = {
    'malware': '/media/princio/ssd512/stratosphere/pcap/csv/malware/',
    'normal': '/media/princio/ssd512/stratosphere/pcap/csv/normal/'
}


try:
    pcap_dict
except NameError:
    pcap_dict = {'normal':{}, 'botnet':{}}
    
try:
    pcap_names
except NameError:
    pcap_names = {'normal':{}, 'botnet':{}}

def get_type(pcapname):
    bot_path = os.path.join(dirs['malware'], pcapname)
    nor_path = os.path.join(dirs['normal'], pcapname)
    if os.path.exists(bot_path):
        type_='botnet'
        df_path = bot_path
    elif os.path.exists(nor_path):
        type_='normal'
        df_path = nor_path
    else:
        return None
    return type_, df_path
    
def get_df(pcapname, reload=False):
    if reload:
        type_, df_path = get_type(pcapname)
        pcap_dict[type_][pcapname] = pd.read_csv(df_path, usecols=list(range(0,12)))
        return pcap_dict[type_][pcapname]
    
    if pcapname in pcap_dict['botnet']:
        return pcap_dict['botnet'][pcapname]
    if pcapname in pcap_dict['normal']:
        return pcap_dict['normal'][pcapname]
    
    type_, df_path = get_type(pcapname)
    pcap_dict[type_][pcapname] = pd.read_csv(df_path, usecols=list(range(0,12)))
    return pcap_dict[type_][pcapname].copy()

def file_list(_dir):
    files = []
    for walker in os.walk(_dir):
        for filenames in walker[2]:
            files.append(os.path.join(_dir, filenames))
    return files

def walkk(dfs, dir_):
    for type_ in ['malware', 'normal']:
        files = file_list(dir_)
        for file in files:
            fname = os.path.basename(file)
            if fname[-4:] != '.csv': continue
            if fname in dfs: continue
            dfs[fname] = pd.read_csv(file, usecols=list(range(0,12)))
        return dfs

default_pcap_id = 15

def draw_graph(pcap_id, query_name=None):
    pcap_name = df_pcap[df_pcap.id == pcap_id].iloc[0]['name'] + '.pcap.csv'
    df = get_df(pcap_name)
    df.index = pd.DatetimeIndex(df['frame.time_epoch_req']*1_000_000_000)
    if query_name is None:
        df = df.drop(columns=['frame.number_req', 'frame.time_epoch_req', 'frame.time_epoch_res', 'dns_server_ip', 'dns.qry.name', 'dns.qry.type'])
        sum_columns = [ 'count', 'no-response', 'response-ok', 'no-such-name', 'legit_list', 'nosfx' ]
        average_columns = [ 'dns.time', 'nosfx_0.1', 'domain_0.1' ]
        df['count'] = 1
        df['no-response'] = df['frame.number_res'].isna().astype(int)
        df['response-ok'] = df['dns.flags.rcode'].apply(lambda x: x == 0).astype(int)
        df['no-such-name'] = df['dns.flags.rcode'].apply(lambda x: x == 3).astype(int)
        df['nosfx'] = df['nosfx_0.1'].apply(lambda x: x > 0.5).astype(int)
        df = df.resample('90T')
        df = pd.concat([df[sum_columns].sum(), df[average_columns].mean()], axis=1)
        df = df.reset_index()
        df = df.melt(id_vars=['frame.time_epoch_req'], value_vars=['response-ok', 'no-response', 'no-such-name']).sort_values(by='frame.time_epoch_req')
        fig = px.bar(df, x='frame.time_epoch_req', y="value", color='variable')
    else:
        df = df[df['dns.qry.name'] == query_name]
        df['nosfx'] = df['nosfx_0.1']
        df['responseness'] = df['dns.flags.rcode'].apply(lambda rc: 'ok' if rc == 0 else 'no-such-name' if rc == 3 else 'no' if np.isnan(rc) else 'err')
        print(df)
        fig = px.scatter(df,
                        x=df.index, y='dns_server_ip',
                        color='responseness',
                        color_discrete_map={'ok': 'blue', 'no-such-name': 'yellow', 'no': 'red', 'err': 'orange'},
                        symbol='legit_list', opacity=0.5)

    return [
        html.H3(pcap_name),
        dcc.Graph(figure=fig, id='graph')
        ]

def get_grouped_table(pcap_id):
    pcap_name = df_pcap[df_pcap.id == pcap_id].iloc[0]['name'] + '.pcap.csv'

    db = sqlite3.connect(db_path)
    df_grouped = pd.read_sql('select * from pcap_queries_2 WHERE pcap_id = %d' % pcap_id, db)
    db.close()
    df_grouped.set_index('query', drop=False, inplace=True)   
    df_grouped.drop(columns=['pcap_id', 'basedomain', 'time_us', 'intervals_mean', 'intervals_std'], inplace=True)
    df_grouped.rename(columns={'no-response': 'res-no', 'response-ok': 'res-ok', 'response-error': 'res-err', 'no-such-name': 'nsn', 'legit_list': 'top10m'}, inplace=True)
    df_grouped['id'] = df_grouped['query']
    return [
        html.H3(pcap_name),
        dash_table.DataTable(
            id='datatable-query',
            columns=[
                {'name': i, 'id': i, 'deletable': True} for i in df_grouped.columns
            ],
            data=df_grouped.to_dict('records'),
            editable=True,
            filter_action='native',
            sort_action='native',
            sort_mode='multi',
            page_action='none',
            style_table={'height': '300px', 'overflowY': 'auto'}
        )
    ]

external_stylesheets = ['./style.css']
app = dash.Dash(__name__, external_stylesheets=external_stylesheets)

db = sqlite3.connect(db_path)
df_pcap = pd.read_sql('select * from pcap', db)
df_grouped = pd.read_sql('select * from pcap_queries_2 WHERE pcap_id = %d' % df_pcap.iloc[default_pcap_id].id, db)
db.close()
df_pcap.set_index('id', drop=False, inplace=True)
df_pcap['uniques/tot'] = df_pcap['uniques/tot'].mul(100).round(2)
df_pcap['name'] = df_pcap['name'].str.slice(0,-9)
df_pcap.drop(columns=['s_id', 's_win', 'qry/h'], inplace=True)
df_pcap.rename(columns={'no-response': 'res-no', 'response-ok': 'res-ok', 'response-error': 'res-err', 'no-such-name': 'nsn', 'legit_list': 'top10m'}, inplace=True)
app.layout = html.Div([
    html.Div([
        dash_table.DataTable(
            id='datatable-pcap',
            columns=[
                {'name': i, 'id': i, 'deletable': True} for i in df_pcap.columns if i != 'id'
            ],
            style_table={'width': '50%', 'height': '300px', 'overflowY': 'auto'},
            style_cell={
                'overflow': 'hidden',
                'textOverflow': 'ellipsis',
                'maxWidth': 0
            },
            tooltip_data=[
                {
                    column: {'value': str(value), 'type': 'markdown'}
                    for column, value in row.items()
                } for row in df_pcap.to_dict('records')
            ],
            data=df_pcap.to_dict('records'),
            editable=True,
            filter_action="native",
            sort_action="native",
            sort_mode='multi',
            page_action='none',
        ),
        html.Div(get_grouped_table(default_pcap_id),
            id='div-datatable-query',
            style={'width': '50%', 'height': '300px', 'overflowY': 'auto'}
        )
    ],
    style={
        # 'display': 'flex',
        # 'flex-direction': 'row',
        'width': '100%'
    }),
    html.Div(
        draw_graph(default_pcap_id, None),
        id='graph-container'),
    html.Div(
        id='click-data')
])


@app.callback(
    Output('div-datatable-query', 'children'),
    Input('datatable-pcap', 'active_cell'))
def update_table(active_cell):
    pcap_id = default_pcap_id if active_cell is None else active_cell['row_id']
    return get_grouped_table(pcap_id)

@app.callback(
    Output('graph-container', 'children'),
    Input('datatable-pcap', 'active_cell'),
    Input('datatable-query', 'active_cell'))
def update_graph(active_cell_pcap, active_cell_query):
    pcap_id = default_pcap_id if active_cell_pcap is None else active_cell_pcap['row_id']
    query_name = None if active_cell_query is None else active_cell_query['row_id']
    return draw_graph(pcap_id, query_name)


@app.callback(
    Output('click-data', 'children'),
    Input('graph', 'selectedData'))
def display_click_data(selectedData):
    import json
    return json.dumps(selectedData, indent=2)

if __name__ == '__main__':
    app.run_server(debug=True)
