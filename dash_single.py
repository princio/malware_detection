
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from dash.dependencies import Input, Output
from plotly.subplots import make_subplots
import sqlite3
import pandas as pd
import os
import plotly.express as px
import numpy as np


db_path = '/media/princio/ssd512/stratosphere/db_3.sqlite3'
dirs = {
    'malware': '/media/princio/ssd512/stratosphere/pcap/csv/malware/',
    'normal': '/media/princio/ssd512/stratosphere/pcap/csv/normal/'
}


try:
    pcap_dict
except NameError:
    pcap_dict = {'normal':{}, 'botnet':{}}
    
try:
    pcap_names
except NameError:
    pcap_names = {'normal':{}, 'botnet':{}}

def get_type(pcapname):
    bot_path = os.path.join(dirs['malware'], pcapname)
    nor_path = os.path.join(dirs['normal'], pcapname)
    if os.path.exists(bot_path):
        type_='botnet'
        df_path = bot_path
    elif os.path.exists(nor_path):
        type_='normal'
        df_path = nor_path
    else:
        return None
    return type_, df_path
    
def get_df(pcapname, reload=False):
    if reload:
        type_, df_path = get_type(pcapname)
        pcap_dict[type_][pcapname] = pd.read_csv(df_path, usecols=list(range(0,12)))
        return pcap_dict[type_][pcapname]
    
    if pcapname in pcap_dict['botnet']:
        return pcap_dict['botnet'][pcapname]
    if pcapname in pcap_dict['normal']:
        return pcap_dict['normal'][pcapname]
    
    type_, df_path = get_type(pcapname)
    pcap_dict[type_][pcapname] = pd.read_csv(df_path, usecols=list(range(0,12)))
    return pcap_dict[type_][pcapname].copy()

def file_list(_dir):
    files = []
    for walker in os.walk(_dir):
        for filenames in walker[2]:
            files.append(os.path.join(_dir, filenames))
    return files

def walkk(dfs, dir_):
    for type_ in ['malware', 'normal']:
        files = file_list(dir_)
        for file in files:
            fname = os.path.basename(file)
            if fname[-4:] != '.csv': continue
            if fname in dfs: continue
            dfs[fname] = pd.read_csv(file, usecols=list(range(0,12)))
        return dfs


pcap_name = '156-1_2016-29-4_capture-win4.pcap.csv'

df = get_df(pcap_name)
df.index = pd.DatetimeIndex(df['frame.time_epoch_req']*1_000_000_000)

def draw_graph(pcap_id, select_only=None, resampling=False):
    df_res = df.copy()
    if select_only is not None:
        df_res = df_res[df_res['dns.qry.name'] == select_only]
    if resampling:
        df_res = df_res.drop(columns=['frame.number_req', 'frame.time_epoch_req', 'frame.time_epoch_res', 'dns_server_ip', 'dns.qry.name', 'dns.qry.type'])
        sum_columns = [ 'count', 'no-response', 'response-ok', 'no-such-name', 'legit_list', 'nosfx' ]
        average_columns = [ 'dns.time', 'nosfx_0.1', 'domain_0.1' ]
        df_res['count'] = 1
        df_res['no-response'] = df_res['frame.number_res'].isna().astype(int)
        df_res['response-ok'] = df_res['dns.flags.rcode'].apply(lambda x: x == 0).astype(int)
        df_res['no-such-name'] = df_res['dns.flags.rcode'].apply(lambda x: x == 3).astype(int)
        df_res['nosfx'] = df_res['nosfx_0.1'].apply(lambda x: x > 0.5).astype(int)
        df_res = df_res.resample('3T')
        df_res = pd.concat([df_res[sum_columns].sum(), df_res[average_columns].mean()], axis=1)
        df_res['nosfxness'] = df_res['nosfx'].div(df_res['count']).fillna(0)#.apply(lambda x: 'resp-ok <0.5' if x < 0.5 else 'resp-ok >0.5')
        df_res['responseness'] = df_res['response-ok'].div(df_res['count']).fillna(0).rsub(1)#.apply(lambda x: 'resp-ok <0.5' if x < 0.5 else 'resp-ok >0.5')
        df_res['legitness'] = df_res['legit_list'].div(df_res['count']).apply(lambda x: 'legit <0.5' if x < 0.5 else 'legit >0.5')
        df_res['count'] = df_res['count'].apply(lambda x: '<100' if x < 100 else '[100,1000]' if x < 1000 else '>1000')
        fig = px.scatter(df_res, x=df_res.index, y="nosfx", color="count", size='responseness', symbol='legitness', hover_data=sum_columns)
    else:
        df_res['nosfx'] = df_res['nosfx_0.1']
        df_res['responseness'] = df_res['dns.flags.rcode'].apply(lambda rc: 'ok' if rc == 0 else 'no-such-name' if rc == 3 else 'no' if np.isnan(rc) else 'err')
        fig = px.scatter(df_res,
        x=df_res.index, y="dns_server_ip",
        color='responseness',
        color_discrete_map={
                "ok": "blue",
                "no-such-name": "yellow",
                "no": "red",
                "err": "orange"},
        symbol='legit_list', opacity=0.5)

    return [dcc.Graph(figure=fig)]



external_stylesheets = ['./style.css']
app = dash.Dash(__name__, external_stylesheets=external_stylesheets)

db = sqlite3.connect(db_path)
df_pcap = pd.read_sql('select * from pcap', db)
df_grouped = pd.read_sql('select * from pcap_queries_2 WHERE pcap_id = %d' % df_pcap.iloc[0].id, db)
db.close()
df_pcap.set_index('id', drop=False, inplace=True)
df_pcap['uniques/tot'] = df_pcap['uniques/tot'].mul(100).round(2)
df_pcap['name'] = df_pcap['name'].str.slice(0,-9)
df_pcap.drop(columns=['s_id', 's_win', 'qry/h'], inplace=True)
df_pcap.rename(columns={'no-response': 'res-no', 'response-ok': 'res-ok', 'response-error': 'res-err', 'no-such-name': 'nsn', 'legit_list': 'top10m'}, inplace=True)
app.layout = html.Div([
    html.Div([
        dash_table.DataTable(
            id='datatable-pcap',
            columns=[
                {'name': i, 'id': i, 'deletable': True} for i in df_pcap.columns if i != 'id'
            ],
            style_table={'width': '50%', 'height': '300px', 'overflowY': 'auto'},
            style_cell={
                'overflow': 'hidden',
                'textOverflow': 'ellipsis',
                'maxWidth': 0
            },
            tooltip_data=[
                {
                    column: {'value': str(value), 'type': 'markdown'}
                    for column, value in row.items()
                } for row in df_pcap.to_dict('records')
            ],
            data=df_pcap.to_dict('records'),
            editable=True,
            filter_action="native",
            sort_action="native",
            sort_mode='multi',
            page_action='none',
        ),
        html.Div(
            id='div-datatable-query',
            style={'width': '50%', 'height': '300px', 'overflowY': 'auto'}
        )
    ],
    style={
        # 'display': 'flex',
        # 'flex-direction': 'row',
        'width': '100%'
    }),
    html.Div(id='graph-container')
])


@app.callback(
    Output('div-datatable-query', 'children'),
    Input('datatable-pcap', 'active_cell'))
def update_table(active_cell):
    if active_cell is None:
        active_cell = { 'row_id': 1 }
    db = sqlite3.connect(db_path)
    df_grouped = pd.read_sql('select * from pcap_queries_2 WHERE pcap_id = %d' % active_cell['row_id'], db)
    db.close()
    df_grouped.set_index('query', drop=False, inplace=True)   
    df_grouped.drop(columns=['pcap_id', 'basedomain', 'time_us', 'intervals_mean', 'intervals_std'], inplace=True)
    df_grouped.rename(columns={'no-response': 'res-no', 'response-ok': 'res-ok', 'response-error': 'res-err', 'no-such-name': 'nsn', 'legit_list': 'top10m'}, inplace=True)

    return dash_table.DataTable(
            id='datatable-query',
            columns=[
                {'name': i, 'id': i, 'deletable': True} for i in df_grouped.columns
            ],
            data=df_grouped.to_dict('records'),
            editable=True,
            filter_action="native",
            sort_action="native",
            sort_mode='multi',
            page_action='none',
            style_table={'height': '300px', 'overflowY': 'auto'}
        )

@app.callback(
    Output('graph-container', 'children'),
    Input('datatable-pcap', 'active_cell_pcap'),
    Input('datatable-query', 'active_cell_query'))
def update_table(active_cell_pcap, active_cell_query):
    if active_cell_pcap is None:
        active_cell = { 'row_id': 1 }
    return draw_graph(active_cell['row_id'], active_cell_query)

if __name__ == '__main__':
    app.run_server(debug=True)
