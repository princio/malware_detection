import os, math, json
import dash
import dash_core_components as dcc
import dash_html_components as html
import dash_table
from dash.dependencies import Input, Output, State
from plotly.subplots import make_subplots
import sqlite3
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go


db_path = '/media/princio/ssd512/stratosphere/db_3.sqlite3'
dirs = {
    'botnet': '/media/princio/ssd512/stratosphere/pcap/csv/malware/',
    'normal': '/media/princio/ssd512/stratosphere/pcap/csv/normal/'
}
pcap_dict = {'normal':{}, 'botnet':{}}
pcap_grouped_dict = {}

DF = None

def get_df(pcap_row, reload=False):
    pcaptype = pcap_row['type']
    pcapname = pcap_row['name']
    df_path = os.path.join(dirs[pcaptype], pcapname)
    pcap_dict[pcaptype][pcapname] = pd.read_csv(df_path, usecols=list(range(0,12)))
    return pcap_dict[pcaptype][pcapname].copy()

default_pcap_id = 46

db = sqlite3.connect(db_path)
df_pcaps = pd.read_sql('SELECT * from pcap', db)
db.close()
df_pcaps = df_pcaps.drop(columns=['s_id', 's_win'])
df_pcaps.set_index('id', inplace=True, drop=False)
df_pcaps['unique_norm'] = df_pcaps['unique_norm'].mul(100).round(2)
df_pcaps.drop(columns=['qry/h'], inplace=True)

def get_row(pcap_id):
    return df_pcaps[df_pcaps.id == pcap_id].iloc[0].to_dict()


def fetch_df_grouped(pcap_id):
    db = sqlite3.connect(db_path)
    df = pd.read_sql('select * from pcap_queries_2 WHERE pcap_id = %d' % pcap_id, db)
    db.close()
    df['responses'] = df['tot'].sub(df['no'])
    req_tot = df['tot'].sum()
    res_tot = df['responses'].sum()
    df['top10m'] = df['top10m'].apply(lambda x: 'legit' if x == 1 else 'unknown')
    df['bad'] = df['tot'].sub(df['ok'])
    df['err'] = df['responses'].sub(df['ok'])
    df['oth'] = df['err'].sub(df['nx'])
    pcap_grouped_dict[pcap_id] = df.copy()
    return df



def heatmap_unique(pcap_row):
    df_or = fetch_df_grouped(pcap_row['id']).copy()

    df = df_or.set_index('query').sort_values(by='tot', ascending=False).reset_index()
    df = df[['no', 'ok', 'nx', 'oth', 'tot', 'nosfx', 'query']].copy()
    keys = 'ok,no,nx,oth'.split(',')

    df = df_or.melt(value_vars=keys, id_vars=['query', 'nosfx'], var_name='rcode', value_name='number').rename(columns={'number': 'tot'})
    df['nosfx_.5'] = (df.nosfx / 0.5 * 0.5).round(2)
    df['nosfx_.25'] = (df.nosfx / 0.25 * 0.25).round(2)
    df['nosfx_.1'] = (df.nosfx / 0.1 * 0.1).round(2)
    df['nosfx_.cut'] = pd.cut(df.nosfx, bins=[0,0.25,0.75,1])
    df = df[df.tot > 0]
    # df['tot'] = 1
    # df['cut'] = pd.cut(df.tot, [0, 1, 10, 100, 1_000, 10_000, 100_000, df.tot.sum()])
    df['tot_qcut'] = pd.qcut(df.tot,  [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1], precision=0, duplicates='drop')
    
    
    # df_g = df.groupby(['rcode', 'nosfx', 'cut']).sum()
    # df_g['query'] = df.groupby(['rcode', 'nosfx', 'cut'])['query'].agg(lambda col: (',<br>'.join(col) + '...'))
    # df = df_g

    
    # df['label'] = 'tot: ' + df['tot'].astype(str) + '<br>unique: ' + df['tot'].astype(str) + '<br>' + df['query']
    df = df.reset_index().sort_values(by='tot')
    df.tot = df.tot * df['tot']
    # print(df[~df.tot.isna()])
    df['tot_log'] = df.tot.apply(np.log10)
    # print(df.sort_values(by='tot_log'))
    
    df.tot_log = df.tot_log.replace(0, 1)
    fig = px.treemap(df,
        path=['nosfx_.cut', 'rcode', 'tot_qcut', 'query'],
        values='tot',
        color='rcode',
        color_discrete_map={'ok':'green', 'no':'grey', 'nx':'orange', 'oth': 'blue'},
        height=600
    )
        # color_continuous_scale=['white', 'red'])#, height=600)
                    # hover_data=['iso_alpha'],
                    # color_continuous_scale='RdBu',
                    # color_continuous_midpoint=np.average(df['lifeExp'], weights=df['pop']))
    return [ dcc.Graph(figure=fig) ]

def draw_pies(pcap_row):
    df_or = fetch_df_grouped(pcap_row['id']).copy()

    df = df_or.copy()

    df_conf = dict(
        ok = df['ok'].sum(),
        nx = df['nx'].sum(),
        no = df['no'].sum(),
        oth = df['oth'].sum()
    )
    colors = ['green', 'orange', 'grey', 'blue']
    fig = go.Figure(data=[go.Pie(labels=list(df_conf.keys()), values=list(df_conf.values()))])
    fig.update_traces(marker=dict(colors=colors, line=dict(color='#000000', width=2)))

    df = df_or.set_index('query').sort_values(by='tot', ascending=False).reset_index()
    df = df[['no', 'ok', 'nx', 'oth', 'tot', 'nosfx', 'query']].copy()
    keys = 'ok,no,nx,oth'.split(',')

    nosfx_slice = 0.5
    df = df_or.melt(value_vars=keys, id_vars=['query', 'nosfx'], var_name='rcode', value_name='number').rename(columns={'number': 'tot'})
    print(df)
    df['nosfx_slice'] = (df.nosfx // nosfx_slice * nosfx_slice).round(2)
    df['nosfx_th'] = df.nosfx.apply(lambda x: 'malware' if x > 0.5 else 'legit')
    df['nosfx_.cut'] = pd.cut(df.nosfx, bins=[0,0.25,0.75,1])
    df = df[df.tot > 0]

    # df['rcode_num'] = df.rcode.map({'ok': 0, 'no':1, 'nx':2, 'oth':3})
    df['colorr'] = df['rcode'] + '/' + df['nosfx_th'].astype(str)

    colors = {
        '(?)': 'white',
        'ok': 'green',
        'ok/malware': 'green',
        'ok/legit': 'lightgreen',
        'no/malware': 'grey',
        'no/legit': 'lightgrey',
        'nx/malware': 'orange',
        'nx/legit': 'lightorange',
        'oth/malware': 'red',
        'oth/legit': 'lightred'
    }

    fig = px.sunburst(df,
        path=[ 'rcode', 'colorr'],
        values='tot',
        labels='colorr',
        color_discrete_map=colors,
        color='colorr'
    )

    fig.update_traces(marker=dict(line=dict(color='#000000', width=0.2)))
    return [ dcc.Graph(figure=fig)]


def draw_timeline(pcap_row):
    df = get_df(pcap_row).rename(columns={'frame.time_epoch_req': 'req_time'})
    df['req_time'] = pd.DatetimeIndex(df['req_time']*1_000_000_000)
    n = df.shape[0]
    y = math.ceil(math.sqrt((3/4) * n))
    x = math.ceil(n / y)

    rows = [ df['req_time'].iloc[i * x] for i in range(y) ]
    rows = pd.Series(rows).dt.strftime('%-j %H:%M:%S')
    cols = np.arange(0,x)

    nans = np.empty(x*y - df.shape[0])
    nans[:] = np.nan

    text = 'query: ' +  df['dns.qry.name'] + '<br>rcode: ' + df['dns.flags.rcode'].fillna('no').astype(str)
    queries = text.values
    text = np.reshape(np.concatenate((text, nans)), (y, x))

    rcode = df['dns.flags.rcode'].fillna(-1).values
    rcode = np.where(rcode == 3, 0.25, rcode)
    rcode = np.where(rcode == 2, 4, rcode)
    rcode = np.where(rcode > 3, 0.5, rcode)
    rcode = np.where(rcode == -1, 1, rcode)
    rcode = np.reshape(np.concatenate((rcode, nans)), (y, x))


    fig = make_subplots(
        cols = 2, rows = 1,
        column_widths = [0.5, 0.5],
        subplot_titles = ('timeline by nosfx', 'timeline by rcode'),
        specs = [[{'type': 'heatmap'}, {'type': 'heatmap'}]]
    )

    fig.add_trace(
        go.Heatmap(
            z=rcode,
            x=cols,
            y=rows,
            text=text,
            zmin=0, zmax=1,
            colorscale=[
                [0, 'green'], [0.25, 'green'],
                [0.25, 'orange'], [0.5, 'orange'],
                [0.5, 'red'], [0.75, 'red'],
                [0.75, 'black'], [1, 'black'],
            ],
            colorbar=dict(tick0=0, dtick=1,
                                thickness=25,
                                tickmode='array',
                                tickvals=[0.125, 0.375, 0.625, 0.875], 
                                ticktext=['ok', 'nx', 'err', 'no']
                    )
        ),
        row=1, col=2
    )

    nosfx = np.reshape(np.concatenate((df['nosfx_0.1'].values, nans)), (y, x))
    fig.add_trace(
        go.Heatmap(
            x=cols, y=rows, z=nosfx,
            zmin=0, zmax=1,
            text=text,
            colorscale=[
                [0, 'white'], [1, 'red'],
            ],
            showscale=False
        ),
        row=1, col=1
    )

    # fig.update_layout(margin=dict(l=0,r=200,b=0,t=0,pad=4))
    # fig.update_layout(title='rcode', yaxis_nticks=20, xaxis_nticks=36, row=1, col=1)
    # fig.update_layout(title='nosfx', yaxis_nticks=20, xaxis_nticks=36, row=1, col=2)

    return [ dcc.Graph(figure=fig) ]

def get_grouped_table(pcap_row):
    pcapname = pcap_row['name'] + '.pcap.csv'
    df = fetch_df_grouped(pcap_row['id']).copy()
    df.set_index('query', drop=False, inplace=True)   
    df.drop(columns=['pcap_id', 'basedomain', 'time_us', 'intervals_mean', 'intervals_std'], inplace=True)
    df['id'] = df['query']
    return [
        html.H3(pcapname),
        dash_table.DataTable(
            id='datatable-query',
            columns=[
                {'name': i, 'id': i, 'deletable': True} for i in df.columns
            ],
            data=df.to_dict('records'),
            editable=True,
            filter_action='native',
            sort_action='native',
            sort_mode='multi',
            page_action='none',
            style_table={'height': '300px', 'overflowY': 'auto'}
        )
    ]

external_stylesheets = ['./style.css']
app = dash.Dash(__name__, external_stylesheets=external_stylesheets)
app.title = 'Dash Single PCAP'
app.layout = html.Div([
    dash_table.DataTable(
        id='datatable-pcap',
        columns=[
            {'name': i, 'id': i, 'deletable': True} for i in df_pcaps.columns if i != 'id'
        ],
        style_table={'height': '150px', 'overflowY': 'auto'},
        style_cell={
            'overflow': 'hidden',
            'textOverflow': 'ellipsis',
            'maxWidth': 0
        },
        tooltip_data=[
            {
                column: {'value': str(value), 'type': 'markdown'}
                for column, value in row.items()
            } for row in df_pcaps.to_dict('records')
        ],
        data=df_pcaps.to_dict('records'),
        editable=True,
        filter_action="native",
        sort_action="native",
        sort_mode='multi',
        page_action='none',
    ),
    html.Div(
        draw_timeline(get_row(default_pcap_id)),
        id='timeline-container'
    ),
    html.Div(
        draw_pies(get_row(default_pcap_id)),
        id='pies-container'
    ),
    html.Div(
        heatmap_unique(get_row(default_pcap_id)),
        id='graph-container'
    ),
    html.Div(
        get_grouped_table(get_row(default_pcap_id)),
        id='div-datatable-query',
        style={'height': '300px', 'overflowY': 'auto'}
    )
])


@app.callback(
    Output('pies-container', 'children'),
    Input('datatable-pcap', 'active_cell'))
def update_pies(active_cell):
    pcap_id = default_pcap_id if active_cell is None else active_cell['row_id']
    return draw_pies(get_row(pcap_id))

@app.callback(
    Output('div-datatable-query', 'children'),
    Input('datatable-pcap', 'active_cell'))
def update_table(active_cell):
    pcap_id = default_pcap_id if active_cell is None else active_cell['row_id']
    return get_grouped_table(get_row(pcap_id))

@app.callback(
    Output('timeline-container', 'children'),
    Input('datatable-pcap', 'active_cell'))
def update_timeline(active_cell):
    pcap_id = default_pcap_id if active_cell is None else active_cell['row_id']
    return draw_timeline(get_row(pcap_id))

@app.callback(
    Output('graph-container', 'children'),
    Input('datatable-pcap', 'active_cell'))
def update_graph(active_cell):
    pcap_id = default_pcap_id if active_cell is None else active_cell['row_id']
    return heatmap_unique(get_row(pcap_id))


if __name__ == '__main__':
    app.run_server(debug=False, port=8051)
