
class Report{
    id;
    model_id;
    dataset_id;
    model;
    dataset;
    datetime;
    time_elapsed;
    confusion_matrix;
    labels;

    metrics = {};
    accuracy =  0;
    supports = {};

    static fill(row) {
        const report = new Report();
        for(const key in row) {
            if( ! (key in report) ) throw `Error in Report.fill(): fetched key '${key}' not present`;
            report[key] = row[key];
        }

        return report;
    }

    calc_metrics () {
        if(!this.confusion_matrix || !this.labels) throw "Labels or ConfusionMatrix cannot be undefined.";
        let tot = 0;
        const tp_s = [];
        const tp_plus_fp_s = new Array(this.labels.length).fill(0);
        const supports = new Array(this.labels.length).fill(0);

        for(let i = 0; i < this.confusion_matrix.length; i++) {
            let row = Math.floor(i / this.labels.length);
            let column = i % this.labels.length;
            tot += this.confusion_matrix[i];
            if(row === column)
                tp_s.push(this.confusion_matrix[i]);
            supports[row] += this.confusion_matrix[i];
            tp_plus_fp_s[column] += this.confusion_matrix[i];
        }

        const metrics = {
            macro: { precision: 0, recall: 0, f1_score: 0 },
            weigthed: { precision: 0, recall: 0, f1_score: 0 }
        };
        for(let i = 0; i < this.labels.length; i++) {
            metrics[this.labels[i]] = {
                precision: tp_s[i] / tp_plus_fp_s[i],
                recall: tp_s[i] / supports[i],
                f1_score: 0
            };
            metrics[this.labels[i]].f1_score = 2 * metrics[this.labels[i]].precision * metrics[this.labels[i]].recall / (metrics[this.labels[i]].precision + metrics[this.labels[i]].recall)
            metrics.macro.precision += metrics[this.labels[i]].precision;
            metrics.macro.recall += metrics[this.labels[i]].recall;
            metrics.macro.f1_score += metrics[this.labels[i]].f1_score;

            metrics.weigthed.precision += metrics[this.labels[i]].precision * supports[i];
            metrics.weigthed.recall += metrics[this.labels[i]].recall * supports[i];
            metrics.weigthed.f1_score += metrics[this.labels[i]].f1_score * supports[i];

            this.accuracy += tp_s[i];
        }

        metrics.macro.precision /= this.labels.length;
        metrics.macro.recall /= this.labels.length;
        metrics.macro.f1_score /= this.labels.length;

        metrics.weigthed.precision /= tot;
        metrics.weigthed.recall /= tot;
        metrics.weigthed.f1_score /= tot;

        this.accuracy /= tot;
        this.supports = supports;

        this.metrics = metrics;
    }
}

module.exports = Report;