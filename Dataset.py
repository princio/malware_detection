import csv
import random
import datetime
import hashlib
from json import dumps as json_dumps

class Dataset:
    def __init__(self):
        self.id = None
        self.hash = None
        self.name = None
        self.date = None
        self.type = None
        self.inputs_number = None
        self.supports = None
        self.labels = None
        self.dga = None

        self._data = []
        self.shuffled = False

    @staticmethod
    def fromdata(connection, data, path):
        dataset = Dataset()

        with open(path, "w+") as f:
            writer = csv.writer(f)
            writer.writerows(data)

        sha256_hash = hashlib.sha256()
        with open(path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        dataset.hash = sha256_hash.hexdigest()

        dataset.name = path.split('/')[-1][:-4]

        
        row_counter = 0
        label_number = { 'legit': 0, 'dga': 0 }
        dga = {}
        for row in data:
            row_counter = row_counter + 1
            label_number[row[0]] += 1
            if row[0] != 'legit':
                dga_name = 'unknown' if row[1] == ' ' else row[1]
                if dga_name not in dga:
                    dga[dga_name] = 0
                dga[dga_name] += 1

        dataset.labels = list(label_number.keys())
        dataset.supports = list(label_number.values())
        dataset.dga = dga
        dataset.inputs_number = dataset.supports[0] + dataset.supports[1]
        dataset.type = 'benign' if dataset.supports[0] > dataset.supports[1] else 'malware'

        dataset.save(connection)

        return dataset

    @staticmethod
    def fetch(connection, id):
        cursor = connection.cursor()
        cursor.execute("""SELECT id, hash, name, type, inputs_number, date, supports, labels, dga
	                        FROM public.datasets WHERE id=%s;""", (id, ))
                            
        return Dataset.fill(cursor.fetchone())

    @staticmethod
    def fill(fetched):
        fetched = list(fetched)
        dataset = Dataset()
        dataset.id = fetched.pop(0)
        dataset.hash = fetched.pop(0)
        dataset.name = fetched.pop(0)
        dataset.type = fetched.pop(0)
        dataset.inputs_number = fetched.pop(0)
        dataset.date = fetched.pop(0)
        dataset.supports = fetched.pop(0)
        dataset.labels = fetched.pop(0)
        dataset.dga = fetched.pop(0)

        return dataset

    def save(self, connection):
        cursor = connection.cursor()
        cursor.execute("""INSERT INTO public.datasets
                        (hash, name, type, inputs_number, date, supports, labels, dga)
                        VALUES (%s, %s, %s, %s, %s, %s, %s, %s) RETURNING id;""",
                        (self.hash, self.name, self.type, self.inputs_number, self.date, self.supports, self.labels, json_dumps(self.dga)))
        self.id = cursor.fetchone()[0]
        connection.commit()
        
    def update(self, connection):
        cursor = connection.cursor()
        cursor.execute("""UPDATE public.datasets
                        SET hash=%s, name=%s, type=%s, inputs_number=%s, date=%s, supports=%s, labels=%s, dga=%s
                        WHERE id=%s;""",
                        (self.hash, self.name, self.type, self.inputs_number, self.date, self.supports, self.labels, json_dumps(self.dga), self.id))
        connection.commit()

    def data(self):
        if len(self._data) > 0:
            return self._data

        with open(f"datasets/{self.type}_h_t/{self.name}", "r") as f:
            reader = csv.reader(f)
            for row in reader:
                self._data.append(row)

        return self._data
 
    @staticmethod
    def shuffle(dataset, connection):
        data = dataset.data()

        random.shuffle(data)

        shuffled_dataset = Dataset()

        shuffled_dataset._data = data
        
        shuffled_dataset.id = None
        shuffled_dataset.date = datetime.datetime.now()
        date_str = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        shuffled_dataset.name = f"{dataset.name[:-4]}_shuffled_{date_str}.csv"
        shuffled_dataset.type = dataset.type
        shuffled_dataset.inputs_number = dataset.inputs_number
        shuffled_dataset.labels = dataset.labels
        shuffled_dataset.supports = dataset.supports
        shuffled_dataset.shuffled = True

        str_ = ""
        with open(f"datasets/{shuffled_dataset.type}_h_t/{shuffled_dataset.name}", "w") as f:
            for row in data:
                str_ = str_ + ",".join(row) + "\n"
                f.write(",".join(row) + "\n")
        sha256_hash = hashlib.sha256()
        sha256_hash.update(str_.encode())
        shuffled_dataset.hash = sha256_hash.hexdigest()

        print(dataset.hash + "\n" + shuffled_dataset.hash)

        shuffled_dataset.save(connection)

        return shuffled_dataset

    def __str__(self):
        return "%s/%s" % (self.type, self.name)