import psycopg2, csv, numpy as np, matplotlib.pyplot as plt, time
from math import log
from plot_llr import plot_llr
from plot_num import plot_num
from Pcap import Pcap
from Repository import ModelRepository
import os, itertools
import csv_inspector

plt.set_loglevel("warning")

connection = psycopg2.connect(user = "postgres", password = "porcodio", host = "127.0.0.1", port = "5432", database = "malware")

_id_mio = 'fb9ffddd-de28-439c-8ae5-3473f390e6cf'
id_granatiero = 'c62c1bed-722f-4a7e-b0a8-09d2b50e9732'


# wrapt                               1.12.1-py37h7b6447c_1 --> 1.11.2-py37h7b6447c_0
# mixed 1 | 6747
# mixed 4 | 175

normal = {
    '27': [{ 'path': 'datasets/pcaps/normal_27/2017_04_30-normal.pcap.csv', 'len': 26461, 'frame_infection_number': None}],
    '31': [{ 'path': 'datasets/pcaps/normal_31/2017-05-01_normal.pcap.csv', 'len': 40122, 'frame_infection_number': None}]
}
mixed = {
    '1': [{ 'path': 'datasets/pcaps/mixed_capture_1/mixed.csv', 'len': 32251, 'frame_infection_number': 6747}],
    '2': [{ 'path': 'datasets/pcaps/mixed_capture_2/mixed.csv', 'len': 4319, 'frame_infection_number': None}],
    '3': [{ 'path': 'datasets/pcaps/mixed_capture_3/mixed.csv', 'len': 763, 'frame_infection_number': None}],
    '4': [{ 'path': 'datasets/pcaps/mixed_capture_4/mixed.csv', 'len': 407, 'frame_infection_number': 174}]
}
botnets = {
    '1': [{
        'path': 'datasets/pcaps/botnet-1/2013-10-01_capture-win12.pcap.csv',
        'name': '2013-10-01_capture-win12.pcap.csv',
        'len': 12145,
        'frame_infection_number': None
    }],
    '3': [{
        'path': 'datasets/pcaps/botnet-3/2013-08-20_capture-win15.pcap.csv',
        'name': '2013-08-20_capture-win15.pcap.csv',
        'len': 188683,
        'frame_infection_number': None
    }],
    '4': [{
        'path': 'datasets/pcaps/botnet-4/2013-08-20_capture-win5.pcap.csv',
        'name': '2013-08-20_capture-win5.pcap.csv',
        'notes': 'X-sinkhole,malware-sinkhole,variant of PushDo botnet',
        'len': 36,
        'frame_infection_number': None
    }],
    '5': [{
        'path': 'datasets/pcaps/botnet-5/2013-08-20_capture-win12.pcap.csv',
        'name': '2013-08-20_capture-win12.pcap.csv',
        'notes': 'Zeus',
        'len': 2782597,
        'frame_infection_number': None,
        'out-file': '2013-08-20_capture-win12.pcap.csv.out.csv'
        },{
        'path': 'datasets/pcaps/botnet-5/2013-08-20_capture-win13.pcap.csv',
        'name': '2013-08-20_capture-win13.pcap.csv',
        'notes': 'Zeus',
        'len': 468388,
        'frame_infection_number': None
    }]
}

def plott():
    pcap_botnet_num1 = 5
    pcap_botnet_num2 = 0
    botnet = botnets[str(pcap_botnet_num1)][pcap_botnet_num2]
    frame_infection_number = botnet['frame_infection_number']
    out_csv = '%s.out.csv' % botnet['path']

    if os.path.exists(out_csv):
        with open(out_csv, 'r') as f:
            reader = csv.reader(f)
            data = [[row[0], row[1], row[2]] for row in reader]
            predictions = np.asarray([float(row[2]) for row in data])
    else:
        model = ModelRepository.fetch(connection, id_granatiero)
        pcap = Pcap(botnet['path'])
        predictions, _, _ = model.predict_csv(csv_in_path=pcap.path, column=3, csv_out_path=out_csv)

    domains = csv_inspector.inspect(out_csv)

    predictions[predictions == 1] = 1 - 1E-12
    predictions[predictions == 0] = 1E-12

    llr = np.log(predictions/(1-predictions))

    deltas = [int(botnet['len']*0.025), int(botnet['len']*0.05)]
    
    # LLR = plot_llr(llr, frame_infection_number, deltas=deltas)

    # deltas_llr = [100, 200]
    # LLR = plot_llr(llr, frame_infection_number, deltas=deltas_llr)
    # _fig, axs = plt.subplots(len(deltas_llr))  # Create a figure and an axes.
    # for idx, delta in enumerate(deltas_llr):
    #     axs[idx].plot(np.arange(0, len(LLR[delta])), LLR[delta], label=f'Î´={delta}')
    #     axs[idx].legend()
    #     axs[idx].set_xlim(0, len(llr))
    #     if frame_infection_number is not None:
    #         axs[idx].axvline(x=frame_infection_number)

    deltas = [int(botnet['len']*0.026), int(botnet['len']*0.05)]
    x, good_binary, bad_binary, good_float, bad_float = plot_num(predictions, frame_infection_number, deltas=deltas)
    _fig, axs = plt.subplots(2, len(deltas))  # Create a figure and an axes.  
    for idx, delta in enumerate(deltas):
        axs[0, idx].plot(x[delta], good_binary[delta], label=f'good_binary')
        axs[0, idx].plot(x[delta], bad_binary[delta], label=f'bad_binary')
        axs[0, idx].set_title(f'binary prediction sum with delta={delta}')
        axs[0, idx].legend()

        axs[1, idx].plot(x[delta], good_float[delta], label=f'good_float')
        axs[1, idx].plot(x[delta], bad_float[delta], label=f'bad_float')
        axs[1, idx].set_title(f'float prediction with delta={delta}')
        axs[1, idx].legend()

        if frame_infection_number is not None:
            axs[0, idx].axvline(x=frame_infection_number, color='red')
            axs[1, idx].axvline(x=frame_infection_number, color='red')

    plt.show()

    pass

if __name__ == "__main__":
    import matplotlib.rcsetup as rcsetup
    plott()

    pass