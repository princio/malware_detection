import psycopg2
import os, json
from Model import Model
from Pcap import Pcap
from Repository import ModelRepository
from math import log
import numpy as np
import matplotlib.pyplot as plt
import math

plt.set_loglevel("warning")

connection = psycopg2.connect(user = "postgres",
                                  password = "porcodio",
                                  host = "127.0.0.1",
                                  port = "5432",
                                  database = "malware")

def llr():
    id_mio = 'fb9ffddd-de28-439c-8ae5-3473f390e6cf'
    id_granatiero = 'c62c1bed-722f-4a7e-b0a8-09d2b50e9732'
    model = ModelRepository.fetch(connection, id_granatiero)

    pcap_name = 'mixed_capture_4/mixed'
    pcap = Pcap(f'datasets/pcaps/{pcap_name}.csv')
    frame_detection_number = 174

    predictions, _ = model.predict_pcap(pcap, csv_path=f'datasets/pcaps/{pcap_name}.out.csv')

    predictions = np.asarray(predictions.ravel(), dtype='float64')

    rows = ["%s,%f\n" % (pcap.data[idx][3], p) for idx, p in enumerate(predictions)]

    with open(f'output/pcap_{pcap.name}_model_{model.name()}.txt', 'w') as fp:
        fp.writelines(rows)

    llr = np.log(predictions/(1-predictions))


    _fig, axss = plt.subplots(5, 3)  # Create a figure and an axes.

    deltas = [1, 25, 50, 100]
    axs = axss[:,0]
    LLR = {}
    for idx, delta in enumerate(deltas):
        LLR[delta] = np.zeros((len(predictions)-delta+1,))
        for z in range(len(predictions)-delta+1):
            for i in range(z, z + delta):
                LLR[delta][z] += llr[i]
        axs[idx].plot(np.arange(0, len(LLR[delta])), LLR[delta], label=f'δ={delta}')
        axs[idx].legend()
        axs[idx].set_xlim(0, len(llr))
        axs[idx].axvline(x=frame_detection_number)

    deltas = [5, 25, 50, 100]
    axs = axss[:,1]
    LLR = {}
    for idx, delta in enumerate(deltas):
        slices_number = math.ceil(len(predictions)/delta)
        LLR[delta] = np.zeros(slices_number)
        for z in range(0, slices_number):
            l = (z+1)*delta if (z+1)*delta < len(llr) else len(llr)
            for i in range(z*delta, l):
                LLR[delta][z] += predictions[i]
            LLR[delta][z] /= l
        axs[idx].plot(np.arange(0, len(predictions), step=delta), LLR[delta], label=f'δ={delta}')
        axs[idx].legend()
        axs[idx].set_xlim(0, len(llr))
        axs[idx].axvline(x=frame_detection_number)

    deltas = [5, 25, 50, 100]
    axs = axss[:,1]
    benign = np.zeros(len(predictions))
    malign = np.zeros(len(predictions))
    if predictions[0] <= 0.5:
        benign[0] += 1
    else:
        malign[0] += 1
    for i in range(1, len(predictions)):
        benign[i] = benign[i-1]
        malign[i] = malign[i-1]
        if predictions[i] <= 0.5:
            benign[i] += 1
        else:
            malign[i] += 1

    graph_b = np.zeros(len(predictions))  
    graph_m = np.zeros(len(predictions))  
    ax = axss[1,2]
    delta = 10
    for z in range(0, len(predictions), delta):
        benign = 0
        malign = 0
        for i in range(z, np.min([len(predictions), z + delta])):
            if predictions[i] <= 0.5:
                benign += 1
            else:
                malign += 1
        for i in range(z, np.min([len(predictions), z + delta])):
            graph_b[i] = benign
            graph_m[i] = malign
    ax.plot(np.arange(0, len(predictions)), graph_m, label=f'malign')
    ax.legend()
    ax.axhline(y=delta)


    graph_b = np.zeros(len(predictions))  
    graph_m = np.zeros(len(predictions))
    graph_sum = np.zeros(len(predictions))
    ax = axss[2,2]
    delta = 50
    for z in range(0, len(predictions), delta):
        benign = 0
        malign = 0
        for i in range(z, np.min([len(predictions), z + delta])):
            if predictions[i] <= 0.5:
                benign += 0.5 - predictions[i]
            else:
                malign += predictions[i] - 0.5
        for i in range(z, np.min([len(predictions), z + delta])):
            graph_b[i] = benign
            graph_m[i] = malign
            graph_sum[i] = malign + benign
    ax.plot(np.arange(0, len(predictions)), graph_b, label=f'benign')
    ax.plot(np.arange(0, len(predictions)), graph_m, label=f'malign')
    ax.plot(np.arange(0, len(predictions)), graph_sum, label=f'sum')
    ax.legend()
    ax.axhline(y=delta/2)
    ax.axvline(x=frame_detection_number)

    b_av = 0
    b_count = 0
    m_av = 0
    m_count = 0
    for i in range(len(predictions)):
        if predictions[i] <= 0.5:
            b_av += predictions[i]
            b_count += 1
        else:
            m_av += predictions[i]
            m_count += 1
    axss[3,2].plot(np.arange(0, len(predictions)), predictions, label=f'predictions')
    axss[3,2].legend()  # Add a legend.
    axss[3,2].set_xlim(0, len(llr))
    axss[3,2].axvline(x=frame_detection_number)



    deltas = [5, 25, 50, 100]
    axs = axss[4,1]
    sums = {}
    deriv = {}
    graph = {}
    for idx, delta in enumerate(deltas):
        slices_number = math.ceil(len(predictions)/delta)
        sums[delta] = np.zeros(slices_number)
        deriv[delta] = np.zeros(slices_number)
        graph[delta] = np.zeros(len(predictions))

        for z in range(0, slices_number):
            l = (z+1)*delta if (z+1)*delta < len(llr) else len(llr)
            for i in range(z*delta, l):
                if predictions[i] > 0.5:
                    sums[delta][z] += predictions[i]
            if z > 0:
                deriv[delta][z] = sums[delta][z] - deriv[delta][z-1]
            else:
                deriv[delta][z] = sums[delta][z]
            for i in range(z*delta, l):
                graph[delta][i] = deriv[delta][z]
        axs.plot(np.arange(0, len(graph[delta])), graph[delta], label=f'δ={delta}')
        axs.legend()
        axs.set_xlim(0, len(llr))
        axs.axvline(x=frame_detection_number)
    
    plt.show()

    b_bef, m_bef = 0, 0
    for i in range(frame_detection_number):
        if predictions[i] < 0.5:
            b_bef += 1
        else:
            m_bef += 1

    b_aft, m_aft = 0, 0
    for i in range(frame_detection_number, len(predictions)):
        if predictions[i] < 0.5:
            b_aft += 1
        else:
            m_aft += 1

    print("%d %d | %d | %d %d" % (b_bef, m_bef, frame_detection_number, b_aft, m_aft))
    pass

if __name__ == "__main__":
    import matplotlib.rcsetup as rcsetup
    llr()


    # for delta in [3,5]:
    #     print("delta=%d" % delta)
    #     for z in range(13-delta + 1):
    #         for i in range(z, z + delta):
    #             print("%5d %5d" % (z, i))
    #         print("----")

    pass